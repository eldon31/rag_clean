How to Use Multivector Representations with Qdrant Effectively - Qdrant

[](https://qdrant.tech/)

- [Qdrant](https://qdrant.tech/documentation/)
- [Cloud](https://qdrant.tech/documentation/cloud-intro/)
- [Build](https://qdrant.tech/documentation/build/)
- [Learn](https://qdrant.tech/articles/)
- [API Reference](https://api.qdrant.tech/api-reference)

Search

[Log in](https://cloud.qdrant.io/login) [Start Free](https://cloud.qdrant.io/signup)

Search

- [Qdrant](https://qdrant.tech/documentation/)
- [Cloud](https://qdrant.tech/documentation/cloud-intro/)
- [Build](https://qdrant.tech/documentation/build/)
- [Learn](https://qdrant.tech/articles/)
- [API Reference](https://api.qdrant.tech/api-reference)

### Getting Started

[What is Qdrant?](https://qdrant.tech/documentation/overview/)

- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)

[Local Quickstart](https://qdrant.tech/documentation/quickstart/)

[API & SDKs](https://qdrant.tech/documentation/interfaces/)

[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)

### User Manual

[Concepts](https://qdrant.tech/documentation/concepts/)

- [Collections](https://qdrant.tech/documentation/concepts/collections/)
- [Points](https://qdrant.tech/documentation/concepts/points/)
- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)
- [Payload](https://qdrant.tech/documentation/concepts/payload/)
- [Search](https://qdrant.tech/documentation/concepts/search/)
- [Explore](https://qdrant.tech/documentation/concepts/explore/)
- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)
- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)
- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)
- [Storage](https://qdrant.tech/documentation/concepts/storage/)
- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)
- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)

[Guides](https://qdrant.tech/documentation/guides/installation/)

- [Installation](https://qdrant.tech/documentation/guides/installation/)
- [Administration](https://qdrant.tech/documentation/guides/administration/)
- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)
- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)
- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)
- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)
- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)
- [Quantization](https://qdrant.tech/documentation/guides/quantization/)
- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)
- [Configuration](https://qdrant.tech/documentation/guides/configuration/)
- [Security](https://qdrant.tech/documentation/guides/security/)
- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)
- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)

### Ecosystem

[FastEmbed](https://qdrant.tech/documentation/fastembed/)

- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)
- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)
- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)
- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)
- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)
- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)

[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)

### Tutorials

[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)

- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)
- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)
- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)
- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)

[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)

- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)
- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)
- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)
- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)
- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)

[Using the Database](https://qdrant.tech/documentation/database-tutorials/)

- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)
- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)
- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)
- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)
- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)
- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)
- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)

### Support

[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)

- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)
- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)

[Release Notes](https://github.com/qdrant/qdrant/releases)

### Getting Started

[What is Qdrant?](https://qdrant.tech/documentation/overview/)

- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)

[Local Quickstart](https://qdrant.tech/documentation/quickstart/)

[API & SDKs](https://qdrant.tech/documentation/interfaces/)

[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)

### User Manual

[Concepts](https://qdrant.tech/documentation/concepts/)

- [Collections](https://qdrant.tech/documentation/concepts/collections/)
- [Points](https://qdrant.tech/documentation/concepts/points/)
- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)
- [Payload](https://qdrant.tech/documentation/concepts/payload/)
- [Search](https://qdrant.tech/documentation/concepts/search/)
- [Explore](https://qdrant.tech/documentation/concepts/explore/)
- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)
- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)
- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)
- [Storage](https://qdrant.tech/documentation/concepts/storage/)
- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)
- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)

[Guides](https://qdrant.tech/documentation/guides/installation/)

- [Installation](https://qdrant.tech/documentation/guides/installation/)
- [Administration](https://qdrant.tech/documentation/guides/administration/)
- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)
- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)
- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)
- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)
- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)
- [Quantization](https://qdrant.tech/documentation/guides/quantization/)
- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)
- [Configuration](https://qdrant.tech/documentation/guides/configuration/)
- [Security](https://qdrant.tech/documentation/guides/security/)
- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)
- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)

### Ecosystem

[FastEmbed](https://qdrant.tech/documentation/fastembed/)

- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)
- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)
- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)
- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)
- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)
- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)

[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)

### Tutorials

[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)

- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)
- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)
- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)
- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)

[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)

- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)
- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)
- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)
- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)
- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)

[Using the Database](https://qdrant.tech/documentation/database-tutorials/)

- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)
- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)
- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)
- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)
- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)
- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)
- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)

### Support

[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)

- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)
- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)

[Release Notes](https://github.com/qdrant/qdrant/releases)

- [Documentation](https://qdrant.tech/documentation/)
-
- [Advanced tutorials](https://qdrant.tech/documentation/advanced-tutorials/)
-
- How to Use Multivector Representations with Qdrant Effectively

# How to Effectively Use Multivector Representations in Qdrant for Reranking

Multivector Representations are one of the most powerful features of Qdrant. However, most people don‚Äôt use them effectively, resulting in massive RAM overhead, slow inserts, and wasted compute.

In this tutorial, you‚Äôll discover how to effectively use multivector representations in Qdrant.

## What are Multivector Representations?

In most vector engines, each document is represented by a single vector - an approach that works well for short texts but often struggles with longer documents. Single vector representations perform pooling of the token-level embeddings, which obviously leads to losing some information.

Multivector representations offer a more fine-grained alternative where a single document is represented using multiple vectors, often at the token or phrase level. This enables more precise matching between specific query terms and relevant parts of the document. Matching is especially effective in Late Interaction models like [ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/), which retain token-level embeddings and perform interaction during query time leading to relevance scoring.

As you will see later in the tutorial, Qdrant supports multivectors and thus late interaction models natively.

## Why Token-level Vectors are Useful

With token-level vectors, models like ColBERT can match specific query tokens to the most relevant parts of a document, enabling high-accuracy retrieval through Late Interaction.

In late interaction, each document is converted into multiple token-level vectors instead of a single vector. The query is also tokenized and embedded into various vectors. Then, the query and document vectors are matched using a similarity function: MaxSim. You can see how it is calculated [here](https://qdrant.tech/documentation/concepts/vectors/#multivectors).

In traditional retrieval, the query and document are converted into single embeddings, after which similarity is computed. This is an early interaction because the information is compressed before retrieval.

## What is Rescoring, and Why is it Used?

Rescoring is two-fold:

- Retrieve relevant documents using a fast model.
- Rerank them using a more accurate but slower model such as ColBERT.

## Why Indexing Every Vector by Default is a Problem

In multivector representations (such as those used by Late Interaction models like ColBERT), a single logical document results in hundreds of token-level vectors. Indexing each of these vectors individually with HNSW in Qdrant can lead to:

- High RAM usage
- Slow insert times due to the complexity of maintaining the HNSW graph

However, because multivectors are typically used in the reranking stage (after a first-pass retrieval using dense vectors), there‚Äôs often no need to index these token-level vectors with HNSW.

Instead, they can be stored as multi-vector fields (without HNSW indexing) and used at query-time for reranking, which reduces resource overhead and improves performance.

For more on this, check out Qdrant‚Äôs detailed breakdown in our [Scaling PDF Retrieval with Qdrant tutorial](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/#math-behind-the-scaling).

With Qdrant, you have full control of how indexing works. You can disable indexing by setting the HNSW `m` parameter to `0`:

```python
from qdrant_client import QdrantClient, models

client = QdrantClient("http://localhost:6333")
collection_name = "dense_multivector_demo"
client.create_collection(
    collection_name=collection_name,
    vectors_config={
        "dense": models.VectorParams(
            size=384,
            distance=models.Distance.COSINE
            # Leave HNSW indexing ON for dense
        ),
        "colbert": models.VectorParams(
            size=128,
            distance=models.Distance.COSINE,
            multivector_config=models.MultiVectorConfig(
                comparator=models.MultiVectorComparator.MAX_SIM
            ),
            hnsw_config=models.HnswConfigDiff(m=0)  # Disable HNSW for reranking
        )
    }
)
```

By disabling HNSW on multivectors, you:

- Save compute.
- Reduce memory usage.
- Speed up vector uploads.

## How to Generate Multivectors Using FastEmbed

Let‚Äôs demonstrate how to effectively use multivectors using [FastEmbed](https://github.com/qdrant/fastembed), which wraps ColBERT into a simple API.

Install FastEmbed and Qdrant:

```bash
pip install qdrant-client[fastembed]>=1.14.2
```

## Step-by-Step: ColBERT + Qdrant Setup

Ensure that Qdrant is running and create a client:

```python
from qdrant_client import QdrantClient, models

# 1. Connect to Qdrant server
client = QdrantClient("http://localhost:6333")
```

## 1. Encode Documents

Next, encode your documents:

```python
from fastembed import TextEmbedding, LateInteractionTextEmbedding
# Example documents and query
documents = [
    "Artificial intelligence is used in hospitals for cancer diagnosis and treatment.",
    "Self-driving cars use AI to detect obstacles and make driving decisions.",
    "AI is transforming customer service through chatbots and automation.",
    # ...
]
query_text = "How does AI help in medicine?"

dense_documents = [
    models.Document(text=doc, model="BAAI/bge-small-en")
    for doc in documents
]
dense_query = models.Document(text=query_text, model="BAAI/bge-small-en")

colbert_documents = [
    models.Document(text=doc, model="colbert-ir/colbertv2.0")
    for doc in documents
]
colbert_query = models.Document(text=query_text, model="colbert-ir/colbertv2.0")
```

### 2. Create a Qdrant collection

Then create a Qdrant collection with both vector types. Note that we leave indexing on for the `dense` vector but turn it off for the `colbert` vector that will be used for reranking.

```python
collection_name = "dense_multivector_demo"
client.create_collection(
    collection_name=collection_name,
    vectors_config={
        "dense": models.VectorParams(
            size=384,
            distance=models.Distance.COSINE
            # Leave HNSW indexing ON for dense
        ),
        "colbert": models.VectorParams(
            size=128,
            distance=models.Distance.COSINE,
            multivector_config=models.MultiVectorConfig(
                comparator=models.MultiVectorComparator.MAX_SIM
            ),
            hnsw_config=models.HnswConfigDiff(m=0)  # Disable HNSW for reranking
        )
    }
)
```

### 3. Upload Documents (Dense + Multivector)

Now upload the vectors, with `batch_size=8`. We do not have many documents, but batching is always recommended.

```python
points = [
    models.PointStruct(
        id=i,
        vector={
            "dense": dense_documents[i],
            "colbert": colbert_documents[i]
        },
        payload={"text": documents[i]}
    ) for i in range(len(documents))
]
client.upload_points(
    collection_name="dense_multivector_demo", 
    points=points, 
    batch_size=8
)
```

### Query with Retrieval + Reranking in One Call

Now let‚Äôs run a search:

```python
results = client.query_points(
    collection_name="dense_multivector_demo",
    prefetch=models.Prefetch(
        query=dense_query,
        using="dense",
    ),
    query=colbert_query,
    using="colbert",
    limit=3,
    with_payload=True
)
```

- The dense vector retrieves the top candidates quickly.
- The Colbert multivector reranks them using token-level `MaxSim` with fine-grained precision.
- Returns the top 3 results.

## Conclusion

Multivector search is one of the most powerful features of a vector database when used correctly. With this functionality in Qdrant, you can:

- Store token-level embeddings natively.
- Disable indexing to reduce overhead.
- Run fast retrieval and accurate reranking in one API call.
- Efficiently scale late interaction.

Combining FastEmbed and Qdrant leads to a production-ready pipeline for ColBERT-style reranking without wasting resources. You can do this locally or use Qdrant Cloud. Qdrant offers an easy-to-use API to get started with your search engine, so if you‚Äôre ready to dive in, sign up for free at [Qdrant Cloud](https://qdrant.tech/cloud/) and start building.

##### Was this page useful?

Yes No

Thank you for your feedback! üôè

We are sorry to hear that. üòî You can [edit](https:/github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/advanced-tutorials/using-multivector-representations.md) this page on GitHub, or [create](https://github.com/qdrant/landing_page/issues/new/choose) a GitHub issue.

On this page:

- [How to Effectively Use Multivector Representations in Qdrant for Reranking](#how-to-effectively-use-multivector-representations-in-qdrant-for-reranking.md)

  - [What are Multivector Representations?](#what-are-multivector-representations.md)

  - [Why Token-level Vectors are Useful](#why-token-level-vectors-are-useful.md)

  - [What is Rescoring, and Why is it Used?](#what-is-rescoring-and-why-is-it-used.md)

  - [Why Indexing Every Vector by Default is a Problem](#why-indexing-every-vector-by-default-is-a-problem.md)

  - [How to Generate Multivectors Using FastEmbed](#how-to-generate-multivectors-using-fastembed.md)

  - [Step-by-Step: ColBERT + Qdrant Setup](#step-by-step-colbert--qdrant-setup.md)

  - [1. Encode Documents](#1-encode-documents.md)

    - [2. Create a Qdrant collection](#2-create-a-qdrant-collection.md)
    - [3. Upload Documents (Dense + Multivector)](#3-upload-documents-dense--multivector.md)
    - [Query with Retrieval + Reranking in One Call](#query-with-retrieval--reranking-in-one-call.md)

  - [Conclusion](#conclusion.md)

* [Edit on Github](https://github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/advanced-tutorials/using-multivector-representations.md)
* [Create an issue](https://github.com/qdrant/landing_page/issues/new/choose)

#### Ready to get started with Qdrant?

[Start Free](https://qdrant.to/cloud/)

¬© 2025 Qdrant.

[Terms](https://qdrant.tech/legal/terms_and_conditions/) [Privacy Policy](https://qdrant.tech/legal/privacy-policy/) [Impressum](https://qdrant.tech/legal/impressum/)
