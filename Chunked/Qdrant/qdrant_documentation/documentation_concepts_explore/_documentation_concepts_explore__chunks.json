[
  {
    "text": "### User Manual  [Concepts](https://qdrant.tech/documentation/concepts/)  - [Collections](https://qdrant.tech/documentation/concepts/collections/) - [Points](https://qdrant.tech/documentation/concepts/points/) - [Vectors](https://qdrant.tech/documentation/concepts/vectors/) - [Payload](https://qdrant.tech/documentation/concepts/payload/) - [Search](https://qdrant.tech/documentation/concepts/search/) - [Explore](https://qdrant.tech/documentation/concepts/explore/) - [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/) - [Filtering](https://qdrant.tech/documentation/concepts/filtering/) - [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/) - [Storage](https://qdrant.tech/documentation/concepts/storage/) - [Indexing](https://qdrant.tech/documentation/concepts/indexing/) - [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)  [Guides](https://qdrant.tech/documentation/guides/installation/)  - [Installation](https://qdrant.tech/documentation/guides/installation/) - [Administration](https://qdrant.tech/documentation/guides/administration/) - [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/) - [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/) - [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/) - [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/) - [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/) - [Quantization](https://qdrant.tech/documentation/guides/quantization/) - [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/) - [Configuration](https://qdrant.tech/documentation/guides/configuration/) - [Security](https://qdrant.tech/documentation/guides/security/) - [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/) - [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)",
    "metadata": {
      "chunk_id": "9591099c224a-0001",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 1,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "User Manual"
      ],
      "heading_text": "User Manual",
      "token_count": 485,
      "char_count": 1968,
      "start_char": 1033,
      "end_char": 3001,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.301559",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 485,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "User Manual",
      "chunk_hash": "aa99483e94fddd20",
      "content_digest": "aa99483e94fddd20",
      "chunk_length": 1968,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "https",
          "qdrant",
          "tech",
          "documentation",
          "guides",
          "concepts",
          "installation",
          "collections",
          "points",
          "vectors",
          "payload",
          "search",
          "explore",
          "hybrid",
          "queries",
          "filtering",
          "optimizer",
          "storage",
          "indexing",
          "snapshots"
        ],
        "term_weights": [
          {
            "term": "https",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "qdrant",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "tech",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "documentation",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "guides",
            "tf": 15,
            "weight": 0.072816
          },
          {
            "term": "concepts",
            "tf": 14,
            "weight": 0.067961
          },
          {
            "term": "installation",
            "tf": 3,
            "weight": 0.014563
          },
          {
            "term": "collections",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "points",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "vectors",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "payload",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "search",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "explore",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "hybrid",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "queries",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "filtering",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "optimizer",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "storage",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "indexing",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "snapshots",
            "tf": 2,
            "weight": 0.009709
          }
        ],
        "unique_terms": 45,
        "total_terms": 206
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "User Manual",
        "collections",
        "concepts",
        "documentation",
        "guides",
        "https",
        "installation",
        "points",
        "qdrant",
        "tech",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "overall": 0.7776666666666666
    }
  },
  {
    "text": "### Tutorials  [Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)  - [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/) - [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/) - [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/) - [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)  [Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)  - [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/) - [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/) - [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/) - [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/) - [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)  [Using the Database](https://qdrant.tech/documentation/database-tutorials/)  - [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/) - [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/) - [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/) - [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/) - [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/) - [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/) - [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)",
    "metadata": {
      "chunk_id": "9591099c224a-0003",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 3,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Tutorials"
      ],
      "heading_text": "Tutorials",
      "token_count": 459,
      "char_count": 1988,
      "start_char": 3683,
      "end_char": 5671,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.310753",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 459,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Tutorials",
      "chunk_hash": "f480f0283a04b78a",
      "content_digest": "f480f0283a04b78a",
      "chunk_length": 1988,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "tutorials",
          "https",
          "tech",
          "documentation",
          "search",
          "database",
          "advanced",
          "beginner",
          "with",
          "hybrid",
          "retrieval",
          "build",
          "scale",
          "neural",
          "fastembed",
          "quality",
          "multivector",
          "representations",
          "using"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 22,
            "weight": 0.098655
          },
          {
            "term": "tutorials",
            "tf": 20,
            "weight": 0.089686
          },
          {
            "term": "https",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "tech",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "documentation",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "search",
            "tf": 14,
            "weight": 0.06278
          },
          {
            "term": "database",
            "tf": 9,
            "weight": 0.040359
          },
          {
            "term": "advanced",
            "tf": 7,
            "weight": 0.03139
          },
          {
            "term": "beginner",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "with",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "hybrid",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "retrieval",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "build",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "scale",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "neural",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "fastembed",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "quality",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "multivector",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "representations",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "using",
            "tf": 2,
            "weight": 0.008969
          }
        ],
        "unique_terms": 64,
        "total_terms": 223
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Tutorials",
        "advanced",
        "beginner",
        "database",
        "documentation",
        "https",
        "qdrant",
        "search",
        "tech",
        "tutorials",
        "with"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "overall": 0.7826697594501718
    }
  },
  {
    "text": "### Support  [FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)  - [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/) - [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)  [Release Notes](https://github.com/qdrant/qdrant/releases)",
    "metadata": {
      "chunk_id": "9591099c224a-0004",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 4,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Support"
      ],
      "heading_text": "Support",
      "token_count": 83,
      "char_count": 311,
      "start_char": 5673,
      "end_char": 5984,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.5627272727272727,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.312176",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 83,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Support",
      "chunk_hash": "f059a5deb61e367d",
      "content_digest": "f059a5deb61e367d",
      "chunk_length": 311,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "faq",
          "https",
          "tech",
          "documentation",
          "fundamentals",
          "database",
          "optimization",
          "support",
          "release",
          "notes",
          "github",
          "com",
          "releases"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 8,
            "weight": 0.228571
          },
          {
            "term": "faq",
            "tf": 4,
            "weight": 0.114286
          },
          {
            "term": "https",
            "tf": 4,
            "weight": 0.114286
          },
          {
            "term": "tech",
            "tf": 3,
            "weight": 0.085714
          },
          {
            "term": "documentation",
            "tf": 3,
            "weight": 0.085714
          },
          {
            "term": "fundamentals",
            "tf": 3,
            "weight": 0.085714
          },
          {
            "term": "database",
            "tf": 2,
            "weight": 0.057143
          },
          {
            "term": "optimization",
            "tf": 2,
            "weight": 0.057143
          },
          {
            "term": "support",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "release",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "notes",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "github",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "com",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "releases",
            "tf": 1,
            "weight": 0.028571
          }
        ],
        "unique_terms": 14,
        "total_terms": 35
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Support",
        "database",
        "documentation",
        "faq",
        "fundamentals",
        "https",
        "optimization",
        "qdrant",
        "release",
        "support",
        "tech"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.5627272727272727,
      "overall": 0.7209090909090908
    }
  },
  {
    "text": "### User Manual  [Concepts](https://qdrant.tech/documentation/concepts/)  - [Collections](https://qdrant.tech/documentation/concepts/collections/) - [Points](https://qdrant.tech/documentation/concepts/points/) - [Vectors](https://qdrant.tech/documentation/concepts/vectors/) - [Payload](https://qdrant.tech/documentation/concepts/payload/) - [Search](https://qdrant.tech/documentation/concepts/search/) - [Explore](https://qdrant.tech/documentation/concepts/explore/) - [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/) - [Filtering](https://qdrant.tech/documentation/concepts/filtering/) - [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/) - [Storage](https://qdrant.tech/documentation/concepts/storage/) - [Indexing](https://qdrant.tech/documentation/concepts/indexing/) - [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)  [Guides](https://qdrant.tech/documentation/guides/installation/)  - [Installation](https://qdrant.tech/documentation/guides/installation/) - [Administration](https://qdrant.tech/documentation/guides/administration/) - [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/) - [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/) - [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/) - [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/) - [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/) - [Quantization](https://qdrant.tech/documentation/guides/quantization/) - [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/) - [Configuration](https://qdrant.tech/documentation/guides/configuration/) - [Security](https://qdrant.tech/documentation/guides/security/) - [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/) - [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)",
    "metadata": {
      "chunk_id": "9591099c224a-0006",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 6,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "User Manual"
      ],
      "heading_text": "User Manual",
      "token_count": 485,
      "char_count": 1968,
      "start_char": 6361,
      "end_char": 8329,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.320507",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 485,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "User Manual",
      "chunk_hash": "aa99483e94fddd20",
      "content_digest": "aa99483e94fddd20",
      "chunk_length": 1968,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "https",
          "qdrant",
          "tech",
          "documentation",
          "guides",
          "concepts",
          "installation",
          "collections",
          "points",
          "vectors",
          "payload",
          "search",
          "explore",
          "hybrid",
          "queries",
          "filtering",
          "optimizer",
          "storage",
          "indexing",
          "snapshots"
        ],
        "term_weights": [
          {
            "term": "https",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "qdrant",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "tech",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "documentation",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "guides",
            "tf": 15,
            "weight": 0.072816
          },
          {
            "term": "concepts",
            "tf": 14,
            "weight": 0.067961
          },
          {
            "term": "installation",
            "tf": 3,
            "weight": 0.014563
          },
          {
            "term": "collections",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "points",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "vectors",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "payload",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "search",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "explore",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "hybrid",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "queries",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "filtering",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "optimizer",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "storage",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "indexing",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "snapshots",
            "tf": 2,
            "weight": 0.009709
          }
        ],
        "unique_terms": 45,
        "total_terms": 206
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "User Manual",
        "collections",
        "concepts",
        "documentation",
        "guides",
        "https",
        "installation",
        "points",
        "qdrant",
        "tech",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "overall": 0.7776666666666666
    }
  },
  {
    "text": "### Tutorials  [Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)  - [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/) - [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/) - [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/) - [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)  [Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)  - [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/) - [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/) - [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/) - [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/) - [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)  [Using the Database](https://qdrant.tech/documentation/database-tutorials/)  - [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/) - [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/) - [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/) - [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/) - [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/) - [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/) - [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)",
    "metadata": {
      "chunk_id": "9591099c224a-0008",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 8,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Tutorials"
      ],
      "heading_text": "Tutorials",
      "token_count": 459,
      "char_count": 1988,
      "start_char": 9011,
      "end_char": 10999,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.331040",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 459,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Tutorials",
      "chunk_hash": "f480f0283a04b78a",
      "content_digest": "f480f0283a04b78a",
      "chunk_length": 1988,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "tutorials",
          "https",
          "tech",
          "documentation",
          "search",
          "database",
          "advanced",
          "beginner",
          "with",
          "hybrid",
          "retrieval",
          "build",
          "scale",
          "neural",
          "fastembed",
          "quality",
          "multivector",
          "representations",
          "using"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 22,
            "weight": 0.098655
          },
          {
            "term": "tutorials",
            "tf": 20,
            "weight": 0.089686
          },
          {
            "term": "https",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "tech",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "documentation",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "search",
            "tf": 14,
            "weight": 0.06278
          },
          {
            "term": "database",
            "tf": 9,
            "weight": 0.040359
          },
          {
            "term": "advanced",
            "tf": 7,
            "weight": 0.03139
          },
          {
            "term": "beginner",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "with",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "hybrid",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "retrieval",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "build",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "scale",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "neural",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "fastembed",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "quality",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "multivector",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "representations",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "using",
            "tf": 2,
            "weight": 0.008969
          }
        ],
        "unique_terms": 64,
        "total_terms": 223
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Tutorials",
        "advanced",
        "beginner",
        "database",
        "documentation",
        "https",
        "qdrant",
        "search",
        "tech",
        "tutorials",
        "with"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "overall": 0.7826697594501718
    }
  },
  {
    "text": "# Explore the data\n\nAfter mastering the concepts in [search](https://qdrant.tech/documentation/concepts/search/), you can start exploring your data in other ways. Qdrant provides a stack of APIs that allow you to find similar vectors in a different fashion, as well as to find the most dissimilar ones. These are useful tools for recommendation systems, data exploration, and data cleaning.",
    "metadata": {
      "chunk_id": "9591099c224a-0010",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 10,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Explore the data"
      ],
      "heading_text": "Explore the data",
      "token_count": 81,
      "char_count": 390,
      "start_char": 11441,
      "end_char": 11831,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.5268421052631579,
      "chunking_strategy": "hybrid_adaptive_semchunk",
      "content_type": "prose_section",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.335092",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 81,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Explore the data",
      "chunk_hash": "1eb573a5bfe5627a",
      "content_digest": "1eb573a5bfe5627a",
      "chunk_length": 390,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "data",
          "the",
          "concepts",
          "search",
          "qdrant",
          "you",
          "find",
          "explore",
          "after",
          "mastering",
          "https",
          "tech",
          "documentation",
          "can",
          "start",
          "exploring",
          "your",
          "other",
          "ways",
          "provides"
        ],
        "term_weights": [
          {
            "term": "data",
            "tf": 4,
            "weight": 0.076923
          },
          {
            "term": "the",
            "tf": 3,
            "weight": 0.057692
          },
          {
            "term": "concepts",
            "tf": 2,
            "weight": 0.038462
          },
          {
            "term": "search",
            "tf": 2,
            "weight": 0.038462
          },
          {
            "term": "qdrant",
            "tf": 2,
            "weight": 0.038462
          },
          {
            "term": "you",
            "tf": 2,
            "weight": 0.038462
          },
          {
            "term": "find",
            "tf": 2,
            "weight": 0.038462
          },
          {
            "term": "explore",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "after",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "mastering",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "https",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "tech",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "documentation",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "can",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "start",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "exploring",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "your",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "other",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "ways",
            "tf": 1,
            "weight": 0.019231
          },
          {
            "term": "provides",
            "tf": 1,
            "weight": 0.019231
          }
        ],
        "unique_terms": 42,
        "total_terms": 52
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Explore the data",
        "after",
        "concepts",
        "data",
        "explore",
        "find",
        "mastering",
        "qdrant",
        "search",
        "the",
        "you"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.5268421052631579,
      "overall": 0.7089473684210525
    }
  },
  {
    "text": "## Recommendation API  In addition to the regular search, Qdrant also allows you to search based on multiple positive and negative examples. The API is called ***recommend***, and the examples can be point IDs, so that you can leverage the already encoded objects; and, as of v1.6, you can also use raw vectors as input, so that you can create your vectors on the fly without uploading them as points. REST API - API Schema definition is available [here](https://api.qdrant.tech/api-reference/search/recommend-points) ```http POST /collections/{collection_name}/points/query {   \"query\": {     \"recommend\": {       \"positive\": [100, 231],       \"negative\": [718, [0.2, 0.3, 0.4, 0.5]],       \"strategy\": \"average_vector\"     }   },   \"filter\": {     \"must\": [       {         \"key\": \"city\",         \"match\": {           \"value\": \"London\"         }       }     ]   } } ``` ```python from qdrant_client import QdrantClient, models  client = QdrantClient(url=\"http://localhost:6333\")  client.query_points(     collection_name=\"{collection_name}\",     query=models.RecommendQuery(         recommend=models.RecommendInput(             positive=[100, 231],             negative=[718, [0.2, 0.3, 0.4, 0.5]],             strategy=models.RecommendStrategy.AVERAGE_VECTOR,         )     ),     query_filter=models.Filter(         must=[             models.FieldCondition(                 key=\"city\",                 match=models.MatchValue(                     value=\"London\",                 ),             )         ]     ),     limit=3, ) ``` ```typescript import { QdrantClient } from \"@qdrant/js-client-rest\";  const client = new QdrantClient({ host: \"localhost\", port: 6333 });  client.query(\"{collection_name}\", {     query: {         recommend: {             positive: [100, 231],             negative: [718, [0.2, 0.3, 0.4, 0.5]],             strategy: \"average_vector\"         }     },     filter: {         must: [             {                 key: \"city\",                 match: {                     value: \"London\",                 },             },         ],     },     limit: 3 }); ``` ```rust use qdrant_client::qdrant::{     Condition, Filter, QueryPointsBuilder, RecommendInputBuilder, RecommendStrategy, }; use qdrant_client::Qdrant;  let client = Qdrant::from_url(\"http://localhost:6334\").build()?;      client     .query(         QueryPointsBuilder::new(\"{collection_name}\")             .query(                 RecommendInputBuilder::default()                     .add_positive(100)                     .add_positive(231)                     .add_positive(vec![0.2, 0.3, 0.4, 0.5])                     .add_negative(718)                     .strategy(RecommendStrategy::AverageVector)                     .build(),             )             .limit(3)             .filter(Filter::must([Condition::matches(                 \"city\",                 \"London\".to_string(),             )])),     )     .await?; ``` ```java import java.util.List;  import io.qdrant.client.QdrantClient; import io.qdrant.client.QdrantGrpcClient; import io.qdrant.client.grpc.Points.QueryPoints; import io.qdrant.client.grpc.Points.RecommendInput; import io.qdrant.client.grpc.Points.RecommendStrategy; import io.qdrant.client.grpc.Points.Filter;  import static io.qdrant.client.ConditionFactory.matchKeyword; import static io.qdrant.client.VectorInputFactory.vectorInput; import static io.qdrant.client.QueryFactory.recommend;  QdrantClient client =     new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());  client.queryAsync(QueryPoints.newBuilder()         .setCollectionName(\"{collection_name}\")         .setQuery(recommend(RecommendInput.newBuilder()                 .addAllPositive(List.of(vectorInput(100), vectorInput(200), vectorInput(100.0f, 231.0f)))                 .addAllNegative(List.of(vectorInput(718), vectorInput(0.2f, 0.3f, 0.4f, 0.5f)))                 .setStrategy(RecommendStrategy.AverageVector)                 .build()))         .setFilter(Filter.newBuilder().addMust(matchKeyword(\"city\", \"London\")))         .setLimit(3)         .build()).get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc; using static Qdrant.Client.Grpc.Conditions;  var client = new QdrantClient(\"localhost\", 6334);  await client.QueryAsync(     collectionName: \"{collection_name}\",     query: new RecommendInput {         Positive = { 100, 231 },         Negative = { 718 }     },     filter: MatchKeyword(\"city\", \"London\"),     limit: 3 ); ``` ```go import (     \"context\"      \"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{     Host: \"localhost\",     Port: 6334, })  client.Query(context.Background(), &qdrant.QueryPoints{     CollectionName: \"{collection_name}\",     Query: qdrant.NewQueryRecommend(&qdrant.RecommendInput{         Positive: []*qdrant.VectorInput{             qdrant.NewVectorInputID(qdrant.NewIDNum(100)),             qdrant.NewVectorInputID(qdrant.NewIDNum(231)),         },         Negative: []*qdrant.VectorInput{             qdrant.NewVectorInputID(qdrant.NewIDNum(718)),         },     }),     Filter: &qdrant.Filter{         Must: []*qdrant.Condition{             qdrant.NewMatch(\"city\", \"London\"),         },     }, }) ``` Example result of this API would be ```json {   \"result\": [     { \"id\": 10, \"score\": 0.81 },     { \"id\": 14, \"score\": 0.75 },     { \"id\": 11, \"score\": 0.73 }   ],   \"status\": \"ok\",   \"time\": 0.001 } ``` The algorithm used to get the recommendations is selected from the available `strategy` options. Each of them has its own strengths and weaknesses, so experiment and choose the one that works best for your case.",
    "metadata": {
      "chunk_id": "9591099c224a-0011",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 11,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Recommendation API"
      ],
      "heading_text": "Recommendation API",
      "token_count": 1415,
      "char_count": 5634,
      "start_char": 11833,
      "end_char": 17467,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.8817371937639198,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.362089",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 1415,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Recommendation API",
      "chunk_hash": "7666024c615c16b8",
      "content_digest": "7666024c615c16b8",
      "chunk_length": 5634,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "import",
          "query",
          "filter",
          "the",
          "positive",
          "points",
          "collection",
          "name",
          "100",
          "qdrantclient",
          "vectorinput",
          "api",
          "negative",
          "recommend",
          "231",
          "718",
          "city",
          "london"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 39,
            "weight": 0.079592
          },
          {
            "term": "client",
            "tf": 29,
            "weight": 0.059184
          },
          {
            "term": "import",
            "tf": 13,
            "weight": 0.026531
          },
          {
            "term": "query",
            "tf": 12,
            "weight": 0.02449
          },
          {
            "term": "filter",
            "tf": 12,
            "weight": 0.02449
          },
          {
            "term": "the",
            "tf": 9,
            "weight": 0.018367
          },
          {
            "term": "positive",
            "tf": 9,
            "weight": 0.018367
          },
          {
            "term": "points",
            "tf": 8,
            "weight": 0.016327
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.016327
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.016327
          },
          {
            "term": "100",
            "tf": 8,
            "weight": 0.016327
          },
          {
            "term": "qdrantclient",
            "tf": 8,
            "weight": 0.016327
          },
          {
            "term": "vectorinput",
            "tf": 8,
            "weight": 0.016327
          },
          {
            "term": "api",
            "tf": 7,
            "weight": 0.014286
          },
          {
            "term": "negative",
            "tf": 7,
            "weight": 0.014286
          },
          {
            "term": "recommend",
            "tf": 7,
            "weight": 0.014286
          },
          {
            "term": "231",
            "tf": 7,
            "weight": 0.014286
          },
          {
            "term": "718",
            "tf": 7,
            "weight": 0.014286
          },
          {
            "term": "city",
            "tf": 7,
            "weight": 0.014286
          },
          {
            "term": "london",
            "tf": 7,
            "weight": 0.014286
          }
        ],
        "unique_terms": 166,
        "total_terms": 490
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Recommendation API",
        "client",
        "collection",
        "filter",
        "import",
        "name",
        "points",
        "positive",
        "qdrant",
        "query",
        "the"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.8817371937639198,
      "overall": 0.7939123979213066
    }
  },
  {
    "text": "### Average vector strategy  The default and first strategy added to Qdrant is called `average_vector`. It preprocesses the input examples to create a single vector that is used for the search. Since the preprocessing step happens very fast, the performance of this strategy is on-par with regular search. The intuition behind this kind of recommendation is that each vector component represents an independent feature of the data, so, by averaging the examples, we should get a good recommendation. The way to produce the searching vector is by first averaging all the positive and negative examples separately, and then combining them into a single vector using the following formula: ```rust avg_positive + avg_positive - avg_negative ``` In the case of not having any negative examples, the search vector will simply be equal to `avg_positive`. This is the default strategy thats going to be set implicitly, but you can explicitly define it by setting `\"strategy\": \"average_vector\"` in the recommendation request.",
    "metadata": {
      "chunk_id": "9591099c224a-0012",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 12,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Average vector strategy"
      ],
      "heading_text": "Average vector strategy",
      "token_count": 191,
      "char_count": 1018,
      "start_char": 17480,
      "end_char": 18498,
      "semantic_score": 0.7999999999999999,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6817721518987342,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.370020",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 191,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Average vector strategy",
      "chunk_hash": "c37c8a5a7078c70d",
      "content_digest": "c37c8a5a7078c70d",
      "chunk_length": 1018,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "the",
          "vector",
          "strategy",
          "examples",
          "positive",
          "avg",
          "average",
          "and",
          "that",
          "search",
          "this",
          "recommendation",
          "negative",
          "default",
          "first",
          "single",
          "averaging",
          "added",
          "qdrant",
          "called"
        ],
        "term_weights": [
          {
            "term": "the",
            "tf": 16,
            "weight": 0.123077
          },
          {
            "term": "vector",
            "tf": 8,
            "weight": 0.061538
          },
          {
            "term": "strategy",
            "tf": 5,
            "weight": 0.038462
          },
          {
            "term": "examples",
            "tf": 4,
            "weight": 0.030769
          },
          {
            "term": "positive",
            "tf": 4,
            "weight": 0.030769
          },
          {
            "term": "avg",
            "tf": 4,
            "weight": 0.030769
          },
          {
            "term": "average",
            "tf": 3,
            "weight": 0.023077
          },
          {
            "term": "and",
            "tf": 3,
            "weight": 0.023077
          },
          {
            "term": "that",
            "tf": 3,
            "weight": 0.023077
          },
          {
            "term": "search",
            "tf": 3,
            "weight": 0.023077
          },
          {
            "term": "this",
            "tf": 3,
            "weight": 0.023077
          },
          {
            "term": "recommendation",
            "tf": 3,
            "weight": 0.023077
          },
          {
            "term": "negative",
            "tf": 3,
            "weight": 0.023077
          },
          {
            "term": "default",
            "tf": 2,
            "weight": 0.015385
          },
          {
            "term": "first",
            "tf": 2,
            "weight": 0.015385
          },
          {
            "term": "single",
            "tf": 2,
            "weight": 0.015385
          },
          {
            "term": "averaging",
            "tf": 2,
            "weight": 0.015385
          },
          {
            "term": "added",
            "tf": 1,
            "weight": 0.007692
          },
          {
            "term": "qdrant",
            "tf": 1,
            "weight": 0.007692
          },
          {
            "term": "called",
            "tf": 1,
            "weight": 0.007692
          }
        ],
        "unique_terms": 77,
        "total_terms": 130
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Average vector strategy",
        "and",
        "average",
        "avg",
        "examples",
        "positive",
        "search",
        "strategy",
        "that",
        "the",
        "vector"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7999999999999999,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6817721518987342,
      "overall": 0.7939240506329113
    }
  },
  {
    "text": "### Best score strategy  *Available as of v1.6.0*  A new strategy introduced in v1.6, is called `best_score`. It is based on the idea that the best way to find similar vectors is to find the ones that are closer to a positive example, while avoiding the ones that are closer to a negative one. The way it works is that each candidate is measured against every example, then we select the best positive and best negative scores. The final score is chosen with this step formula: ```rust // Sigmoid function to normalize the score between 0 and 1 let sigmoid = |x| 0.5 * (1.0 + (x / (1.0 + x.abs())));  let score = if best_positive_score > best_negative_score {     sigmoid(best_positive_score) } else {     -sigmoid(best_negative_score) }; ``` The performance of `best_score` strategy will be linearly impacted by the amount of examples. Since we are computing similarities to every example at each step of the search, the performance of this strategy will be linearly impacted by the amount of examples. This means that the more examples you provide, the slower the search will be. However, this strategy can be very powerful and should be more embedding-agnostic. Accuracy may be impacted with this strategy. To improve it, increasing the `ef` search parameter to something above 32 will already be much better than the default 16, e.g: `\"params\": { \"ef\": 64 }`  To use this algorithm, you need to set `\"strategy\": \"best_score\"` in the recommendation request.",
    "metadata": {
      "chunk_id": "9591099c224a-0013",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 13,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Best score strategy"
      ],
      "heading_text": "Best score strategy",
      "token_count": 335,
      "char_count": 1460,
      "start_char": 18504,
      "end_char": 19964,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6752933884297521,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.376843",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 335,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Best score strategy",
      "chunk_hash": "c3c5a58652addb7f",
      "content_digest": "c3c5a58652addb7f",
      "chunk_length": 1460,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "the",
          "best",
          "score",
          "strategy",
          "this",
          "that",
          "positive",
          "negative",
          "sigmoid",
          "will",
          "are",
          "example",
          "and",
          "impacted",
          "examples",
          "search",
          "way",
          "find",
          "ones",
          "closer"
        ],
        "term_weights": [
          {
            "term": "the",
            "tf": 19,
            "weight": 0.105556
          },
          {
            "term": "best",
            "tf": 11,
            "weight": 0.061111
          },
          {
            "term": "score",
            "tf": 11,
            "weight": 0.061111
          },
          {
            "term": "strategy",
            "tf": 7,
            "weight": 0.038889
          },
          {
            "term": "this",
            "tf": 6,
            "weight": 0.033333
          },
          {
            "term": "that",
            "tf": 5,
            "weight": 0.027778
          },
          {
            "term": "positive",
            "tf": 4,
            "weight": 0.022222
          },
          {
            "term": "negative",
            "tf": 4,
            "weight": 0.022222
          },
          {
            "term": "sigmoid",
            "tf": 4,
            "weight": 0.022222
          },
          {
            "term": "will",
            "tf": 4,
            "weight": 0.022222
          },
          {
            "term": "are",
            "tf": 3,
            "weight": 0.016667
          },
          {
            "term": "example",
            "tf": 3,
            "weight": 0.016667
          },
          {
            "term": "and",
            "tf": 3,
            "weight": 0.016667
          },
          {
            "term": "impacted",
            "tf": 3,
            "weight": 0.016667
          },
          {
            "term": "examples",
            "tf": 3,
            "weight": 0.016667
          },
          {
            "term": "search",
            "tf": 3,
            "weight": 0.016667
          },
          {
            "term": "way",
            "tf": 2,
            "weight": 0.011111
          },
          {
            "term": "find",
            "tf": 2,
            "weight": 0.011111
          },
          {
            "term": "ones",
            "tf": 2,
            "weight": 0.011111
          },
          {
            "term": "closer",
            "tf": 2,
            "weight": 0.011111
          }
        ],
        "unique_terms": 89,
        "total_terms": 180
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Best score strategy",
        "best",
        "negative",
        "positive",
        "score",
        "sigmoid",
        "strategy",
        "that",
        "the",
        "this",
        "will"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6752933884297521,
      "overall": 0.758431129476584
    }
  },
  {
    "text": "### Sum scores strategy\n\nAnother strategy for using multiple query vectors simultaneously is to just sum their scores against the candidates. In qdrant, this is called `sum_scores` strategy.\n\nThis strategy was used in [this paper](https://arxiv.org/abs/2210.10695) by [UKP Lab](http://www.ukp.tu-darmstadt.de/), [hessian.ai](https://hessian.ai) and [cohere.ai](https://cohere.ai) to incorporate relevance feedback into a subsequent search. In the paper this boosted the nDCG\\@20 performance by 5.6% points when using 2-8 positive feedback documents.\n\nThe formula that this strategy implements is\n\n$$ s\\_i = \\sum\\_{v\\_q\\in Q^+}s(v\\_q, v\\_i) - \\sum\\_{v\\_q\\in Q^-}s(v\\_q, v\\_i) $$\n\nwhere $Q^+$ is the set of positive examples, $Q^-$ is the set of negative examples, and $s(v\\_q, v\\_i)$ is the score of the vector $v\\_q$ against the vector $v\\_i$\n\nAs with `best_score`, this strategy also allows using only negative examples.",
    "metadata": {
      "chunk_id": "9591099c224a-0015",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 15,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Sum scores strategy"
      ],
      "heading_text": "Sum scores strategy",
      "token_count": 268,
      "char_count": 921,
      "start_char": 20409,
      "end_char": 21330,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6883870967741935,
      "chunking_strategy": "hybrid_adaptive_semchunk",
      "content_type": "prose_section",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.379495",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 268,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Sum scores strategy",
      "chunk_hash": "d997bde6cb2346d6",
      "content_digest": "d997bde6cb2346d6",
      "chunk_length": 921,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "the",
          "strategy",
          "this",
          "sum",
          "scores",
          "using",
          "https",
          "examples",
          "against",
          "paper",
          "ukp",
          "hessian",
          "and",
          "cohere",
          "feedback",
          "positive",
          "set",
          "negative",
          "score",
          "vector"
        ],
        "term_weights": [
          {
            "term": "the",
            "tf": 9,
            "weight": 0.086538
          },
          {
            "term": "strategy",
            "tf": 6,
            "weight": 0.057692
          },
          {
            "term": "this",
            "tf": 6,
            "weight": 0.057692
          },
          {
            "term": "sum",
            "tf": 5,
            "weight": 0.048077
          },
          {
            "term": "scores",
            "tf": 3,
            "weight": 0.028846
          },
          {
            "term": "using",
            "tf": 3,
            "weight": 0.028846
          },
          {
            "term": "https",
            "tf": 3,
            "weight": 0.028846
          },
          {
            "term": "examples",
            "tf": 3,
            "weight": 0.028846
          },
          {
            "term": "against",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "paper",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "ukp",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "hessian",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "and",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "cohere",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "feedback",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "positive",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "set",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "negative",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "score",
            "tf": 2,
            "weight": 0.019231
          },
          {
            "term": "vector",
            "tf": 2,
            "weight": 0.019231
          }
        ],
        "unique_terms": 62,
        "total_terms": 104
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": true
      },
      "search_keywords": [
        "Sum scores strategy",
        "against",
        "examples",
        "https",
        "paper",
        "scores",
        "strategy",
        "sum",
        "the",
        "this",
        "using"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6883870967741935,
      "overall": 0.7627956989247311
    }
  },
  {
    "text": "### Multiple vectors  *Available as of v0.10.0*  If the collection was created with multiple vectors, the name of the vector should be specified in the recommendation request: ```http POST /collections/{collection_name}/points/query {   \"query\": {     \"recommend\": {       \"positive\": [100, 231],       \"negative\": [718]     }   },   \"using\": \"image\",   \"limit\": 10 } ``` ```python client.query_points(     collection_name=\"{collection_name}\",     query=models.RecommendQuery(         recommend=models.RecommendInput(             positive=[100, 231],             negative=[718],         )     ),     using=\"image\",     limit=10, ) ``` ```typescript client.query(\"{collection_name}\", {     query: {         recommend: {             positive: [100, 231],             negative: [718],         }     },     using: \"image\",     limit: 10 }); ``` ```rust use qdrant_client::qdrant::{QueryPointsBuilder, RecommendInputBuilder};  client     .query(         QueryPointsBuilder::new(\"{collection_name}\")             .query(                 RecommendInputBuilder::default()                     .add_positive(100)                     .add_positive(231)                     .add_negative(718)                     .build(),             )             .limit(10)             .using(\"image\"),     )     .await?; ``` ```java import java.util.List;  import io.qdrant.client.grpc.Points.QueryPoints; import io.qdrant.client.grpc.Points.RecommendInput;  import static io.qdrant.client.VectorInputFactory.vectorInput; import static io.qdrant.client.QueryFactory.recommend;  client.queryAsync(QueryPoints.newBuilder()         .setCollectionName(\"{collection_name}\")         .setQuery(recommend(RecommendInput.newBuilder()                 .addAllPositive(List.of(vectorInput(100), vectorInput(231)))                 .addAllNegative(List.of(vectorInput(718)))                 .build()))         .setUsing(\"image\")         .setLimit(10)         .build()).get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc;  var client = new QdrantClient(\"localhost\", 6334);  await client.QueryAsync(     collectionName: \"{collection_name}\",     query: new RecommendInput {         Positive = { 100, 231 },         Negative = { 718 }     },     usingVector: \"image\",     limit: 10 ); ``` ```go import (     \"context\"      \"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{     Host: \"localhost\",     Port: 6334, })  client.Query(context.Background(), &qdrant.QueryPoints{     CollectionName: \"{collection_name}\",     Query: qdrant.NewQueryRecommend(&qdrant.RecommendInput{         Positive: []*qdrant.VectorInput{             qdrant.NewVectorInputID(qdrant.NewIDNum(100)),             qdrant.NewVectorInputID(qdrant.NewIDNum(231)),         },         Negative: []*qdrant.VectorInput{             qdrant.NewVectorInputID(qdrant.NewIDNum(718)),         },     }),     Using: qdrant.PtrOf(\"image\"), }) ``` Parameter `using` specifies which stored vectors to use for the recommendation.",
    "metadata": {
      "chunk_id": "9591099c224a-0016",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 16,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Multiple vectors"
      ],
      "heading_text": "Multiple vectors",
      "token_count": 712,
      "char_count": 2992,
      "start_char": 21332,
      "end_char": 24324,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.7091346153846154,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.391264",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 712,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Multiple vectors",
      "chunk_hash": "0186f45e9952af4c",
      "content_digest": "0186f45e9952af4c",
      "chunk_length": 2992,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "query",
          "collection",
          "name",
          "using",
          "positive",
          "100",
          "231",
          "718",
          "image",
          "negative",
          "import",
          "vectorinput",
          "the",
          "recommend",
          "limit",
          "recommendinput",
          "points",
          "vectors"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 24,
            "weight": 0.09375
          },
          {
            "term": "client",
            "tf": 16,
            "weight": 0.0625
          },
          {
            "term": "query",
            "tf": 11,
            "weight": 0.042969
          },
          {
            "term": "collection",
            "tf": 9,
            "weight": 0.035156
          },
          {
            "term": "name",
            "tf": 9,
            "weight": 0.035156
          },
          {
            "term": "using",
            "tf": 8,
            "weight": 0.03125
          },
          {
            "term": "positive",
            "tf": 7,
            "weight": 0.027344
          },
          {
            "term": "100",
            "tf": 7,
            "weight": 0.027344
          },
          {
            "term": "231",
            "tf": 7,
            "weight": 0.027344
          },
          {
            "term": "718",
            "tf": 7,
            "weight": 0.027344
          },
          {
            "term": "image",
            "tf": 7,
            "weight": 0.027344
          },
          {
            "term": "negative",
            "tf": 6,
            "weight": 0.023438
          },
          {
            "term": "import",
            "tf": 6,
            "weight": 0.023438
          },
          {
            "term": "vectorinput",
            "tf": 6,
            "weight": 0.023438
          },
          {
            "term": "the",
            "tf": 5,
            "weight": 0.019531
          },
          {
            "term": "recommend",
            "tf": 5,
            "weight": 0.019531
          },
          {
            "term": "limit",
            "tf": 5,
            "weight": 0.019531
          },
          {
            "term": "recommendinput",
            "tf": 5,
            "weight": 0.019531
          },
          {
            "term": "points",
            "tf": 4,
            "weight": 0.015625
          },
          {
            "term": "vectors",
            "tf": 3,
            "weight": 0.011719
          }
        ],
        "unique_terms": 88,
        "total_terms": 256
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "100",
        "231",
        "718",
        "Multiple vectors",
        "client",
        "collection",
        "name",
        "positive",
        "qdrant",
        "query",
        "using"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.7091346153846154,
      "overall": 0.7363782051282052
    }
  },
  {
    "text": "### Lookup vectors from another collection  *Available as of v0.11.6*  If you have collections with vectors of the same dimensionality, and you want to look for recommendations in one collection based on the vectors of another collection, you can use the `lookup_from` parameter. It might be useful, e.g. in the item-to-user recommendations scenario. Where user and item embeddings, although having the same vector parameters (distance type and dimensionality), are usually stored in different collections. ```http POST /collections/{collection_name}/points/query {   \"query\": {     \"recommend\": {       \"positive\": [100, 231],       \"negative\": [718]     }   },   \"limit\": 10,   \"lookup_from\": {     \"collection\": \"{external_collection_name}\",     \"vector\": \"{external_vector_name}\"   } } ``` ```python client.query_points(     collection_name=\"{collection_name}\",     query=models.RecommendQuery(         recommend=models.RecommendInput(             positive=[100, 231],             negative=[718],         )     ),     using=\"image\",     limit=10,     lookup_from=models.LookupLocation(         collection=\"{external_collection_name}\", vector=\"{external_vector_name}\"     ), ) ``` ```typescript client.query(\"{collection_name}\", {     query: {         recommend: {             positive: [100, 231],             negative: [718],         }     },     using: \"image\",     limit: 10,     lookup_from: {         collection: \"{external_collection_name}\",         vector: \"{external_vector_name}\"     } }); ``` ```rust use qdrant_client::qdrant::{LookupLocationBuilder, QueryPointsBuilder, RecommendInputBuilder};  client     .query(         QueryPointsBuilder::new(\"{collection_name}\")             .query(                 RecommendInputBuilder::default()                     .add_positive(100)                     .add_positive(231)                     .add_negative(718)                     .build(),             )             .limit(10)             .using(\"image\")             .lookup_from(                 LookupLocationBuilder::new(\"{external_collection_name}\")                     .vector_name(\"{external_vector_name}\"),             ),     )     .await?; ``` ```java import java.util.List;  import io.qdrant.client.grpc.Points.LookupLocation; import io.qdrant.client.grpc.Points.QueryPoints; import io.qdrant.client.grpc.Points.RecommendInput;  import static io.qdrant.client.VectorInputFactory.vectorInput; import static io.qdrant.client.QueryFactory.recommend;  client.queryAsync(QueryPoints.newBuilder()         .setCollectionName(\"{collection_name}\")         .setQuery(recommend(RecommendInput.newBuilder()                 .addAllPositive(List.of(vectorInput(100), vectorInput(231)))                 .addAllNegative(List.of(vectorInput(718)))                 .build()))         .setUsing(\"image\")         .setLimit(10)         .setLookupFrom(                 LookupLocation.newBuilder()                         .setCollectionName(\"{external_collection_name}\")                         .setVectorName(\"{external_vector_name}\")                         .build())         .build()).get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc;  var client = new QdrantClient(\"localhost\", 6334);  await client.QueryAsync(     collectionName: \"{collection_name}\",     query: new RecommendInput {         Positive = { 100, 231 },         Negative = { 718 }     },     usingVector: \"image\",     limit: 10,     lookupFrom: new LookupLocation     {         CollectionName = \"{external_collection_name}\",         VectorName = \"{external_vector_name}\",     } ); ``` ```go import (     \"context\"      \"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{     Host: \"localhost\",     Port: 6334, })  client.Query(context.Background(), &qdrant.QueryPoints{     CollectionName: \"{collection_name}\",     Query: qdrant.NewQueryRecommend(&qdrant.RecommendInput{         Positive: []*qdrant.VectorInput{             qdrant.NewVectorInputID(qdrant.NewIDNum(100)),             qdrant.NewVectorInputID(qdrant.NewIDNum(231)),         },         Negative: []*qdrant.VectorInput{             qdrant.NewVectorInputID(qdrant.NewIDNum(718)),         },     }),     Using: qdrant.PtrOf(\"image\"),     LookupFrom: &qdrant.LookupLocation{         CollectionName: \"{external_collection_name}\",         VectorName:     qdrant.PtrOf(\"{external_vector_name}\"),     }, }) ``` Vectors are retrieved from the external collection by ids provided in the `positive` and `negative` lists. These vectors then used to perform the recommendation in the current collection, comparing against the using or default vector.",
    "metadata": {
      "chunk_id": "9591099c224a-0017",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 17,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Lookup vectors from another collection"
      ],
      "heading_text": "Lookup vectors from another collection",
      "token_count": 1018,
      "char_count": 4618,
      "start_char": 24334,
      "end_char": 28952,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.7012307692307693,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.423649",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 1018,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Lookup vectors from another collection",
      "chunk_hash": "9ef94ffdeacaff77",
      "content_digest": "9ef94ffdeacaff77",
      "chunk_length": 4618,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "collection",
          "name",
          "client",
          "external",
          "vector",
          "query",
          "the",
          "positive",
          "from",
          "100",
          "231",
          "negative",
          "718",
          "using",
          "import",
          "lookup",
          "image",
          "vectorinput",
          "vectors"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 27,
            "weight": 0.066998
          },
          {
            "term": "collection",
            "tf": 23,
            "weight": 0.057072
          },
          {
            "term": "name",
            "tf": 23,
            "weight": 0.057072
          },
          {
            "term": "client",
            "tf": 17,
            "weight": 0.042184
          },
          {
            "term": "external",
            "tf": 15,
            "weight": 0.037221
          },
          {
            "term": "vector",
            "tf": 13,
            "weight": 0.032258
          },
          {
            "term": "query",
            "tf": 11,
            "weight": 0.027295
          },
          {
            "term": "the",
            "tf": 10,
            "weight": 0.024814
          },
          {
            "term": "positive",
            "tf": 8,
            "weight": 0.019851
          },
          {
            "term": "from",
            "tf": 7,
            "weight": 0.01737
          },
          {
            "term": "100",
            "tf": 7,
            "weight": 0.01737
          },
          {
            "term": "231",
            "tf": 7,
            "weight": 0.01737
          },
          {
            "term": "negative",
            "tf": 7,
            "weight": 0.01737
          },
          {
            "term": "718",
            "tf": 7,
            "weight": 0.01737
          },
          {
            "term": "using",
            "tf": 7,
            "weight": 0.01737
          },
          {
            "term": "import",
            "tf": 7,
            "weight": 0.01737
          },
          {
            "term": "lookup",
            "tf": 6,
            "weight": 0.014888
          },
          {
            "term": "image",
            "tf": 6,
            "weight": 0.014888
          },
          {
            "term": "vectorinput",
            "tf": 6,
            "weight": 0.014888
          },
          {
            "term": "vectors",
            "tf": 5,
            "weight": 0.012407
          }
        ],
        "unique_terms": 127,
        "total_terms": 403
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Lookup vectors from another collection",
        "client",
        "collection",
        "external",
        "from",
        "name",
        "positive",
        "qdrant",
        "query",
        "the",
        "vector"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.7012307692307693,
      "overall": 0.7337435897435899
    }
  },
  {
    "text": "## Discovery API  *Available as of v1.7*  REST API Schema definition available [here](https://api.qdrant.tech/api-reference/search/discover-points)  In this API, Qdrant introduces the concept of `context`, which is used for splitting the space. Context is a set of positive-negative pairs, and each pair divides the space into positive and negative zones. In that mode, the search operation prefers points based on how many positive zones they belong to (or how much they avoid negative zones). The interface for providing context is similar to the recommendation API (ids or raw vectors). Still, in this case, they need to be provided in the form of positive-negative pairs. Discovery API lets you do two new types of search:  - **Discovery search**: Uses the context (the pairs of positive-negative vectors) and a target to return the points more similar to the target, but constrained by the context. - **Context search**: Using only the context pairs, get the points that live in the best zone, where loss is minimized  The way positive and negative examples should be arranged in the context pairs is completely up to you. So you can have the flexibility of trying out different permutation techniques based on your model and data. The speed of search is linearly related to the amount of examples you provide in the query.",
    "metadata": {
      "chunk_id": "9591099c224a-0019",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 19,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Discovery API"
      ],
      "heading_text": "Discovery API",
      "token_count": 273,
      "char_count": 1328,
      "start_char": 37017,
      "end_char": 38345,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6730985915492959,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "list_section",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.444669",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 273,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Discovery API",
      "chunk_hash": "aa29d687536f5f84",
      "content_digest": "aa29d687536f5f84",
      "chunk_length": 1328,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "the",
          "context",
          "api",
          "search",
          "positive",
          "negative",
          "pairs",
          "and",
          "points",
          "you",
          "discovery",
          "zones",
          "they",
          "available",
          "qdrant",
          "this",
          "for",
          "space",
          "that",
          "based"
        ],
        "term_weights": [
          {
            "term": "the",
            "tf": 21,
            "weight": 0.117318
          },
          {
            "term": "context",
            "tf": 8,
            "weight": 0.044693
          },
          {
            "term": "api",
            "tf": 7,
            "weight": 0.039106
          },
          {
            "term": "search",
            "tf": 6,
            "weight": 0.03352
          },
          {
            "term": "positive",
            "tf": 6,
            "weight": 0.03352
          },
          {
            "term": "negative",
            "tf": 6,
            "weight": 0.03352
          },
          {
            "term": "pairs",
            "tf": 5,
            "weight": 0.027933
          },
          {
            "term": "and",
            "tf": 5,
            "weight": 0.027933
          },
          {
            "term": "points",
            "tf": 4,
            "weight": 0.022346
          },
          {
            "term": "you",
            "tf": 4,
            "weight": 0.022346
          },
          {
            "term": "discovery",
            "tf": 3,
            "weight": 0.01676
          },
          {
            "term": "zones",
            "tf": 3,
            "weight": 0.01676
          },
          {
            "term": "they",
            "tf": 3,
            "weight": 0.01676
          },
          {
            "term": "available",
            "tf": 2,
            "weight": 0.011173
          },
          {
            "term": "qdrant",
            "tf": 2,
            "weight": 0.011173
          },
          {
            "term": "this",
            "tf": 2,
            "weight": 0.011173
          },
          {
            "term": "for",
            "tf": 2,
            "weight": 0.011173
          },
          {
            "term": "space",
            "tf": 2,
            "weight": 0.011173
          },
          {
            "term": "that",
            "tf": 2,
            "weight": 0.011173
          },
          {
            "term": "based",
            "tf": 2,
            "weight": 0.011173
          }
        ],
        "unique_terms": 99,
        "total_terms": 179
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Discovery API",
        "and",
        "api",
        "context",
        "negative",
        "pairs",
        "points",
        "positive",
        "search",
        "the",
        "you"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6730985915492959,
      "overall": 0.7576995305164319
    }
  },
  {
    "text": "### Discovery search  This type of search works specially well for combining multimodal, vector-constrained searches. Qdrant already has extensive support for filters, which constrain the search based on its payload, but using discovery search, you can also constrain the vector space in which the search is performed. The formula for the discovery score can be expressed as:  $$ \\text{rank}(v^+, v^-) = \\begin{cases} 1, &\\quad s(v^+) \\geq s(v^-) \\\\\\ -1, &\\quad s(v^+) < s(v^-) \\end{cases} $$ where $v^+$ represents a positive example, $v^-$ represents a negative example, and $s(v)$ is the similarity score of a vector $v$ to the target vector. The discovery score is then computed as: $$ \\text{discovery score} = \\text{sigmoid}(s(v\\_t))+ \\sum \\text{rank}(v\\_i^+, v\\_i^-), $$ where $s(v)$ is the similarity function, $v\\_t$ is the target vector, and again $v\\_i^+$ and $v\\_i^-$ are the positive and negative examples, respectively. The sigmoid function is used to normalize the score between 0 and 1 and the sum of ranks is used to penalize vectors that are closer to the negative examples than to the positive ones. In other words, the sum of individual ranks determines how many positive zones a point is in, while the closeness hierarchy comes second. Example: ```http POST /collections/{collection_name}/points/query {   \"query\": {     \"discover\": {       \"target\": [0.2, 0.1, 0.9, 0.7],       \"context\": [         {           \"positive\": 100,           \"negative\": 718         },         {           \"positive\": 200,           \"negative\": 300         }       ]     }   },   \"limit\": 10 } ``` ```python from qdrant_client import QdrantClient, models  client = QdrantClient(url=\"http://localhost:6333\")  discover_queries = [     models.QueryRequest(         query=models.DiscoverQuery(             discover=models.DiscoverInput(                 target=[0.2, 0.1, 0.9, 0.7],                 context=[                     models.ContextPair(                         positive=100,                         negative=718,                     ),                     models.ContextPair(                         positive=200,                         negative=300,                     ),                 ],             )         ),         limit=10,     ), ]  client.query_batch_points(     collection_name=\"{collection_name}\", requests=discover_queries ) ``` ```typescript import { QdrantClient } from \"@qdrant/js-client-rest\";  const client = new QdrantClient({ host: \"localhost\", port: 6333 });  client.query(\"{collection_name}\", {     query: {         discover: {             target: [0.2, 0.1, 0.9, 0.7],             context: [                 {                     positive: 100,                     negative: 718,                 },                 {                     positive: 200,                     negative: 300,                 },             ],         }     },     limit: 10, }); ``` ```rust use qdrant_client::qdrant::{ContextInputBuilder, DiscoverInputBuilder, QueryPointsBuilder}; use qdrant_client::Qdrant;  client     .query(         QueryPointsBuilder::new(\"{collection_name}\").query(             DiscoverInputBuilder::new(                 vec![0.2, 0.1, 0.9, 0.7],                 ContextInputBuilder::default()                     .add_pair(100, 718)                     .add_pair(200, 300),             )             .build(),         ),     )     .await?; ``` ```java import java.util.List;  import io.qdrant.client.QdrantClient; import io.qdrant.client.QdrantGrpcClient; import io.qdrant.client.grpc.Points.ContextInput; import io.qdrant.client.grpc.Points.ContextInputPair; import io.qdrant.client.grpc.Points.DiscoverInput; import io.qdrant.client.grpc.Points.QueryPoints;  import static io.qdrant.client.VectorInputFactory.vectorInput; import static io.qdrant.client.QueryFactory.discover;  QdrantClient client =     new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());  client.queryAsync(QueryPoints.newBuilder()         .setCollectionName(\"{collection_name}\")         .setQuery(discover(DiscoverInput.newBuilder()                 .setTarget(vectorInput(0.2f, 0.1f, 0.9f, 0.7f))                 .setContext(ContextInput.newBuilder()                         .addAllPairs(List.of(                                 ContextInputPair.newBuilder()                                         .setPositive(vectorInput(100))                                         .setNegative(vectorInput(718))                                         .build(),                                 ContextInputPair.newBuilder()                                         .setPositive(vectorInput(200))                                         .setNegative(vectorInput(300))                                         .build()))                         .build())                 .build()))         .setLimit(10)         .build()).get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc;  var client = new QdrantClient(\"localhost\", 6334);  await client.QueryAsync(     collectionName: \"{collection_name}\",     query: new DiscoverInput {         Target = new float[] { 0.2f, 0.1f, 0.9f, 0.7f },         Context = new ContextInput {             Pairs = {                 new ContextInputPair {                     Positive = 100,                     Negative = 718                 },                 new ContextInputPair {                     Positive = 200,                     Negative = 300                 },             }            },     },     limit: 10 ); ``` ```go import (     \"context\"      \"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{     Host: \"localhost\",     Port: 6334, })  client.Query(context.Background(), &qdrant.QueryPoints{     CollectionName: \"{collection_name}\",     Query: qdrant.NewQueryDiscover(&qdrant.DiscoverInput{         Target: qdrant.NewVectorInput(0.2, 0.1, 0.9, 0.7),         Context: &qdrant.ContextInput{             Pairs: []*qdrant.ContextInputPair{                 {                     Positive: qdrant.NewVectorInputID(qdrant.NewIDNum(100)),                     Negative: qdrant.NewVectorInputID(qdrant.NewIDNum(718)),                 },                 {                     Positive: qdrant.NewVectorInputID(qdrant.NewIDNum(200)),                     Negative: qdrant.NewVectorInputID(qdrant.NewIDNum(300)),                 },             },         },     }), }) ``` Notes about discovery search:  - When providing ids as examples, they will be excluded from the results. - Score is always in descending order (larger is better), regardless of the metric used. - Since the space is hard-constrained by the context, accuracy is normal to drop when using default settings. To mitigate this, increasing the `ef` search parameter to something above 64 will already be much better than the default 16, e.g: `\"params\": { \"ef\": 128 }`",
    "metadata": {
      "chunk_id": "9591099c224a-0020",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 20,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Discovery search"
      ],
      "heading_text": "Discovery search",
      "token_count": 1592,
      "char_count": 6839,
      "start_char": 38350,
      "end_char": 45189,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6908931506849316,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.462195",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 1592,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Discovery search",
      "chunk_hash": "023de4ad8e0e67ca",
      "content_digest": "023de4ad8e0e67ca",
      "chunk_length": 6839,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "the",
          "positive",
          "negative",
          "import",
          "query",
          "new",
          "collection",
          "name",
          "context",
          "qdrantclient",
          "search",
          "target",
          "discover",
          "100",
          "718",
          "200",
          "300",
          "build"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 35,
            "weight": 0.063985
          },
          {
            "term": "client",
            "tf": 26,
            "weight": 0.047532
          },
          {
            "term": "the",
            "tf": 24,
            "weight": 0.043876
          },
          {
            "term": "positive",
            "tf": 14,
            "weight": 0.025594
          },
          {
            "term": "negative",
            "tf": 13,
            "weight": 0.023766
          },
          {
            "term": "import",
            "tf": 12,
            "weight": 0.021938
          },
          {
            "term": "query",
            "tf": 11,
            "weight": 0.02011
          },
          {
            "term": "new",
            "tf": 10,
            "weight": 0.018282
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.014625
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.014625
          },
          {
            "term": "context",
            "tf": 8,
            "weight": 0.014625
          },
          {
            "term": "qdrantclient",
            "tf": 8,
            "weight": 0.014625
          },
          {
            "term": "search",
            "tf": 7,
            "weight": 0.012797
          },
          {
            "term": "target",
            "tf": 7,
            "weight": 0.012797
          },
          {
            "term": "discover",
            "tf": 7,
            "weight": 0.012797
          },
          {
            "term": "100",
            "tf": 7,
            "weight": 0.012797
          },
          {
            "term": "718",
            "tf": 7,
            "weight": 0.012797
          },
          {
            "term": "200",
            "tf": 7,
            "weight": 0.012797
          },
          {
            "term": "300",
            "tf": 7,
            "weight": 0.012797
          },
          {
            "term": "build",
            "tf": 7,
            "weight": 0.012797
          }
        ],
        "unique_terms": 199,
        "total_terms": 547
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": true
      },
      "search_keywords": [
        "Discovery search",
        "client",
        "collection",
        "import",
        "name",
        "negative",
        "new",
        "positive",
        "qdrant",
        "query",
        "the"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6908931506849316,
      "overall": 0.7636310502283106
    }
  },
  {
    "text": "### Context search  Conversely, in the absence of a target, a rigid integer-by-integer function doesnt provide much guidance for the search when utilizing a proximity graph like HNSW. Instead, context search employs a function derived from the [triplet-loss](https://qdrant.tech/articles/triplet-loss/) concept, which is usually applied during model training. For context search, this function is adapted to steer the search towards areas with fewer negative examples. We can directly associate the score function to a loss function, where 0.0 is the maximum score a point can have, which means it is only in positive areas. As soon as a point exists closer to a negative example, its loss will simply be the difference of the positive and negative similarities. $$ \\text{context score} = \\sum \\min(s(v^+\\_i) - s(v^-\\_i), 0.0) $$  Where $v^+\\_i$ and $v^-\\_i$ are the positive and negative examples of each pair, and $s(v)$ is the similarity function. Using this kind of search, you can expect the output to not necessarily be around a single point, but rather, to be any point that isnt closer to a negative example, which creates a constrained diverse result. So, even when the API is not called [`recommend`](#recommendation-api.md), recommendation systems can also use this approach and adapt it for their specific use-cases. Example: ```http POST /collections/{collection_name}/points/query {   \"query\": {     \"context\": [       {         \"positive\": 100,         \"negative\": 718       },       {         \"positive\": 200,         \"negative\": 300       }     ]   },   \"limit\": 10 } ``` ```python from qdrant_client import QdrantClient, models  client = QdrantClient(url=\"http://localhost:6333\")  discover_queries = [     models.QueryRequest(         query=models.ContextQuery(             context=[                 models.ContextPair(                     positive=100,                     negative=718,                 ),                 models.ContextPair(                     positive=200,                     negative=300,                 ),             ],         ),         limit=10,     ), ]  client.query_batch_points(     collection_name=\"{collection_name}\", requests=discover_queries ) ``` ```typescript import { QdrantClient } from \"@qdrant/js-client-rest\";  const client = new QdrantClient({ host: \"localhost\", port: 6333 });  client.query(\"{collection_name}\", {     query: {         context: [             {                 positive: 100,                 negative: 718,             },             {                 positive: 200,                 negative: 300,             },         ]     },     limit: 10, }); ``` ```rust use qdrant_client::qdrant::{ContextInputBuilder, QueryPointsBuilder}; use qdrant_client::Qdrant;  let client = Qdrant::from_url(\"http://localhost:6334\").build()?;  client     .query(         QueryPointsBuilder::new(\"{collection_name}\").query(             ContextInputBuilder::default()                 .add_pair(100, 718)                 .add_pair(200, 300)                 .build(),         ),     )     .await?; ``` ```java import java.util.List;  import io.qdrant.client.QdrantClient; import io.qdrant.client.QdrantGrpcClient; import io.qdrant.client.grpc.Points.ContextInput; import io.qdrant.client.grpc.Points.ContextInputPair; import io.qdrant.client.grpc.Points.QueryPoints;  import static io.qdrant.client.VectorInputFactory.vectorInput; import static io.qdrant.client.QueryFactory.context;  QdrantClient client =     new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());  client.queryAsync(QueryPoints.newBuilder()         .setCollectionName(\"{collection_name}\")         .setQuery(context(ContextInput.newBuilder()                 .addAllPairs(List.of(                         ContextInputPair.newBuilder()                                 .setPositive(vectorInput(100))                                 .setNegative(vectorInput(718))                                 .build(),                         ContextInputPair.newBuilder()                                 .setPositive(vectorInput(200))                                 .setNegative(vectorInput(300))                                 .build()))                 .build()))         .setLimit(10)         .build()).get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc;  var client = new QdrantClient(\"localhost\", 6334);  await client.QueryAsync(   collectionName: \"{collection_name}\",   query: new ContextInput {     Pairs = {       new ContextInputPair {         Positive = 100,           Negative = 718       },       new ContextInputPair {         Positive = 200,           Negative = 300       },     }   },   limit: 10 ); ``` ```go import (     \"context\"      \"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{     Host: \"localhost\",     Port: 6334, })  client.Query(context.Background(), &qdrant.QueryPoints{     CollectionName: \"{collection_name}\",     Query: qdrant.NewQueryContext(&qdrant.ContextInput{         Pairs: []*qdrant.ContextInputPair{             {                 Positive: qdrant.NewVectorInputID(qdrant.NewIDNum(100)),                 Negative: qdrant.NewVectorInputID(qdrant.NewIDNum(718)),             },             {                 Positive: qdrant.NewVectorInputID(qdrant.NewIDNum(200)),                 Negative: qdrant.NewVectorInputID(qdrant.NewIDNum(300)),             },         },     }), }) ``` Notes about context search:  - When providing ids as examples, they will be excluded from the results. - Score is always in descending order (larger is better), regardless of the metric used. - Best possible score is `0.0`, and it is normal that many points get this score.",
    "metadata": {
      "chunk_id": "9591099c224a-0021",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 21,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Context search"
      ],
      "heading_text": "Context search",
      "token_count": 1285,
      "char_count": 5683,
      "start_char": 45201,
      "end_char": 50884,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.8713438735177865,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.480850",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 1285,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Context search",
      "chunk_hash": "2fedbeb783a3a966",
      "content_digest": "2fedbeb783a3a966",
      "chunk_length": 5683,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "negative",
          "the",
          "positive",
          "context",
          "query",
          "import",
          "collection",
          "name",
          "qdrantclient",
          "search",
          "100",
          "718",
          "200",
          "300",
          "new",
          "build",
          "function",
          "score"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 33,
            "weight": 0.063584
          },
          {
            "term": "client",
            "tf": 26,
            "weight": 0.050096
          },
          {
            "term": "negative",
            "tf": 15,
            "weight": 0.028902
          },
          {
            "term": "the",
            "tf": 14,
            "weight": 0.026975
          },
          {
            "term": "positive",
            "tf": 13,
            "weight": 0.025048
          },
          {
            "term": "context",
            "tf": 12,
            "weight": 0.023121
          },
          {
            "term": "query",
            "tf": 11,
            "weight": 0.021195
          },
          {
            "term": "import",
            "tf": 11,
            "weight": 0.021195
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.015414
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.015414
          },
          {
            "term": "qdrantclient",
            "tf": 8,
            "weight": 0.015414
          },
          {
            "term": "search",
            "tf": 7,
            "weight": 0.013487
          },
          {
            "term": "100",
            "tf": 7,
            "weight": 0.013487
          },
          {
            "term": "718",
            "tf": 7,
            "weight": 0.013487
          },
          {
            "term": "200",
            "tf": 7,
            "weight": 0.013487
          },
          {
            "term": "300",
            "tf": 7,
            "weight": 0.013487
          },
          {
            "term": "new",
            "tf": 7,
            "weight": 0.013487
          },
          {
            "term": "build",
            "tf": 7,
            "weight": 0.013487
          },
          {
            "term": "function",
            "tf": 6,
            "weight": 0.011561
          },
          {
            "term": "score",
            "tf": 6,
            "weight": 0.011561
          }
        ],
        "unique_terms": 201,
        "total_terms": 519
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": true
      },
      "search_keywords": [
        "Context search",
        "client",
        "collection",
        "context",
        "import",
        "name",
        "negative",
        "positive",
        "qdrant",
        "query",
        "the"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.8713438735177865,
      "overall": 0.8237812911725954
    }
  },
  {
    "text": "## Distance Matrix  *Available as of v1.12.0*  The distance matrix API allows to calculate the distance between sampled pairs of vectors and to return the result as a sparse matrix. Such API enables new data exploration use cases such as clustering similar vectors, visualization of connections or dimension reduction. The API input request consists of the following parameters:  - `sample`: the number of vectors to sample - `limit`: the number of scores to return per sample - `filter`: the filter to apply to constraint the samples  Lets have a look at a basic example with `sample=100`, `limit=10`:  The engine starts by selecting `100` random points from the collection, then for each of the selected points, it will compute the top `10` closest points **within** the samples. This will results in a total of 1000 scores represented as a sparse matrix for efficient processing. The distance matrix API offers two output formats to ease the integration with different tools.",
    "metadata": {
      "chunk_id": "9591099c224a-0022",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 22,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Distance Matrix"
      ],
      "heading_text": "Distance Matrix",
      "token_count": 202,
      "char_count": 979,
      "start_char": 50898,
      "end_char": 51877,
      "semantic_score": 0.7999999999999999,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6817721518987342,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "list_section",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.484938",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 202,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Distance Matrix",
      "chunk_hash": "d462f5d7e7eae32d",
      "content_digest": "d462f5d7e7eae32d",
      "chunk_length": 979,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "the",
          "matrix",
          "distance",
          "api",
          "sample",
          "vectors",
          "points",
          "return",
          "sparse",
          "such",
          "number",
          "limit",
          "scores",
          "filter",
          "samples",
          "with",
          "100",
          "for",
          "will",
          "available"
        ],
        "term_weights": [
          {
            "term": "the",
            "tf": 16,
            "weight": 0.129032
          },
          {
            "term": "matrix",
            "tf": 5,
            "weight": 0.040323
          },
          {
            "term": "distance",
            "tf": 4,
            "weight": 0.032258
          },
          {
            "term": "api",
            "tf": 4,
            "weight": 0.032258
          },
          {
            "term": "sample",
            "tf": 4,
            "weight": 0.032258
          },
          {
            "term": "vectors",
            "tf": 3,
            "weight": 0.024194
          },
          {
            "term": "points",
            "tf": 3,
            "weight": 0.024194
          },
          {
            "term": "return",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "sparse",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "such",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "number",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "limit",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "scores",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "filter",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "samples",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "with",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "100",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "for",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "will",
            "tf": 2,
            "weight": 0.016129
          },
          {
            "term": "available",
            "tf": 1,
            "weight": 0.008065
          }
        ],
        "unique_terms": 80,
        "total_terms": 124
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Distance Matrix",
        "api",
        "distance",
        "matrix",
        "points",
        "return",
        "sample",
        "sparse",
        "such",
        "the",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7999999999999999,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6817721518987342,
      "overall": 0.7939240506329113
    }
  },
  {
    "text": "### Pairwise format  Returns the distance matrix as a list of pairs of point `ids` with their respective score. ```http POST /collections/{collection_name}/points/search/matrix/pairs {     \"sample\": 10,     \"limit\": 2,     \"filter\": {         \"must\": {             \"key\": \"color\",             \"match\": { \"value\": \"red\" }         }     }   } ``` ```python from qdrant_client import QdrantClient, models  client = QdrantClient(url=\"http://localhost:6333\")  client.search_matrix_pairs(     collection_name=\"{collection_name}\",     sample=10,     limit=2,     query_filter=models.Filter(         must=[             models.FieldCondition(                 key=\"color\", match=models.MatchValue(value=\"red\")             ),         ]     ), ) ``` ```typescript import { QdrantClient } from \"@qdrant/js-client-rest\";  const client = new QdrantClient({ host: \"localhost\", port: 6333 });  client.searchMatrixPairs(\"{collection_name}\", {     filter: {         must: [             {                 key: \"color\",                 match: {                     value: \"red\",                 },             },         ],     },     sample: 10,     limit: 2, }); ``` ```rust use qdrant_client::qdrant::{Condition, Filter, SearchMatrixPointsBuilder}; use qdrant_client::Qdrant;  client     .search_matrix_pairs(         SearchMatrixPointsBuilder::new(\"collection_name\")            .filter(Filter::must(vec![Condition::matches(                \"color\",                \"red\".to_string(),            )]))            .sample(10)            .limit(2),     )     .await?; ``` ```java import static io.qdrant.client.ConditionFactory.matchKeyword;  import io.qdrant.client.QdrantClient; import io.qdrant.client.QdrantGrpcClient; import io.qdrant.client.grpc.Points.Filter; import io.qdrant.client.grpc.Points.SearchMatrixPoints;  QdrantClient client =     new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());  client     .searchMatrixPairsAsync(         Points.SearchMatrixPoints.newBuilder()             .setCollectionName(\"{collection_name}\")             .setFilter(Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build())             .setSample(10)             .setLimit(2)             .build())     .get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc; using static Qdrant.Client.Grpc.Conditions;  var client = new QdrantClient(\"localhost\", 6334);  await client.SearchMatrixPairsAsync(     collectionName: \"{collection_name}\",     filter: MatchKeyword(\"color\", \"red\"),     sample: 10,     limit: 2 ); ``` ```go import (     \"context\"      \"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{     Host: \"localhost\",     Port: 6334, })  sample := uint64(10) limit := uint64(2) res, err := client.SearchMatrixPairs(ctx, &qdrant.SearchMatrixPoints{     CollectionName: \"{collection_name}\",     Sample:         &sample,     Limit:          &limit,     Filter: &qdrant.Filter{         Must: []*qdrant.Condition{             qdrant.NewMatch(\"color\", \"red\"),         },     }, }) ``` Returns ```json {     \"result\": {         \"pairs\": [             {\"a\": 1, \"b\": 3, \"score\": 1.4063001},             {\"a\": 1, \"b\": 4, \"score\": 1.2531},             {\"a\": 2, \"b\": 1, \"score\": 1.1550001},             {\"a\": 2, \"b\": 8, \"score\": 1.1359},             {\"a\": 3, \"b\": 1, \"score\": 1.4063001},             {\"a\": 3, \"b\": 4, \"score\": 1.2218001},             {\"a\": 4, \"b\": 1, \"score\": 1.2531},             {\"a\": 4, \"b\": 3, \"score\": 1.2218001},             {\"a\": 5, \"b\": 3, \"score\": 0.70239997},             {\"a\": 5, \"b\": 1, \"score\": 0.6146},             {\"a\": 6, \"b\": 3, \"score\": 0.6353},             {\"a\": 6, \"b\": 4, \"score\": 0.5093},             {\"a\": 7, \"b\": 3, \"score\": 1.0990001},             {\"a\": 7, \"b\": 1, \"score\": 1.0349001},             {\"a\": 8, \"b\": 2, \"score\": 1.1359},             {\"a\": 8, \"b\": 3, \"score\": 1.0553}         ]     } } ```",
    "metadata": {
      "chunk_id": "9591099c224a-0023",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 23,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Pairwise format"
      ],
      "heading_text": "Pairwise format",
      "token_count": 1137,
      "char_count": 3889,
      "start_char": 51883,
      "end_char": 55772,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6581818181818182,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.496459",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 1137,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Pairwise format",
      "chunk_hash": "ce2890a460b44a66",
      "content_digest": "ce2890a460b44a66",
      "chunk_length": 3889,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "client",
          "qdrant",
          "score",
          "filter",
          "collection",
          "name",
          "sample",
          "limit",
          "import",
          "qdrantclient",
          "color",
          "red",
          "pairs",
          "must",
          "localhost",
          "matrix",
          "points",
          "models",
          "new",
          "grpc"
        ],
        "term_weights": [
          {
            "term": "client",
            "tf": 24,
            "weight": 0.080268
          },
          {
            "term": "qdrant",
            "tf": 22,
            "weight": 0.073579
          },
          {
            "term": "score",
            "tf": 17,
            "weight": 0.056856
          },
          {
            "term": "filter",
            "tf": 12,
            "weight": 0.040134
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.026756
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.026756
          },
          {
            "term": "sample",
            "tf": 8,
            "weight": 0.026756
          },
          {
            "term": "limit",
            "tf": 8,
            "weight": 0.026756
          },
          {
            "term": "import",
            "tf": 8,
            "weight": 0.026756
          },
          {
            "term": "qdrantclient",
            "tf": 8,
            "weight": 0.026756
          },
          {
            "term": "color",
            "tf": 7,
            "weight": 0.023411
          },
          {
            "term": "red",
            "tf": 7,
            "weight": 0.023411
          },
          {
            "term": "pairs",
            "tf": 5,
            "weight": 0.016722
          },
          {
            "term": "must",
            "tf": 5,
            "weight": 0.016722
          },
          {
            "term": "localhost",
            "tf": 5,
            "weight": 0.016722
          },
          {
            "term": "matrix",
            "tf": 4,
            "weight": 0.013378
          },
          {
            "term": "points",
            "tf": 4,
            "weight": 0.013378
          },
          {
            "term": "models",
            "tf": 4,
            "weight": 0.013378
          },
          {
            "term": "new",
            "tf": 4,
            "weight": 0.013378
          },
          {
            "term": "grpc",
            "tf": 4,
            "weight": 0.013378
          }
        ],
        "unique_terms": 105,
        "total_terms": 299
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Pairwise format",
        "client",
        "collection",
        "filter",
        "import",
        "limit",
        "name",
        "qdrant",
        "qdrantclient",
        "sample",
        "score"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6581818181818182,
      "overall": 0.7527272727272726
    }
  },
  {
    "text": "### Offset format  Returns the distance matrix as a four arrays:  - `offsets_row` and `offsets_col`, represent the positions of non-zero distance values in the matrix. - `scores` contains the distance values. - `ids` contains the point ids corresponding to the distance values. ```http POST /collections/{collection_name}/points/search/matrix/offsets {     \"sample\": 10,     \"limit\": 2,     \"filter\": {         \"must\": {             \"key\": \"color\",             \"match\": { \"value\": \"red\" }         }     } } ``` ```python from qdrant_client import QdrantClient, models  client = QdrantClient(url=\"http://localhost:6333\")  client.search_matrix_offsets(     collection_name=\"{collection_name}\",     sample=10,     limit=2,     query_filter=models.Filter(         must=[             models.FieldCondition(                 key=\"color\", match=models.MatchValue(value=\"red\")             ),         ]     ), ) ``` ```typescript import { QdrantClient } from \"@qdrant/js-client-rest\";  const client = new QdrantClient({ host: \"localhost\", port: 6333 });  client.searchMatrixOffsets(\"{collection_name}\", {     filter: {         must: [             {                 key: \"color\",                 match: {                     value: \"red\",                 },             },         ],     },     sample: 10,     limit: 2, }); ``` ```rust use qdrant_client::qdrant::{Condition, Filter, SearchMatrixPointsBuilder}; use qdrant_client::Qdrant;  client     .search_matrix_offsets(         SearchMatrixPointsBuilder::new(\"collection_name\")            .filter(Filter::must(vec![Condition::matches(                \"color\",                \"red\".to_string(),            )]))            .sample(10)            .limit(2),     )     .await?; ``` ```java import static io.qdrant.client.ConditionFactory.matchKeyword;  import io.qdrant.client.QdrantClient; import io.qdrant.client.QdrantGrpcClient; import io.qdrant.client.grpc.Points.Filter; import io.qdrant.client.grpc.Points.SearchMatrixPoints;  QdrantClient client =     new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());  client     .searchMatrixOffsetsAsync(         SearchMatrixPoints.newBuilder()             .setCollectionName(\"{collection_name}\")             .setFilter(Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build())             .setSample(10)             .setLimit(2)             .build())     .get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc; using static Qdrant.Client.Grpc.Conditions;  var client = new QdrantClient(\"localhost\", 6334);  await client.SearchMatrixOffsetsAsync(     collectionName: \"{collection_name}\",     filter: MatchKeyword(\"color\", \"red\"),     sample: 10,     limit: 2 ); ``` ```go import (     \"context\"      \"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{     Host: \"localhost\",     Port: 6334, })  sample := uint64(10) limit := uint64(2) res, err := client.SearchMatrixOffsets(ctx, &qdrant.SearchMatrixPoints{     CollectionName: \"{collection_name}\",     Sample:         &sample,     Limit:          &limit,     Filter: &qdrant.Filter{         Must: []*qdrant.Condition{             qdrant.NewMatch(\"color\", \"red\"),         },     }, }) ``` Returns ```json {     \"result\": {         \"offsets_row\": [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7],         \"offsets_col\": [2, 3, 0, 7, 0, 3, 0, 2, 2, 0, 2, 3, 2, 0, 1, 2],         \"scores\": [             1.4063001, 1.2531, 1.1550001, 1.1359, 1.4063001,             1.2218001, 1.2531, 1.2218001, 0.70239997, 0.6146, 0.6353,             0.5093, 1.0990001, 1.0349001, 1.1359, 1.0553             ],         \"ids\": [1, 2, 3, 4, 5, 6, 7, 8]     } } ```",
    "metadata": {
      "chunk_id": "9591099c224a-0024",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "filename": "_documentation_concepts_explore_.md",
      "file_extension": ".md",
      "chunk_index": 24,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Offset format"
      ],
      "heading_text": "Offset format",
      "token_count": 1055,
      "char_count": 3664,
      "start_char": 55783,
      "end_char": 59447,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6822784810126583,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:17.506016",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 1055,
      "document_id": "9591099c224a",
      "document_name": "_documentation_concepts_explore_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "source_filename": "_documentation_concepts_explore_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_explore\\_documentation_concepts_explore_.md",
      "hierarchy_path": "Offset format",
      "chunk_hash": "d590370c9d8b2cf7",
      "content_digest": "d590370c9d8b2cf7",
      "chunk_length": 3664,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "client",
          "qdrant",
          "filter",
          "collection",
          "name",
          "sample",
          "limit",
          "import",
          "qdrantclient",
          "offsets",
          "color",
          "red",
          "the",
          "matrix",
          "must",
          "localhost",
          "distance",
          "models",
          "new",
          "grpc"
        ],
        "term_weights": [
          {
            "term": "client",
            "tf": 24,
            "weight": 0.07767
          },
          {
            "term": "qdrant",
            "tf": 22,
            "weight": 0.071197
          },
          {
            "term": "filter",
            "tf": 12,
            "weight": 0.038835
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.02589
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.02589
          },
          {
            "term": "sample",
            "tf": 8,
            "weight": 0.02589
          },
          {
            "term": "limit",
            "tf": 8,
            "weight": 0.02589
          },
          {
            "term": "import",
            "tf": 8,
            "weight": 0.02589
          },
          {
            "term": "qdrantclient",
            "tf": 8,
            "weight": 0.02589
          },
          {
            "term": "offsets",
            "tf": 7,
            "weight": 0.022654
          },
          {
            "term": "color",
            "tf": 7,
            "weight": 0.022654
          },
          {
            "term": "red",
            "tf": 7,
            "weight": 0.022654
          },
          {
            "term": "the",
            "tf": 6,
            "weight": 0.019417
          },
          {
            "term": "matrix",
            "tf": 5,
            "weight": 0.016181
          },
          {
            "term": "must",
            "tf": 5,
            "weight": 0.016181
          },
          {
            "term": "localhost",
            "tf": 5,
            "weight": 0.016181
          },
          {
            "term": "distance",
            "tf": 4,
            "weight": 0.012945
          },
          {
            "term": "models",
            "tf": 4,
            "weight": 0.012945
          },
          {
            "term": "new",
            "tf": 4,
            "weight": 0.012945
          },
          {
            "term": "grpc",
            "tf": 4,
            "weight": 0.012945
          }
        ],
        "unique_terms": 113,
        "total_terms": 309
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Offset format",
        "client",
        "collection",
        "filter",
        "import",
        "limit",
        "name",
        "offsets",
        "qdrant",
        "qdrantclient",
        "sample"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6822784810126583,
      "overall": 0.760759493670886
    }
  }
]