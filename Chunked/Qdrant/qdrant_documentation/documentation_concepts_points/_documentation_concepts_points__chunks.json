[
  {
    "text": "### User Manual  [Concepts](https://qdrant.tech/documentation/concepts/)  - [Collections](https://qdrant.tech/documentation/concepts/collections/) - [Points](https://qdrant.tech/documentation/concepts/points/) - [Vectors](https://qdrant.tech/documentation/concepts/vectors/) - [Payload](https://qdrant.tech/documentation/concepts/payload/) - [Search](https://qdrant.tech/documentation/concepts/search/) - [Explore](https://qdrant.tech/documentation/concepts/explore/) - [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/) - [Filtering](https://qdrant.tech/documentation/concepts/filtering/) - [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/) - [Storage](https://qdrant.tech/documentation/concepts/storage/) - [Indexing](https://qdrant.tech/documentation/concepts/indexing/) - [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)  [Guides](https://qdrant.tech/documentation/guides/installation/)  - [Installation](https://qdrant.tech/documentation/guides/installation/) - [Administration](https://qdrant.tech/documentation/guides/administration/) - [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/) - [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/) - [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/) - [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/) - [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/) - [Quantization](https://qdrant.tech/documentation/guides/quantization/) - [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/) - [Configuration](https://qdrant.tech/documentation/guides/configuration/) - [Security](https://qdrant.tech/documentation/guides/security/) - [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/) - [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)",
    "metadata": {
      "chunk_id": "b2de55f15c63-0001",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 1,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "User Manual"
      ],
      "heading_text": "User Manual",
      "token_count": 485,
      "char_count": 1968,
      "start_char": 1032,
      "end_char": 3000,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.659256",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 485,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "User Manual",
      "chunk_hash": "aa99483e94fddd20",
      "content_digest": "aa99483e94fddd20",
      "chunk_length": 1968,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "https",
          "qdrant",
          "tech",
          "documentation",
          "guides",
          "concepts",
          "installation",
          "collections",
          "points",
          "vectors",
          "payload",
          "search",
          "explore",
          "hybrid",
          "queries",
          "filtering",
          "optimizer",
          "storage",
          "indexing",
          "snapshots"
        ],
        "term_weights": [
          {
            "term": "https",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "qdrant",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "tech",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "documentation",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "guides",
            "tf": 15,
            "weight": 0.072816
          },
          {
            "term": "concepts",
            "tf": 14,
            "weight": 0.067961
          },
          {
            "term": "installation",
            "tf": 3,
            "weight": 0.014563
          },
          {
            "term": "collections",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "points",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "vectors",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "payload",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "search",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "explore",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "hybrid",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "queries",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "filtering",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "optimizer",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "storage",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "indexing",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "snapshots",
            "tf": 2,
            "weight": 0.009709
          }
        ],
        "unique_terms": 45,
        "total_terms": 206
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "User Manual",
        "collections",
        "concepts",
        "documentation",
        "guides",
        "https",
        "installation",
        "points",
        "qdrant",
        "tech",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "overall": 0.7776666666666666
    }
  },
  {
    "text": "### Tutorials  [Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)  - [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/) - [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/) - [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/) - [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)  [Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)  - [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/) - [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/) - [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/) - [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/) - [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)  [Using the Database](https://qdrant.tech/documentation/database-tutorials/)  - [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/) - [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/) - [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/) - [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/) - [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/) - [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/) - [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)",
    "metadata": {
      "chunk_id": "b2de55f15c63-0003",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 3,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Tutorials"
      ],
      "heading_text": "Tutorials",
      "token_count": 459,
      "char_count": 1988,
      "start_char": 3682,
      "end_char": 5670,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.665455",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 459,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Tutorials",
      "chunk_hash": "f480f0283a04b78a",
      "content_digest": "f480f0283a04b78a",
      "chunk_length": 1988,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "tutorials",
          "https",
          "tech",
          "documentation",
          "search",
          "database",
          "advanced",
          "beginner",
          "with",
          "hybrid",
          "retrieval",
          "build",
          "scale",
          "neural",
          "fastembed",
          "quality",
          "multivector",
          "representations",
          "using"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 22,
            "weight": 0.098655
          },
          {
            "term": "tutorials",
            "tf": 20,
            "weight": 0.089686
          },
          {
            "term": "https",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "tech",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "documentation",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "search",
            "tf": 14,
            "weight": 0.06278
          },
          {
            "term": "database",
            "tf": 9,
            "weight": 0.040359
          },
          {
            "term": "advanced",
            "tf": 7,
            "weight": 0.03139
          },
          {
            "term": "beginner",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "with",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "hybrid",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "retrieval",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "build",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "scale",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "neural",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "fastembed",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "quality",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "multivector",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "representations",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "using",
            "tf": 2,
            "weight": 0.008969
          }
        ],
        "unique_terms": 64,
        "total_terms": 223
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Tutorials",
        "advanced",
        "beginner",
        "database",
        "documentation",
        "https",
        "qdrant",
        "search",
        "tech",
        "tutorials",
        "with"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "overall": 0.7826697594501718
    }
  },
  {
    "text": "### Support  [FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)  - [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/) - [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)  [Release Notes](https://github.com/qdrant/qdrant/releases)",
    "metadata": {
      "chunk_id": "b2de55f15c63-0004",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 4,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Support"
      ],
      "heading_text": "Support",
      "token_count": 83,
      "char_count": 311,
      "start_char": 5672,
      "end_char": 5983,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.5627272727272727,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.666568",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 83,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Support",
      "chunk_hash": "f059a5deb61e367d",
      "content_digest": "f059a5deb61e367d",
      "chunk_length": 311,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "faq",
          "https",
          "tech",
          "documentation",
          "fundamentals",
          "database",
          "optimization",
          "support",
          "release",
          "notes",
          "github",
          "com",
          "releases"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 8,
            "weight": 0.228571
          },
          {
            "term": "faq",
            "tf": 4,
            "weight": 0.114286
          },
          {
            "term": "https",
            "tf": 4,
            "weight": 0.114286
          },
          {
            "term": "tech",
            "tf": 3,
            "weight": 0.085714
          },
          {
            "term": "documentation",
            "tf": 3,
            "weight": 0.085714
          },
          {
            "term": "fundamentals",
            "tf": 3,
            "weight": 0.085714
          },
          {
            "term": "database",
            "tf": 2,
            "weight": 0.057143
          },
          {
            "term": "optimization",
            "tf": 2,
            "weight": 0.057143
          },
          {
            "term": "support",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "release",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "notes",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "github",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "com",
            "tf": 1,
            "weight": 0.028571
          },
          {
            "term": "releases",
            "tf": 1,
            "weight": 0.028571
          }
        ],
        "unique_terms": 14,
        "total_terms": 35
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Support",
        "database",
        "documentation",
        "faq",
        "fundamentals",
        "https",
        "optimization",
        "qdrant",
        "release",
        "support",
        "tech"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.5627272727272727,
      "overall": 0.7209090909090908
    }
  },
  {
    "text": "### User Manual  [Concepts](https://qdrant.tech/documentation/concepts/)  - [Collections](https://qdrant.tech/documentation/concepts/collections/) - [Points](https://qdrant.tech/documentation/concepts/points/) - [Vectors](https://qdrant.tech/documentation/concepts/vectors/) - [Payload](https://qdrant.tech/documentation/concepts/payload/) - [Search](https://qdrant.tech/documentation/concepts/search/) - [Explore](https://qdrant.tech/documentation/concepts/explore/) - [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/) - [Filtering](https://qdrant.tech/documentation/concepts/filtering/) - [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/) - [Storage](https://qdrant.tech/documentation/concepts/storage/) - [Indexing](https://qdrant.tech/documentation/concepts/indexing/) - [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)  [Guides](https://qdrant.tech/documentation/guides/installation/)  - [Installation](https://qdrant.tech/documentation/guides/installation/) - [Administration](https://qdrant.tech/documentation/guides/administration/) - [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/) - [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/) - [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/) - [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/) - [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/) - [Quantization](https://qdrant.tech/documentation/guides/quantization/) - [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/) - [Configuration](https://qdrant.tech/documentation/guides/configuration/) - [Security](https://qdrant.tech/documentation/guides/security/) - [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/) - [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)",
    "metadata": {
      "chunk_id": "b2de55f15c63-0006",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 6,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "User Manual"
      ],
      "heading_text": "User Manual",
      "token_count": 485,
      "char_count": 1968,
      "start_char": 6360,
      "end_char": 8328,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.675795",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 485,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "User Manual",
      "chunk_hash": "aa99483e94fddd20",
      "content_digest": "aa99483e94fddd20",
      "chunk_length": 1968,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "https",
          "qdrant",
          "tech",
          "documentation",
          "guides",
          "concepts",
          "installation",
          "collections",
          "points",
          "vectors",
          "payload",
          "search",
          "explore",
          "hybrid",
          "queries",
          "filtering",
          "optimizer",
          "storage",
          "indexing",
          "snapshots"
        ],
        "term_weights": [
          {
            "term": "https",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "qdrant",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "tech",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "documentation",
            "tf": 27,
            "weight": 0.131068
          },
          {
            "term": "guides",
            "tf": 15,
            "weight": 0.072816
          },
          {
            "term": "concepts",
            "tf": 14,
            "weight": 0.067961
          },
          {
            "term": "installation",
            "tf": 3,
            "weight": 0.014563
          },
          {
            "term": "collections",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "points",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "vectors",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "payload",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "search",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "explore",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "hybrid",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "queries",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "filtering",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "optimizer",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "storage",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "indexing",
            "tf": 2,
            "weight": 0.009709
          },
          {
            "term": "snapshots",
            "tf": 2,
            "weight": 0.009709
          }
        ],
        "unique_terms": 45,
        "total_terms": 206
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "User Manual",
        "collections",
        "concepts",
        "documentation",
        "guides",
        "https",
        "installation",
        "points",
        "qdrant",
        "tech",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.733,
      "overall": 0.7776666666666666
    }
  },
  {
    "text": "### Tutorials  [Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)  - [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/) - [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/) - [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/) - [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)  [Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)  - [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/) - [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/) - [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/) - [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/) - [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)  [Using the Database](https://qdrant.tech/documentation/database-tutorials/)  - [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/) - [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/) - [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/) - [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/) - [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/) - [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/) - [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)",
    "metadata": {
      "chunk_id": "b2de55f15c63-0008",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 8,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Tutorials"
      ],
      "heading_text": "Tutorials",
      "token_count": 459,
      "char_count": 1988,
      "start_char": 9010,
      "end_char": 10998,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.683174",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 459,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Tutorials",
      "chunk_hash": "f480f0283a04b78a",
      "content_digest": "f480f0283a04b78a",
      "chunk_length": 1988,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "tutorials",
          "https",
          "tech",
          "documentation",
          "search",
          "database",
          "advanced",
          "beginner",
          "with",
          "hybrid",
          "retrieval",
          "build",
          "scale",
          "neural",
          "fastembed",
          "quality",
          "multivector",
          "representations",
          "using"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 22,
            "weight": 0.098655
          },
          {
            "term": "tutorials",
            "tf": 20,
            "weight": 0.089686
          },
          {
            "term": "https",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "tech",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "documentation",
            "tf": 19,
            "weight": 0.085202
          },
          {
            "term": "search",
            "tf": 14,
            "weight": 0.06278
          },
          {
            "term": "database",
            "tf": 9,
            "weight": 0.040359
          },
          {
            "term": "advanced",
            "tf": 7,
            "weight": 0.03139
          },
          {
            "term": "beginner",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "with",
            "tf": 5,
            "weight": 0.022422
          },
          {
            "term": "hybrid",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "retrieval",
            "tf": 4,
            "weight": 0.017937
          },
          {
            "term": "build",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "scale",
            "tf": 3,
            "weight": 0.013453
          },
          {
            "term": "neural",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "fastembed",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "quality",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "multivector",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "representations",
            "tf": 2,
            "weight": 0.008969
          },
          {
            "term": "using",
            "tf": 2,
            "weight": 0.008969
          }
        ],
        "unique_terms": 64,
        "total_terms": 223
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Tutorials",
        "advanced",
        "beginner",
        "database",
        "documentation",
        "https",
        "qdrant",
        "search",
        "tech",
        "tutorials",
        "with"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.7480092783505154,
      "overall": 0.7826697594501718
    }
  },
  {
    "text": "# Points  The points are the central entity that Qdrant operates with. A point is a record consisting of a [vector](https://qdrant.tech/documentation/concepts/vectors/) and an optional [payload](https://qdrant.tech/documentation/concepts/payload/). It looks like this: ```json // This is a simple point {     \"id\": 129,     \"vector\": [0.1, 0.2, 0.3, 0.4],     \"payload\": {\"color\": \"red\"}, } ``` You can search among the points grouped in one [collection](https://qdrant.tech/documentation/concepts/collections/) based on vector similarity. This procedure is described in more detail in the [search](https://qdrant.tech/documentation/concepts/search/) and [filtering](https://qdrant.tech/documentation/concepts/filtering/) sections. This section explains how to create and manage vectors. Any point modification operation is asynchronous and takes place in 2 steps. At the first stage, the operation is written to the Write-ahead-log. After this moment, the service will not lose the data, even if the machine loses power supply.",
    "metadata": {
      "chunk_id": "b2de55f15c63-0010",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 10,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Points"
      ],
      "heading_text": "Points",
      "token_count": 245,
      "char_count": 1028,
      "start_char": 11439,
      "end_char": 12467,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.5156,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.688213",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 245,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Points",
      "chunk_hash": "eb410c70ecc5bd01",
      "content_digest": "eb410c70ecc5bd01",
      "chunk_length": 1028,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "the",
          "qdrant",
          "https",
          "tech",
          "documentation",
          "concepts",
          "this",
          "and",
          "points",
          "point",
          "vector",
          "payload",
          "search",
          "vectors",
          "filtering",
          "operation",
          "are",
          "central",
          "entity",
          "that"
        ],
        "term_weights": [
          {
            "term": "the",
            "tf": 10,
            "weight": 0.08
          },
          {
            "term": "qdrant",
            "tf": 6,
            "weight": 0.048
          },
          {
            "term": "https",
            "tf": 5,
            "weight": 0.04
          },
          {
            "term": "tech",
            "tf": 5,
            "weight": 0.04
          },
          {
            "term": "documentation",
            "tf": 5,
            "weight": 0.04
          },
          {
            "term": "concepts",
            "tf": 5,
            "weight": 0.04
          },
          {
            "term": "this",
            "tf": 5,
            "weight": 0.04
          },
          {
            "term": "and",
            "tf": 4,
            "weight": 0.032
          },
          {
            "term": "points",
            "tf": 3,
            "weight": 0.024
          },
          {
            "term": "point",
            "tf": 3,
            "weight": 0.024
          },
          {
            "term": "vector",
            "tf": 3,
            "weight": 0.024
          },
          {
            "term": "payload",
            "tf": 3,
            "weight": 0.024
          },
          {
            "term": "search",
            "tf": 3,
            "weight": 0.024
          },
          {
            "term": "vectors",
            "tf": 2,
            "weight": 0.016
          },
          {
            "term": "filtering",
            "tf": 2,
            "weight": 0.016
          },
          {
            "term": "operation",
            "tf": 2,
            "weight": 0.016
          },
          {
            "term": "are",
            "tf": 1,
            "weight": 0.008
          },
          {
            "term": "central",
            "tf": 1,
            "weight": 0.008
          },
          {
            "term": "entity",
            "tf": 1,
            "weight": 0.008
          },
          {
            "term": "that",
            "tf": 1,
            "weight": 0.008
          }
        ],
        "unique_terms": 75,
        "total_terms": 125
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Points",
        "and",
        "concepts",
        "documentation",
        "https",
        "point",
        "points",
        "qdrant",
        "tech",
        "the",
        "this"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.5156,
      "overall": 0.7051999999999999
    }
  },
  {
    "text": "### Update vectors  *Available as of v1.2.0*  This method updates the specified vectors on the given points. Unspecified vectors are kept unchanged. All given points must exist. REST API ([Schema](https://api.qdrant.tech/api-reference/points/update-vectors)): ```http PUT /collections/{collection_name}/points/vectors {     \"points\": [         {             \"id\": 1,             \"vector\": {                 \"image\": [0.1, 0.2, 0.3, 0.4]             }         },         {             \"id\": 2,             \"vector\": {                 \"text\": [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]             }         }     ] } ``` ```python client.update_vectors(     collection_name=\"{collection_name}\",     points=[         models.PointVectors(             id=1,             vector={                 \"image\": [0.1, 0.2, 0.3, 0.4],             },         ),         models.PointVectors(             id=2,             vector={                 \"text\": [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2],             },         ),     ], ) ``` ```typescript client.updateVectors(\"{collection_name}\", {   points: [     {       id: 1,       vector: {         image: [0.1, 0.2, 0.3, 0.4],       },     },     {       id: 2,       vector: {         text: [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2],       },     },   ], }); ``` ```rust use std::collections::HashMap;  use qdrant_client::qdrant::{     PointVectors, UpdatePointVectorsBuilder, };  client     .update_vectors(         UpdatePointVectorsBuilder::new(             \"{collection_name}\",             vec![                 PointVectors {                     id: Some(1.into()),                     vectors: Some(                         HashMap::from([(\"image\".to_string(), vec![0.1, 0.2, 0.3, 0.4])]).into(),                     ),                 },                 PointVectors {                     id: Some(2.into()),                     vectors: Some(                         HashMap::from([(                             \"text\".to_string(),                             vec![0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2],                         )])                         .into(),                     ),                 },             ],         )         .wait(true),     )     .await?; ``` ```java import java.util.List; import java.util.Map;  import static io.qdrant.client.PointIdFactory.id; import static io.qdrant.client.VectorFactory.vector; import static io.qdrant.client.VectorsFactory.namedVectors;  client     .updateVectorsAsync(         \"{collection_name}\",         List.of(             PointVectors.newBuilder()                 .setId(id(1))                 .setVectors(namedVectors(Map.of(\"image\", vector(List.of(0.1f, 0.2f, 0.3f, 0.4f)))))                 .build(),             PointVectors.newBuilder()                 .setId(id(2))                 .setVectors(                     namedVectors(                         Map.of(                             \"text\", vector(List.of(0.9f, 0.8f, 0.7f, 0.6f, 0.5f, 0.4f, 0.3f, 0.2f)))))                 .build()))     .get(); ``` ```csharp using Qdrant.Client; using Qdrant.Client.Grpc;  var client = new QdrantClient(\"localhost\", 6334);  await client.UpdateVectorsAsync( \tcollectionName: \"{collection_name}\", \tpoints: new List<PointVectors> \t{ \t\tnew() { Id = 1, Vectors = (\"image\", new float[] { 0.1f, 0.2f, 0.3f, 0.4f }) }, \t\tnew() \t\t{ \t\t\tId = 2, \t\t\tVectors = (\"text\", new float[] { 0.9f, 0.8f, 0.7f, 0.6f, 0.5f, 0.4f, 0.3f, 0.2f }) \t\t} \t} ); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{ \tHost: \"localhost\", \tPort: 6334, })  client.UpdateVectors(context.Background(), &qdrant.UpdatePointVectors{ \tCollectionName: \"{collection_name}\", \tPoints: []*qdrant.PointVectors{ \t\t{ \t\t\tId: qdrant.NewIDNum(1), \t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{ \t\t\t\t\"image\": qdrant.NewVector(0.1, 0.2, 0.3, 0.4), \t\t\t}), \t\t}, \t\t{ \t\t\tId: qdrant.NewIDNum(2), \t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{ \t\t\t\t\"text\": qdrant.NewVector(0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2), \t\t\t}), \t\t}, \t}, }) ``` To update points and replace all of its vectors, see [uploading points](#upload-points.md).",
    "metadata": {
      "chunk_id": "b2de55f15c63-0016",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 16,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Update vectors"
      ],
      "heading_text": "Update vectors",
      "token_count": 1296,
      "char_count": 4162,
      "start_char": 39722,
      "end_char": 43884,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6597733711048159,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.769313",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 1296,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Update vectors",
      "chunk_hash": "d1b78048141d917e",
      "content_digest": "d1b78048141d917e",
      "chunk_length": 4162,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "vectors",
          "points",
          "vector",
          "pointvectors",
          "collection",
          "name",
          "image",
          "text",
          "new",
          "import",
          "update",
          "list",
          "map",
          "some",
          "into",
          "string",
          "api",
          "hashmap"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 22,
            "weight": 0.08209
          },
          {
            "term": "client",
            "tf": 15,
            "weight": 0.05597
          },
          {
            "term": "vectors",
            "tf": 14,
            "weight": 0.052239
          },
          {
            "term": "points",
            "tf": 12,
            "weight": 0.044776
          },
          {
            "term": "vector",
            "tf": 11,
            "weight": 0.041045
          },
          {
            "term": "pointvectors",
            "tf": 9,
            "weight": 0.033582
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.029851
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.029851
          },
          {
            "term": "image",
            "tf": 7,
            "weight": 0.026119
          },
          {
            "term": "text",
            "tf": 7,
            "weight": 0.026119
          },
          {
            "term": "new",
            "tf": 7,
            "weight": 0.026119
          },
          {
            "term": "import",
            "tf": 6,
            "weight": 0.022388
          },
          {
            "term": "update",
            "tf": 5,
            "weight": 0.018657
          },
          {
            "term": "list",
            "tf": 5,
            "weight": 0.018657
          },
          {
            "term": "map",
            "tf": 5,
            "weight": 0.018657
          },
          {
            "term": "some",
            "tf": 4,
            "weight": 0.014925
          },
          {
            "term": "into",
            "tf": 4,
            "weight": 0.014925
          },
          {
            "term": "string",
            "tf": 4,
            "weight": 0.014925
          },
          {
            "term": "api",
            "tf": 3,
            "weight": 0.011194
          },
          {
            "term": "hashmap",
            "tf": 3,
            "weight": 0.011194
          }
        ],
        "unique_terms": 96,
        "total_terms": 268
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Update vectors",
        "client",
        "collection",
        "image",
        "name",
        "points",
        "pointvectors",
        "qdrant",
        "text",
        "vector",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6597733711048159,
      "overall": 0.7199244570349386
    }
  },
  {
    "text": "### Delete vectors  *Available as of v1.2.0*  This method deletes just the specified vectors from the given points. Other vectors are kept unchanged. Points are never deleted. REST API ([Schema](https://api.qdrant.tech/api-reference/points/delete-vectors)): ```http POST /collections/{collection_name}/points/vectors/delete {     \"points\": [0, 3, 100],     \"vectors\": [\"text\", \"image\"] } ``` ```python client.delete_vectors(     collection_name=\"{collection_name}\",     points=[0, 3, 100],     vectors=[\"text\", \"image\"], ) ``` ```typescript client.deleteVectors(\"{collection_name}\", {   points: [0, 3, 10],   vector: [\"text\", \"image\"], }); ``` ```rust use qdrant_client::qdrant::{     DeletePointVectorsBuilder, PointsIdsList, };  client     .delete_vectors(         DeletePointVectorsBuilder::new(\"{collection_name}\")             .points_selector(PointsIdsList {                 ids: vec![0.into(), 3.into(), 10.into()],             })             .vectors(vec![\"text\".into(), \"image\".into()])             .wait(true),     )     .await?; ``` ```java import java.util.List;  import static io.qdrant.client.PointIdFactory.id;  client     .deleteVectorsAsync(         \"{collection_name}\", List.of(\"text\", \"image\"), List.of(id(0), id(3), id(10)))     .get(); ``` ```csharp await client.DeleteVectorsAsync(\"{collection_name}\", [\"text\", \"image\"], [0, 3, 10]); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client.DeleteVectors(context.Background(), &qdrant.DeletePointVectors{ \tCollectionName: \"{collection_name}\", \tPointsSelector: qdrant.NewPointsSelector( \t\tqdrant.NewIDNum(0), qdrant.NewIDNum(3), qdrant.NewIDNum(10)), \tVectors: &qdrant.VectorsSelector{ \t\tNames: []string{\"text\", \"image\"}, \t}, }) ``` To delete entire points, see [deleting points](#delete-points.md).",
    "metadata": {
      "chunk_id": "b2de55f15c63-0017",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 17,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Delete vectors"
      ],
      "heading_text": "Delete vectors",
      "token_count": 482,
      "char_count": 1791,
      "start_char": 43895,
      "end_char": 45686,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.5812197183098591,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.774737",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 482,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Delete vectors",
      "chunk_hash": "56d7e00284ba5b8f",
      "content_digest": "56d7e00284ba5b8f",
      "chunk_length": 1791,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "vectors",
          "points",
          "client",
          "collection",
          "name",
          "delete",
          "text",
          "image",
          "into",
          "api",
          "import",
          "list",
          "newidnum",
          "the",
          "are",
          "100",
          "deletevectors",
          "deletepointvectorsbuilder",
          "pointsidslist"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 12,
            "weight": 0.071429
          },
          {
            "term": "vectors",
            "tf": 11,
            "weight": 0.065476
          },
          {
            "term": "points",
            "tf": 11,
            "weight": 0.065476
          },
          {
            "term": "client",
            "tf": 9,
            "weight": 0.053571
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.047619
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.047619
          },
          {
            "term": "delete",
            "tf": 7,
            "weight": 0.041667
          },
          {
            "term": "text",
            "tf": 7,
            "weight": 0.041667
          },
          {
            "term": "image",
            "tf": 7,
            "weight": 0.041667
          },
          {
            "term": "into",
            "tf": 5,
            "weight": 0.029762
          },
          {
            "term": "api",
            "tf": 3,
            "weight": 0.017857
          },
          {
            "term": "import",
            "tf": 3,
            "weight": 0.017857
          },
          {
            "term": "list",
            "tf": 3,
            "weight": 0.017857
          },
          {
            "term": "newidnum",
            "tf": 3,
            "weight": 0.017857
          },
          {
            "term": "the",
            "tf": 2,
            "weight": 0.011905
          },
          {
            "term": "are",
            "tf": 2,
            "weight": 0.011905
          },
          {
            "term": "100",
            "tf": 2,
            "weight": 0.011905
          },
          {
            "term": "deletevectors",
            "tf": 2,
            "weight": 0.011905
          },
          {
            "term": "deletepointvectorsbuilder",
            "tf": 2,
            "weight": 0.011905
          },
          {
            "term": "pointsidslist",
            "tf": 2,
            "weight": 0.011905
          }
        ],
        "unique_terms": 74,
        "total_terms": 168
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Delete vectors",
        "client",
        "collection",
        "delete",
        "image",
        "into",
        "name",
        "points",
        "qdrant",
        "text",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.5812197183098591,
      "overall": 0.6937399061032864
    }
  },
  {
    "text": "### Update payload\n\nLearn how to modify the payload of a point in the [Payload](https://qdrant.tech/documentation/concepts/payload/#update-payload) section.",
    "metadata": {
      "chunk_id": "b2de55f15c63-0018",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 18,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Update payload"
      ],
      "heading_text": "Update payload",
      "token_count": 36,
      "char_count": 156,
      "start_char": 45697,
      "end_char": 45853,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.5525,
      "chunking_strategy": "hybrid_adaptive_semchunk",
      "content_type": "prose_section",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.775451",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 36,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Update payload",
      "chunk_hash": "f3abf0098521731d",
      "content_digest": "f3abf0098521731d",
      "chunk_length": 156,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "payload",
          "update",
          "the",
          "learn",
          "how",
          "modify",
          "point",
          "https",
          "qdrant",
          "tech",
          "documentation",
          "concepts",
          "section"
        ],
        "term_weights": [
          {
            "term": "payload",
            "tf": 5,
            "weight": 0.263158
          },
          {
            "term": "update",
            "tf": 2,
            "weight": 0.105263
          },
          {
            "term": "the",
            "tf": 2,
            "weight": 0.105263
          },
          {
            "term": "learn",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "how",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "modify",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "point",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "https",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "qdrant",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "tech",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "documentation",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "concepts",
            "tf": 1,
            "weight": 0.052632
          },
          {
            "term": "section",
            "tf": 1,
            "weight": 0.052632
          }
        ],
        "unique_terms": 13,
        "total_terms": 19
      },
      "modal_hint": "prose",
      "content_flags": {
        "has_code_block": false,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Update payload",
        "how",
        "https",
        "learn",
        "modify",
        "payload",
        "point",
        "qdrant",
        "tech",
        "the",
        "update"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.5525,
      "overall": 0.7174999999999999
    }
  },
  {
    "text": "## Delete points  REST API ([Schema](https://api.qdrant.tech/api-reference/points/delete-points)): ```http POST /collections/{collection_name}/points/delete {     \"points\": [0, 3, 100] } ``` ```python client.delete(     collection_name=\"{collection_name}\",     points_selector=models.PointIdsList(         points=[0, 3, 100],     ), ) ``` ```typescript client.delete(\"{collection_name}\", {   points: [0, 3, 100], }); ``` ```rust use qdrant_client::qdrant::{DeletePointsBuilder, PointsIdsList};  client     .delete_points(         DeletePointsBuilder::new(\"{collection_name}\")             .points(PointsIdsList {                 ids: vec![0.into(), 3.into(), 100.into()],             })             .wait(true),     )     .await?; ``` ```java import java.util.List;  import static io.qdrant.client.PointIdFactory.id;  client.deleteAsync(\"{collection_name}\", List.of(id(0), id(3), id(100))); ``` ```csharp using Qdrant.Client;  var client = new QdrantClient(\"localhost\", 6334);  await client.DeleteAsync(collectionName: \"{collection_name}\", ids: [0, 3, 100]); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{ \tHost: \"localhost\", \tPort: 6334, })  client.Delete(context.Background(), &qdrant.DeletePoints{ \tCollectionName: \"{collection_name}\", \tPoints: qdrant.NewPointsSelector( \t\tqdrant.NewIDNum(0), qdrant.NewIDNum(3), qdrant.NewIDNum(100), \t), }) ``` Alternative way to specify which points to remove is to use filter. ```http POST /collections/{collection_name}/points/delete {     \"filter\": {         \"must\": [             {                 \"key\": \"color\",                 \"match\": {                     \"value\": \"red\"                 }             }         ]     } } ``` ```python client.delete(     collection_name=\"{collection_name}\",     points_selector=models.FilterSelector(         filter=models.Filter(             must=[                 models.FieldCondition(                     key=\"color\",                     match=models.MatchValue(value=\"red\"),                 ),             ],         )     ), ) ``` ```typescript client.delete(\"{collection_name}\", {   filter: {     must: [       {         key: \"color\",         match: {           value: \"red\",         },       },     ],   }, }); ``` ```rust use qdrant_client::qdrant::{Condition, DeletePointsBuilder, Filter};  client     .delete_points(         DeletePointsBuilder::new(\"{collection_name}\")             .points(Filter::must([Condition::matches(                 \"color\",                 \"red\".to_string(),             )]))             .wait(true),     )     .await?; ``` ```java import static io.qdrant.client.ConditionFactory.matchKeyword;  import io.qdrant.client.grpc.Points.Filter;  client     .deleteAsync(         \"{collection_name}\",         Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build())     .get(); ``` ```csharp using Qdrant.Client; using static Qdrant.Client.Grpc.Conditions;  var client = new QdrantClient(\"localhost\", 6334);  await client.DeleteAsync(collectionName: \"{collection_name}\", filter: MatchKeyword(\"color\", \"red\")); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{ \tHost: \"localhost\", \tPort: 6334, })  client.Delete(context.Background(), &qdrant.DeletePoints{ \tCollectionName: \"{collection_name}\", \tPoints: qdrant.NewPointsSelectorFilter( \t\t&qdrant.Filter{ \t\t\tMust: []*qdrant.Condition{ \t\t\t\tqdrant.NewMatch(\"color\", \"red\"), \t\t\t}, \t\t}, \t), }) ``` This example removes all points with `{ \"color\": \"red\" }` from the collection.",
    "metadata": {
      "chunk_id": "b2de55f15c63-0019",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 19,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Delete points"
      ],
      "heading_text": "Delete points",
      "token_count": 898,
      "char_count": 3582,
      "start_char": 45855,
      "end_char": 49437,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.8623134328358208,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.783768",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 898,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Delete points",
      "chunk_hash": "23d2ff2e9f4911b5",
      "content_digest": "23d2ff2e9f4911b5",
      "chunk_length": 3582,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "points",
          "collection",
          "name",
          "delete",
          "filter",
          "color",
          "red",
          "100",
          "import",
          "models",
          "must",
          "deletepointsbuilder",
          "new",
          "await",
          "deleteasync",
          "localhost",
          "6334",
          "collectionname"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 29,
            "weight": 0.090062
          },
          {
            "term": "client",
            "tf": 26,
            "weight": 0.080745
          },
          {
            "term": "points",
            "tf": 19,
            "weight": 0.059006
          },
          {
            "term": "collection",
            "tf": 17,
            "weight": 0.052795
          },
          {
            "term": "name",
            "tf": 16,
            "weight": 0.049689
          },
          {
            "term": "delete",
            "tf": 12,
            "weight": 0.037267
          },
          {
            "term": "filter",
            "tf": 11,
            "weight": 0.034161
          },
          {
            "term": "color",
            "tf": 8,
            "weight": 0.024845
          },
          {
            "term": "red",
            "tf": 8,
            "weight": 0.024845
          },
          {
            "term": "100",
            "tf": 7,
            "weight": 0.021739
          },
          {
            "term": "import",
            "tf": 6,
            "weight": 0.018634
          },
          {
            "term": "models",
            "tf": 5,
            "weight": 0.015528
          },
          {
            "term": "must",
            "tf": 5,
            "weight": 0.015528
          },
          {
            "term": "deletepointsbuilder",
            "tf": 4,
            "weight": 0.012422
          },
          {
            "term": "new",
            "tf": 4,
            "weight": 0.012422
          },
          {
            "term": "await",
            "tf": 4,
            "weight": 0.012422
          },
          {
            "term": "deleteasync",
            "tf": 4,
            "weight": 0.012422
          },
          {
            "term": "localhost",
            "tf": 4,
            "weight": 0.012422
          },
          {
            "term": "6334",
            "tf": 4,
            "weight": 0.012422
          },
          {
            "term": "collectionname",
            "tf": 4,
            "weight": 0.012422
          }
        ],
        "unique_terms": 93,
        "total_terms": 322
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "100",
        "Delete points",
        "client",
        "collection",
        "color",
        "delete",
        "filter",
        "name",
        "points",
        "qdrant",
        "red"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.8623134328358208,
      "overall": 0.7874378109452737
    }
  },
  {
    "text": "## Retrieve points  There is a method for retrieving points by their ids. REST API ([Schema](https://api.qdrant.tech/api-reference/points/get-points)): ```http POST /collections/{collection_name}/points {     \"ids\": [0, 3, 100] } ``` ```python client.retrieve(     collection_name=\"{collection_name}\",     ids=[0, 3, 100], ) ``` ```typescript client.retrieve(\"{collection_name}\", {   ids: [0, 3, 100], }); ``` ```rust use qdrant_client::qdrant::GetPointsBuilder;  client     .get_points(GetPointsBuilder::new(         \"{collection_name}\",         vec![0.into(), 30.into(), 100.into()],     ))     .await?; ``` ```java import java.util.List;  import static io.qdrant.client.PointIdFactory.id;  client     .retrieveAsync(\"{collection_name}\", List.of(id(0), id(30), id(100)), false, false, null)     .get(); ``` ```csharp using Qdrant.Client;  var client = new QdrantClient(\"localhost\", 6334);  await client.RetrieveAsync( \tcollectionName: \"{collection_name}\", \tids: [0, 30, 100], \twithPayload: false, \twithVectors: false ); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{ \tHost: \"localhost\", \tPort: 6334, })  client.Get(context.Background(), &qdrant.GetPoints{ \tCollectionName: \"{collection_name}\", \tIds: []*qdrant.PointId{ \t\tqdrant.NewIDNum(0), qdrant.NewIDNum(3), qdrant.NewIDNum(100), \t}, }) ``` This method has additional parameters `with_vectors` and `with_payload`. Using these parameters, you can select parts of the point you want as a result. Excluding helps you not to waste traffic transmitting useless data. The single point can also be retrieved via the API:  REST API ([Schema](https://api.qdrant.tech/api-reference/points/get-point)): ```http GET /collections/{collection_name}/points/{point_id} ```",
    "metadata": {
      "chunk_id": "b2de55f15c63-0020",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 20,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Retrieve points"
      ],
      "heading_text": "Retrieve points",
      "token_count": 492,
      "char_count": 1784,
      "start_char": 49455,
      "end_char": 51239,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.5774245614035087,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.789280",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 492,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Retrieve points",
      "chunk_hash": "9313e634a0a897e3",
      "content_digest": "9313e634a0a897e3",
      "chunk_length": 1784,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "collection",
          "name",
          "points",
          "api",
          "100",
          "ids",
          "get",
          "false",
          "point",
          "retrieve",
          "into",
          "import",
          "newidnum",
          "you",
          "the",
          "method",
          "rest",
          "schema"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 15,
            "weight": 0.074627
          },
          {
            "term": "client",
            "tf": 12,
            "weight": 0.059701
          },
          {
            "term": "collection",
            "tf": 9,
            "weight": 0.044776
          },
          {
            "term": "name",
            "tf": 9,
            "weight": 0.044776
          },
          {
            "term": "points",
            "tf": 8,
            "weight": 0.039801
          },
          {
            "term": "api",
            "tf": 7,
            "weight": 0.034826
          },
          {
            "term": "100",
            "tf": 7,
            "weight": 0.034826
          },
          {
            "term": "ids",
            "tf": 6,
            "weight": 0.029851
          },
          {
            "term": "get",
            "tf": 6,
            "weight": 0.029851
          },
          {
            "term": "false",
            "tf": 4,
            "weight": 0.0199
          },
          {
            "term": "point",
            "tf": 4,
            "weight": 0.0199
          },
          {
            "term": "retrieve",
            "tf": 3,
            "weight": 0.014925
          },
          {
            "term": "into",
            "tf": 3,
            "weight": 0.014925
          },
          {
            "term": "import",
            "tf": 3,
            "weight": 0.014925
          },
          {
            "term": "newidnum",
            "tf": 3,
            "weight": 0.014925
          },
          {
            "term": "you",
            "tf": 3,
            "weight": 0.014925
          },
          {
            "term": "the",
            "tf": 3,
            "weight": 0.014925
          },
          {
            "term": "method",
            "tf": 2,
            "weight": 0.00995
          },
          {
            "term": "rest",
            "tf": 2,
            "weight": 0.00995
          },
          {
            "term": "schema",
            "tf": 2,
            "weight": 0.00995
          }
        ],
        "unique_terms": 91,
        "total_terms": 201
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "100",
        "Retrieve points",
        "api",
        "client",
        "collection",
        "false",
        "get",
        "ids",
        "name",
        "points",
        "qdrant"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.5774245614035087,
      "overall": 0.6924748538011696
    }
  },
  {
    "text": "## Scroll points  Sometimes it might be necessary to get all stored points without knowing ids, or iterate over points that correspond to a filter. REST API ([Schema](https://api.qdrant.tech/master/api-reference/points/scroll-points)): ```http POST /collections/{collection_name}/points/scroll {     \"filter\": {         \"must\": [             {                 \"key\": \"color\",                 \"match\": {                     \"value\": \"red\"                 }             }         ]     },     \"limit\": 1,     \"with_payload\": true,     \"with_vector\": false } ``` ```python client.scroll(     collection_name=\"{collection_name}\",     scroll_filter=models.Filter(         must=[             models.FieldCondition(key=\"color\", match=models.MatchValue(value=\"red\")),         ]     ),     limit=1,     with_payload=True,     with_vectors=False, ) ``` ```typescript client.scroll(\"{collection_name}\", {   filter: {     must: [       {         key: \"color\",         match: {           value: \"red\",         },       },     ],   },   limit: 1,   with_payload: true,   with_vector: false, }); ``` ```rust use qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};  client     .scroll(         ScrollPointsBuilder::new(\"{collection_name}\")             .filter(Filter::must([Condition::matches(                 \"color\",                 \"red\".to_string(),             )]))             .limit(1)             .with_payload(true)             .with_vectors(false),     )     .await?; ``` ```java import static io.qdrant.client.ConditionFactory.matchKeyword; import static io.qdrant.client.WithPayloadSelectorFactory.enable;  import io.qdrant.client.grpc.Points.Filter; import io.qdrant.client.grpc.Points.ScrollPoints;  client     .scrollAsync(         ScrollPoints.newBuilder()             .setCollectionName(\"{collection_name}\")             .setFilter(Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build())             .setLimit(1)             .setWithPayload(enable(true))             .build())     .get(); ``` ```csharp using Qdrant.Client; using static Qdrant.Client.Grpc.Conditions;  var client = new QdrantClient(\"localhost\", 6334);  await client.ScrollAsync( \tcollectionName: \"{collection_name}\", \tfilter: MatchKeyword(\"color\", \"red\"), \tlimit: 1, \tpayloadSelector: true ); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{ \tHost: \"localhost\", \tPort: 6334, })  client.Scroll(context.Background(), &qdrant.ScrollPoints{ \tCollectionName: \"{collection_name}\", \tFilter: &qdrant.Filter{ \t\tMust: []*qdrant.Condition{ \t\t\tqdrant.NewMatch(\"color\", \"red\"), \t\t}, \t}, \tLimit:       qdrant.PtrOf(uint32(1)), \tWithPayload: qdrant.NewWithPayload(true), }) ``` Returns all point with `color` = `red`. ```json {   \"result\": {     \"next_page_offset\": 1,     \"points\": [       {         \"id\": 0,         \"payload\": {           \"color\": \"red\"         }       }     ]   },   \"status\": \"ok\",   \"time\": 0.0001 } ``` The Scroll API will return all points that match the filter in a page-by-page manner. All resulting points are sorted by ID. To query the next page it is necessary to specify the largest seen ID in the `offset` field. For convenience, this ID is also returned in the field `next_page_offset`. If the value of the `next_page_offset` field is `null` - the last page is reached.",
    "metadata": {
      "chunk_id": "b2de55f15c63-0021",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 21,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Scroll points"
      ],
      "heading_text": "Scroll points",
      "token_count": 827,
      "char_count": 3348,
      "start_char": 51252,
      "end_char": 54600,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.7041237113402061,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.796921",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 827,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Scroll points",
      "chunk_hash": "7f9bc1dfaa654cac",
      "content_digest": "7f9bc1dfaa654cac",
      "chunk_length": 3348,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "filter",
          "points",
          "scroll",
          "color",
          "red",
          "with",
          "the",
          "collection",
          "name",
          "true",
          "page",
          "limit",
          "must",
          "payload",
          "import",
          "all",
          "api",
          "match"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 19,
            "weight": 0.059561
          },
          {
            "term": "client",
            "tf": 16,
            "weight": 0.050157
          },
          {
            "term": "filter",
            "tf": 14,
            "weight": 0.043887
          },
          {
            "term": "points",
            "tf": 11,
            "weight": 0.034483
          },
          {
            "term": "scroll",
            "tf": 9,
            "weight": 0.028213
          },
          {
            "term": "color",
            "tf": 9,
            "weight": 0.028213
          },
          {
            "term": "red",
            "tf": 9,
            "weight": 0.028213
          },
          {
            "term": "with",
            "tf": 9,
            "weight": 0.028213
          },
          {
            "term": "the",
            "tf": 9,
            "weight": 0.028213
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.025078
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.025078
          },
          {
            "term": "true",
            "tf": 7,
            "weight": 0.021944
          },
          {
            "term": "page",
            "tf": 7,
            "weight": 0.021944
          },
          {
            "term": "limit",
            "tf": 6,
            "weight": 0.018809
          },
          {
            "term": "must",
            "tf": 5,
            "weight": 0.015674
          },
          {
            "term": "payload",
            "tf": 5,
            "weight": 0.015674
          },
          {
            "term": "import",
            "tf": 5,
            "weight": 0.015674
          },
          {
            "term": "all",
            "tf": 4,
            "weight": 0.012539
          },
          {
            "term": "api",
            "tf": 4,
            "weight": 0.012539
          },
          {
            "term": "match",
            "tf": 4,
            "weight": 0.012539
          }
        ],
        "unique_terms": 126,
        "total_terms": 319
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Scroll points",
        "client",
        "collection",
        "color",
        "filter",
        "points",
        "qdrant",
        "red",
        "scroll",
        "the",
        "with"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.7041237113402061,
      "overall": 0.768041237113402
    }
  },
  {
    "text": "### Order points by payload key  *Available as of v1.8.0*  When using the [`scroll`](#scroll-points.md) API, you can sort the results by payload key. For example, you can retrieve points in chronological order if your payloads have a `\"timestamp\"` field, as is shown from the example below:  Without an appropriate index, payload-based ordering would create too much load on the system for each request. Qdrant therefore requires a payload index which supports [Range filtering conditions](https://qdrant.tech/documentation/concepts/indexing/#payload-index) on the field used for `order_by` ```http POST /collections/{collection_name}/points/scroll {     \"limit\": 15,     \"order_by\": \"timestamp\", // <-- this! } ``` ```python client.scroll(     collection_name=\"{collection_name}\",     limit=15,     order_by=\"timestamp\", # <-- this! ) ``` ```typescript client.scroll(\"{collection_name}\", {   limit: 15,   order_by: \"timestamp\", // <-- this! }); ``` ```rust use qdrant_client::qdrant::{OrderByBuilder, ScrollPointsBuilder};  client     .scroll(         ScrollPointsBuilder::new(\"{collection_name}\")             .limit(15)             .order_by(OrderByBuilder::new(\"timestamp\")),     )     .await?; ``` ```java import io.qdrant.client.grpc.Points.OrderBy; import io.qdrant.client.grpc.Points.ScrollPoints;  client.scrollAsync(ScrollPoints.newBuilder()   .setCollectionName(\"{collection_name}\")   .setLimit(15)   .setOrderBy(OrderBy.newBuilder().setKey(\"timestamp\").build())   .build()).get(); ``` ```csharp await client.ScrollAsync(\"{collection_name}\", limit: 15, orderBy: \"timestamp\"); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{ \tHost: \"localhost\", \tPort: 6334, })  client.Scroll(context.Background(), &qdrant.ScrollPoints{ \tCollectionName: \"{collection_name}\", \tLimit:          qdrant.PtrOf(uint32(15)), \tOrderBy: &qdrant.OrderBy{ \t\tKey: \"timestamp\", \t}, }) ``` You need to use the `order_by` `key` parameter to specify the payload key. Then you can add other fields to control the ordering, such as `direction` and `start_from`: ```http \"order_by\": {     \"key\": \"timestamp\",     \"direction\": \"desc\" // default is \"asc\"     \"start_from\": 123, // start from this value } ``` ```python order_by=models.OrderBy(     key=\"timestamp\",     direction=\"desc\",  # default is \"asc\"     start_from=123,  # start from this value ) ``` ```typescript order_by: {     key: \"timestamp\",     direction: \"desc\", // default is \"asc\"     start_from: 123, // start from this value } ``` ```rust use qdrant_client::qdrant::{start_from::Value, Direction, OrderByBuilder};  OrderByBuilder::new(\"timestamp\")     .direction(Direction::Desc.into())     .start_from(Value::Integer(123))     .build(); ``` ```java import io.qdrant.client.grpc.Points.Direction; import io.qdrant.client.grpc.Points.OrderBy; import io.qdrant.client.grpc.Points.StartFrom;  OrderBy.newBuilder()   .setKey(\"timestamp\")   .setDirection(Direction.Desc)   .setStartFrom(StartFrom.newBuilder()     .setInteger(123)     .build())   .build(); ``` ```csharp using Qdrant.Client.Grpc;  new OrderBy {  Key = \"timestamp\",  Direction = Direction.Desc,  StartFrom = 123 }; ``` ```go import \"github.com/qdrant/go-client/qdrant\"  qdrant.OrderBy{ \tKey:       \"timestamp\", \tDirection: qdrant.Direction_Desc.Enum(), \tStartFrom: qdrant.NewStartFromInt(123), } ``` When you use the `order_by` parameter, pagination is disabled. When sorting is based on a non-unique value, it is not possible to rely on an ID offset. Thus, next\\_page\\_offset is not returned within the response. However, you can still do pagination by combining `\"order_by\": { \"start_from\": ... }` with a `{ \"must_not\": [{ \"has_id\": [...] }] }` filter.",
    "metadata": {
      "chunk_id": "b2de55f15c63-0022",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 22,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Order points by payload key"
      ],
      "heading_text": "Order points by payload key",
      "token_count": 954,
      "char_count": 3728,
      "start_char": 54614,
      "end_char": 58342,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.884054054054054,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.806653",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 954,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Order points by payload key",
      "chunk_hash": "eb4f5c664cd228a0",
      "content_digest": "eb4f5c664cd228a0",
      "chunk_length": 3728,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "timestamp",
          "order",
          "direction",
          "from",
          "key",
          "the",
          "orderby",
          "start",
          "points",
          "collection",
          "name",
          "scroll",
          "import",
          "desc",
          "123",
          "payload",
          "you",
          "limit"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 24,
            "weight": 0.05985
          },
          {
            "term": "client",
            "tf": 17,
            "weight": 0.042394
          },
          {
            "term": "timestamp",
            "tf": 15,
            "weight": 0.037406
          },
          {
            "term": "order",
            "tf": 13,
            "weight": 0.032419
          },
          {
            "term": "direction",
            "tf": 13,
            "weight": 0.032419
          },
          {
            "term": "from",
            "tf": 11,
            "weight": 0.027431
          },
          {
            "term": "key",
            "tf": 10,
            "weight": 0.024938
          },
          {
            "term": "the",
            "tf": 10,
            "weight": 0.024938
          },
          {
            "term": "orderby",
            "tf": 10,
            "weight": 0.024938
          },
          {
            "term": "start",
            "tf": 10,
            "weight": 0.024938
          },
          {
            "term": "points",
            "tf": 9,
            "weight": 0.022444
          },
          {
            "term": "collection",
            "tf": 8,
            "weight": 0.01995
          },
          {
            "term": "name",
            "tf": 8,
            "weight": 0.01995
          },
          {
            "term": "scroll",
            "tf": 7,
            "weight": 0.017456
          },
          {
            "term": "import",
            "tf": 7,
            "weight": 0.017456
          },
          {
            "term": "desc",
            "tf": 7,
            "weight": 0.017456
          },
          {
            "term": "123",
            "tf": 7,
            "weight": 0.017456
          },
          {
            "term": "payload",
            "tf": 6,
            "weight": 0.014963
          },
          {
            "term": "you",
            "tf": 6,
            "weight": 0.014963
          },
          {
            "term": "limit",
            "tf": 6,
            "weight": 0.014963
          }
        ],
        "unique_terms": 145,
        "total_terms": 401
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Order points by payload key",
        "client",
        "direction",
        "from",
        "key",
        "order",
        "orderby",
        "qdrant",
        "start",
        "the",
        "timestamp"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.884054054054054,
      "overall": 0.7946846846846847
    }
  },
  {
    "text": "## Counting points  *Available as of v0.8.4*  Sometimes it can be useful to know how many points fit the filter conditions without doing a real search. Among others, for example, we can highlight the following scenarios:  - Evaluation of results size for faceted search - Determining the number of pages for pagination - Debugging the query execution speed  REST API ([Schema](https://api.qdrant.tech/master/api-reference/points/count-points)): ```http POST /collections/{collection_name}/points/count {     \"filter\": {         \"must\": [             {                 \"key\": \"color\",                 \"match\": {                     \"value\": \"red\"                 }             }         ]     },     \"exact\": true } ``` ```python client.count(     collection_name=\"{collection_name}\",     count_filter=models.Filter(         must=[             models.FieldCondition(key=\"color\", match=models.MatchValue(value=\"red\")),         ]     ),     exact=True, ) ``` ```typescript client.count(\"{collection_name}\", {   filter: {     must: [       {         key: \"color\",         match: {           value: \"red\",         },       },     ],   },   exact: true, }); ``` ```rust use qdrant_client::qdrant::{Condition, CountPointsBuilder, Filter};  client     .count(         CountPointsBuilder::new(\"{collection_name}\")             .filter(Filter::must([Condition::matches(                 \"color\",                 \"red\".to_string(),             )]))             .exact(true),     )     .await?; ``` ```java import static io.qdrant.client.ConditionFactory.matchKeyword;  import io.qdrant.client.grpc.Points.Filter;  client     .countAsync(         \"{collection_name}\",         Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build(),         true)     .get(); ``` ```csharp using Qdrant.Client; using static Qdrant.Client.Grpc.Conditions;  var client = new QdrantClient(\"localhost\", 6334);  await client.CountAsync( \tcollectionName: \"{collection_name}\", \tfilter: MatchKeyword(\"color\", \"red\"), \texact: true ); ``` ```go import ( \t\"context\"  \t\"github.com/qdrant/go-client/qdrant\" )  client, err := qdrant.NewClient(&qdrant.Config{ \tHost: \"localhost\", \tPort: 6334, })  client.Count(context.Background(), &qdrant.CountPoints{ \tCollectionName: \"midlib\", \tFilter: &qdrant.Filter{ \t\tMust: []*qdrant.Condition{ \t\t\tqdrant.NewMatch(\"color\", \"red\"), \t\t}, \t}, }) ``` Returns number of counts matching given filtering conditions: ```json {   \"count\": 3811 } ```",
    "metadata": {
      "chunk_id": "b2de55f15c63-0023",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 23,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Counting points"
      ],
      "heading_text": "Counting points",
      "token_count": 591,
      "char_count": 2443,
      "start_char": 58361,
      "end_char": 60804,
      "semantic_score": 0.7,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.9200934579439253,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.812517",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 591,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Counting points",
      "chunk_hash": "870fe52ee570f1c8",
      "content_digest": "870fe52ee570f1c8",
      "chunk_length": 2443,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "qdrant",
          "client",
          "filter",
          "count",
          "collection",
          "name",
          "color",
          "red",
          "points",
          "true",
          "must",
          "exact",
          "the",
          "conditions",
          "for",
          "api",
          "key",
          "match",
          "value",
          "models"
        ],
        "term_weights": [
          {
            "term": "qdrant",
            "tf": 15,
            "weight": 0.064103
          },
          {
            "term": "client",
            "tf": 14,
            "weight": 0.059829
          },
          {
            "term": "filter",
            "tf": 13,
            "weight": 0.055556
          },
          {
            "term": "count",
            "tf": 8,
            "weight": 0.034188
          },
          {
            "term": "collection",
            "tf": 7,
            "weight": 0.029915
          },
          {
            "term": "name",
            "tf": 7,
            "weight": 0.029915
          },
          {
            "term": "color",
            "tf": 7,
            "weight": 0.029915
          },
          {
            "term": "red",
            "tf": 7,
            "weight": 0.029915
          },
          {
            "term": "points",
            "tf": 6,
            "weight": 0.025641
          },
          {
            "term": "true",
            "tf": 6,
            "weight": 0.025641
          },
          {
            "term": "must",
            "tf": 5,
            "weight": 0.021368
          },
          {
            "term": "exact",
            "tf": 5,
            "weight": 0.021368
          },
          {
            "term": "the",
            "tf": 4,
            "weight": 0.017094
          },
          {
            "term": "conditions",
            "tf": 3,
            "weight": 0.012821
          },
          {
            "term": "for",
            "tf": 3,
            "weight": 0.012821
          },
          {
            "term": "api",
            "tf": 3,
            "weight": 0.012821
          },
          {
            "term": "key",
            "tf": 3,
            "weight": 0.012821
          },
          {
            "term": "match",
            "tf": 3,
            "weight": 0.012821
          },
          {
            "term": "value",
            "tf": 3,
            "weight": 0.012821
          },
          {
            "term": "models",
            "tf": 3,
            "weight": 0.012821
          }
        ],
        "unique_terms": 109,
        "total_terms": 234
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Counting points",
        "client",
        "collection",
        "color",
        "count",
        "filter",
        "name",
        "points",
        "qdrant",
        "red",
        "true"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.7,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.9200934579439253,
      "overall": 0.840031152647975
    }
  },
  {
    "text": "## Batch update  *Available as of v1.5.0*  You can batch multiple point update operations. This includes inserting, updating and deleting points, vectors and payload. A batch update request consists of a list of operations. These are executed in order. These operations can be batched:  - [Upsert points](#upload-points.md): `upsert` or `UpsertOperation` - [Delete points](#delete-points.md): `delete_points` or `DeleteOperation` - [Update vectors](#update-vectors.md): `update_vectors` or `UpdateVectorsOperation` - [Delete vectors](#delete-vectors.md): `delete_vectors` or `DeleteVectorsOperation` - [Set payload](https://qdrant.tech/documentation/concepts/payload/#set-payload): `set_payload` or `SetPayloadOperation` - [Overwrite payload](https://qdrant.tech/documentation/concepts/payload/#overwrite-payload): `overwrite_payload` or `OverwritePayload` - [Delete payload](https://qdrant.tech/documentation/concepts/payload/#delete-payload-keys): `delete_payload` or `DeletePayloadOperation` - [Clear payload](https://qdrant.tech/documentation/concepts/payload/#clear-payload): `clear_payload` or `ClearPayloadOperation`  The following example snippet makes use of all operations. REST API ([Schema](https://api.qdrant.tech/master/api-reference/points/batch-update)): ```http POST /collections/{collection_name}/points/batch {     \"operations\": [         {             \"upsert\": {                 \"points\": [                     {                         \"id\": 1,                         \"vector\": [1.0, 2.0, 3.0, 4.0],                         \"payload\": {}                     }                 ]             }         },         {             \"update_vectors\": {                 \"points\": [                     {                         \"id\": 1,                         \"vector\": [1.0, 2.0, 3.0, 4.0]                     }                 ]             }         },         {             \"delete_vectors\": {                 \"points\": [1],                 \"vector\": [\"\"]             }         },         {             \"overwrite_payload\": {                 \"payload\": {                     \"test_payload\": \"1\"                 },                 \"points\": [1]             }         },         {             \"set_payload\": {                 \"payload\": {                     \"test_payload_2\": \"2\",                     \"test_payload_3\": \"3\"                 },                 \"points\": [1]             }         },         {             \"delete_payload\": {                 \"keys\": [\"test_payload_2\"],                 \"points\": [1]             }         },         {             \"clear_payload\": {                 \"points\": [1]             }         },         {\"delete\": {\"points\": [1]}}     ] } ``` ```python client.batch_update_points(     collection_name=\"{collection_name}\",     update_operations=[         models.UpsertOperation(             upsert=models.PointsList(                 points=[                     models.PointStruct(                         id=1,                         vector=[1.0, 2.0, 3.0, 4.0],                         payload={},                     ),                 ]             )         ),         models.UpdateVectorsOperation(             update_vectors=models.UpdateVectors(                 points=[                     models.PointVectors(                         id=1,                         vector=[1.0, 2.0, 3.0, 4.0],                     )                 ]             )         ),         models.DeleteVectorsOperation(             delete_vectors=models.DeleteVectors(points=[1], vector=[\"\"])         ),         models.OverwritePayloadOperation(             overwrite_payload=models.SetPayload(                 payload={\"test_payload\": 1},                 points=[1],             )         ),         models.SetPayloadOperation(             set_payload=models.SetPayload(                 payload={                     \"test_payload_2\": 2,                     \"test_payload_3\": 3,                 },                 points=[1],             )         ),         models.DeletePayloadOperation(             delete_payload=models.DeletePayload(keys=[\"test_payload_2\"], points=[1])         ),         models.ClearPayloadOperation(clear_payload=models.PointIdsList(points=[1])),         models.DeleteOperation(delete=models.PointIdsList(points=[1])),     ], ) ``` ```typescript client.batchUpdate(\"{collection_name}\", {   operations: [     {       upsert: {         points: [           {             id: 1,             vector: [1.0, 2.0, 3.0, 4.0],             payload: {},           },         ],       },     },     {       update_vectors: {         points: [           {             id: 1,             vector: [1.0, 2.0, 3.0, 4.0],           },         ],       },     },     {       delete_vectors: {         points: [1],         vector: [\"\"],       },     },     {       overwrite_payload: {         payload: {           test_payload: 1,         },         points: [1],       },     },     {       set_payload: {         payload: {           test_payload_2: 2,           test_payload_3: 3,         },         points: [1],       },     },     {       delete_payload: {         keys: [\"test_payload_2\"],         points: [1],       },     },     {       clear_payload: {         points: [1],       },     },     {       delete: {         points: [1],       },     },   ], }); ``` ```rust use std::collections::HashMap;  use qdrant_client::qdrant::{     points_update_operation::{         ClearPayload, DeletePayload, DeletePoints, DeleteVectors, Operation, OverwritePayload,         PointStructList, SetPayload, UpdateVectors,     },     PointStruct, PointVectors, PointsUpdateOperation, UpdateBatchPointsBuilder, VectorsSelector, }; use qdrant_client::Payload;  client     .update_points_batch(         UpdateBatchPointsBuilder::new(             \"{collection_name}\",             vec![                 PointsUpdateOperation {                     operation: Some(Operation::Upsert(PointStructList {                         points: vec![PointStruct::new(                             1,                             vec![1.0, 2.0, 3.0, 4.0],                             Payload::default(),                         )],                         ..Default::default()                     })),                 },                 PointsUpdateOperation {                     operation: Some(Operation::UpdateVectors(UpdateVectors {                         points: vec![PointVectors {                             id: Some(1.into()),                             vectors: Some(vec![1.0, 2.0, 3.0, 4.0].into()),                         }],                         ..Default::default()                     })),                 },                 PointsUpdateOperation {                     operation: Some(Operation::DeleteVectors(DeleteVectors {                         points_selector: Some(vec![1.into()].into()),                         vectors: Some(VectorsSelector {                             names: vec![\"\".into()],                         }),                         ..Default::default()                     })),                 },                 PointsUpdateOperation {                     operation: Some(Operation::OverwritePayload(OverwritePayload {                         points_selector: Some(vec![1.into()].into()),                         payload: HashMap::from([(\"test_payload\".to_string(), 1.into())]),                         ..Default::default()                     })),                 },                 PointsUpdateOperation {                     operation: Some(Operation::SetPayload(SetPayload {                         points_selector: Some(vec![1.into()].into()),                         payload: HashMap::from([                             (\"test_payload_2\".to_string(), 2.into()),                             (\"test_payload_3\".to_string(), 3.into()),                         ]),                         ..Default::default()                     })),                 },                 PointsUpdateOperation {                     operation: Some(Operation::DeletePayload(DeletePayload {                         points_selector: Some(vec![1.into()].into()),                         keys: vec![\"test_payload_2\".to_string()],                         ..Default::default()                     })),                 },                 PointsUpdateOperation {                     operation: Some(Operation::ClearPayload(ClearPayload {                         points: Some(vec![1.into()].into()),                         ..Default::default()                     })),                 },                 PointsUpdateOperation {                     operation: Some(Operation::DeletePoints(DeletePoints {                         points: Some(vec![1.into()].into()),                         ..Default::default()                     })),                 },             ],         )         .wait(true),     )     .await?; ``` ```java import java.util.List; import java.util.Map;  import static io.qdrant.client.PointIdFactory.id; import static io.qdrant.client.ValueFactory.value; import static io.qdrant.client.VectorsFactory.vectors;  import io.qdrant.client.grpc.Points.PointStruct; import io.qdrant.client.grpc.Points.PointVectors; import io.qdrant.client.grpc.Points.PointsIdsList; import io.qdrant.client.grpc.Points.PointsSelector; import io.qdrant.client.grpc.Points.PointsUpdateOperation; import io.qdrant.client.grpc.Points.PointsUpdateOperation.ClearPayload; import io.qdrant.client.grpc.Points.PointsUpdateOperation.DeletePayload; import io.qdrant.client.grpc.Points.PointsUpdateOperation.DeletePoints; import io.qdrant.client.grpc.Points.PointsUpdateOperation.DeleteVectors; import io.qdrant.client.grpc.Points.PointsUpdateOperation.PointStructList; import io.qdrant.client.grpc.Points.PointsUpdateOperation.SetPayload; import io.qdrant.client.grpc.Points.PointsUpdateOperation.UpdateVectors; import io.qdrant.client.grpc.Points.VectorsSelector;  client     .batchUpdateAsync(         \"{collection_name}\",         List.of(             PointsUpdateOperation.newBuilder()                 .setUpsert(                     PointStructList.newBuilder()                         .addPoints(                             PointStruct.newBuilder()                                 .setId(id(1))                                 .setVectors(vectors(1.0f, 2.0f, 3.0f, 4.0f))                                 .build())                         .build())                 .build(),             PointsUpdateOperation.newBuilder()                 .setUpdateVectors(                     UpdateVectors.newBuilder()                         .addPoints(                             PointVectors.newBuilder()                                 .setId(id(1))                                 .setVectors(vectors(1.0f, 2.0f, 3.0f, 4.0f))                                 .build())                         .build())                 .build(),             PointsUpdateOperation.newBuilder()                 .setDeleteVectors(                     DeleteVectors.newBuilder()                         .setPointsSelector(                             PointsSelector.newBuilder()                                 .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())                                 .build())                         .setVectors(VectorsSelector.newBuilder().addNames(\"\").build())                         .build())                 .build(),             PointsUpdateOperation.newBuilder()                 .setOverwritePayload(                     SetPayload.newBuilder()                         .setPointsSelector(                             PointsSelector.newBuilder()                                 .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())                                 .build())                         .putAllPayload(Map.of(\"test_payload\", value(1)))                         .build())                 .build(),             PointsUpdateOperation.newBuilder()                 .setSetPayload(                     SetPayload.newBuilder()                         .setPointsSelector(                             PointsSelector.newBuilder()                                 .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())                                 .build())                         .putAllPayload(                             Map.of(\"test_payload_2\", value(2), \"test_payload_3\", value(3)))                         .build())                 .build(),             PointsUpdateOperation.newBuilder()                 .setDeletePayload(                     DeletePayload.newBuilder()                         .setPointsSelector(                             PointsSelector.newBuilder()                                 .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())                                 .build())                         .addKeys(\"test_payload_2\")                         .build())                 .build(),             PointsUpdateOperation.newBuilder()                 .setClearPayload(                     ClearPayload.newBuilder()                         .setPoints(                             PointsSelector.newBuilder()                                 .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())                                 .build())                         .build())                 .build(),             PointsUpdateOperation.newBuilder()                 .setDeletePoints(                     DeletePoints.newBuilder()                         .setPoints(                             PointsSelector.newBuilder()                                 .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())                                 .build())                         .build())                 .build()))     .get(); ``` To batch many points with a single operation type, please use batching functionality in that operation directly.",
    "metadata": {
      "chunk_id": "b2de55f15c63-0024",
      "source_file": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "filename": "_documentation_concepts_points_.md",
      "file_extension": ".md",
      "chunk_index": 24,
      "document_level": 1,
      "parent_chunk_id": null,
      "child_chunk_ids": [],
      "section_path": [
        "Batch update"
      ],
      "heading_text": "Batch update",
      "token_count": 2598,
      "char_count": 13846,
      "start_char": 60816,
      "end_char": 74662,
      "semantic_score": 0.6,
      "structural_score": 0.8999999999999999,
      "retrieval_quality": 0.6310179640718562,
      "chunking_strategy": "hybrid_adaptive_structural",
      "content_type": "code_block",
      "embedding_model": "jina-code-embeddings-1.5b",
      "embedding_dimension": 1536,
      "processing_timestamp": "2025-10-20T16:07:18.833433",
      "model_aware_chunking": true,
      "within_token_limit": true,
      "estimated_tokens": 2598,
      "document_id": "b2de55f15c63",
      "document_name": "_documentation_concepts_points_",
      "source_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "source_filename": "_documentation_concepts_points_.md",
      "source_directory": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points",
      "relative_path": "Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
      "hierarchy_path": "Batch update",
      "chunk_hash": "79c477ff084f3f63",
      "content_digest": "79c477ff084f3f63",
      "chunk_length": 13846,
      "payload_version": "1.3",
      "collection_hints": [
        "qdrant"
      ],
      "target_model": "jina-code-embeddings-1.5b",
      "chunker_version": "v5_unified",
      "chunk_size_tokens": 26214,
      "chunk_overlap_tokens": 2621,
      "chunk_size_chars": 104856,
      "chunk_overlap_chars": 10484,
      "safety_margin": 0.8,
      "model_hf_id": "jinaai/jina-code-embeddings-1.5b",
      "model_max_tokens": 32768,
      "model_vector_dim": 1536,
      "matryoshka_dimension": 1536,
      "recommended_batch_size": 16,
      "backend": "pytorch",
      "memory_efficient": true,
      "query_prefix": "Encode this code snippet for semantic retrieval: ",
      "sparse_features": {
        "version": "1.0",
        "weighting": "tf-normalized",
        "top_terms": [
          "payload",
          "points",
          "newbuilder",
          "build",
          "pointsupdateoperation",
          "qdrant",
          "client",
          "test",
          "operation",
          "vectors",
          "delete",
          "models",
          "into",
          "import",
          "some",
          "default",
          "update",
          "vec",
          "grpc",
          "vector"
        ],
        "term_weights": [
          {
            "term": "payload",
            "tf": 62,
            "weight": 0.080729
          },
          {
            "term": "points",
            "tf": 57,
            "weight": 0.074219
          },
          {
            "term": "newbuilder",
            "tf": 31,
            "weight": 0.040365
          },
          {
            "term": "build",
            "tf": 31,
            "weight": 0.040365
          },
          {
            "term": "pointsupdateoperation",
            "tf": 25,
            "weight": 0.032552
          },
          {
            "term": "qdrant",
            "tf": 24,
            "weight": 0.03125
          },
          {
            "term": "client",
            "tf": 22,
            "weight": 0.028646
          },
          {
            "term": "test",
            "tf": 20,
            "weight": 0.026042
          },
          {
            "term": "operation",
            "tf": 20,
            "weight": 0.026042
          },
          {
            "term": "vectors",
            "tf": 18,
            "weight": 0.023438
          },
          {
            "term": "delete",
            "tf": 18,
            "weight": 0.023438
          },
          {
            "term": "models",
            "tf": 18,
            "weight": 0.023438
          },
          {
            "term": "into",
            "tf": 18,
            "weight": 0.023438
          },
          {
            "term": "import",
            "tf": 18,
            "weight": 0.023438
          },
          {
            "term": "some",
            "tf": 17,
            "weight": 0.022135
          },
          {
            "term": "default",
            "tf": 17,
            "weight": 0.022135
          },
          {
            "term": "update",
            "tf": 14,
            "weight": 0.018229
          },
          {
            "term": "vec",
            "tf": 13,
            "weight": 0.016927
          },
          {
            "term": "grpc",
            "tf": 13,
            "weight": 0.016927
          },
          {
            "term": "vector",
            "tf": 9,
            "weight": 0.011719
          }
        ],
        "unique_terms": 142,
        "total_terms": 768
      },
      "modal_hint": "code",
      "content_flags": {
        "has_code_block": true,
        "has_table": false,
        "has_list": false,
        "has_json": false,
        "has_formula": false
      },
      "search_keywords": [
        "Batch update",
        "build",
        "client",
        "newbuilder",
        "operation",
        "payload",
        "points",
        "pointsupdateoperation",
        "qdrant",
        "test",
        "vectors"
      ],
      "collection_name": "Qdrant"
    },
    "advanced_scores": {
      "semantic": 0.6,
      "structural": 0.8999999999999999,
      "retrieval_quality": 0.6310179640718562,
      "overall": 0.7103393213572854
    }
  }
]