[
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:0",
    "content": "Payload - Qdrant\n\n[](https://qdrant.tech/)\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\nSearch\n\n[Log in](https://cloud.qdrant.io/login) [Start Free](https://cloud.qdrant.io/signup)\n\nSearch\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 0,
      "token_count": 275,
      "char_count": 1004,
      "start_char": 0,
      "end_char": 1004
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:1",
    "content": "tart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 1,
      "token_count": 256,
      "char_count": 1014,
      "start_char": 904,
      "end_char": 1920
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:2",
    "content": "mentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 2,
      "token_count": 253,
      "char_count": 1023,
      "start_char": 1820,
      "end_char": 2844
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:3",
    "content": "cumentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 3,
      "token_count": 255,
      "char_count": 992,
      "start_char": 2744,
      "end_char": 3736
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:4",
    "content": "(https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 4,
      "token_count": 242,
      "char_count": 1001,
      "start_char": 3636,
      "end_char": 4638
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:5",
    "content": "- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 5,
      "token_count": 229,
      "char_count": 1011,
      "start_char": 4538,
      "end_char": 5550
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:6",
    "content": "sync-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 6,
      "token_count": 261,
      "char_count": 1016,
      "start_char": 5450,
      "end_char": 6466
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:7",
    "content": "ser Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 7,
      "token_count": 252,
      "char_count": 1020,
      "start_char": 6366,
      "end_char": 7387
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:8",
    "content": "ion/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 8,
      "token_count": 250,
      "char_count": 1001,
      "start_char": 7287,
      "end_char": 8288
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:9",
    "content": "ics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 9,
      "token_count": 261,
      "char_count": 1012,
      "start_char": 8188,
      "end_char": 9201
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:10",
    "content": "/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 10,
      "token_count": 235,
      "char_count": 1006,
      "start_char": 9101,
      "end_char": 10108
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:11",
    "content": "aborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 11,
      "token_count": 231,
      "char_count": 1004,
      "start_char": 10008,
      "end_char": 11014
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:12",
    "content": "attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n- [Documentation](https://qdrant.tech/documentation/)\n-\n- [Concepts](https://qdrant.tech/documentation/concepts/)\n-\n- Payload\n\n# Payload\n\nOne of the significant features of Qdrant is the ability to store additional information along with vectors. This information is called `payload` in Qdrant terminology.\n\nQdrant allows you to store any information that can be represented using JSON.\n\nHere is an example of a typical payload:\n\n```json\n{\n    \"name\": \"jacket\",\n    \"colors\": [\"red\", \"blue\"],\n    \"count\": 10,\n    \"price\": 11.99,\n    \"locations\": [\n        {\n            \"lon\": 52.5200, \n            \"lat\": 13.4050\n        }",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 12,
      "token_count": 272,
      "char_count": 1023,
      "start_char": 10914,
      "end_char": 11939
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:13",
    "content": ".99,\n    \"locations\": [\n        {\n            \"lon\": 52.5200, \n            \"lat\": 13.4050\n        }\n    ],\n    \"reviews\": [\n        {\n            \"user\": \"alice\",\n            \"score\": 4\n        },\n        {\n            \"user\": \"bob\",\n            \"score\": 5\n        }\n    ]\n}\n```\n\n## Payload types\n\nIn addition to storing payloads, Qdrant also allows you search based on certain kinds of values. This feature is implemented as additional filters during the search and will enable you to incorporate custom logic on top of semantic similarity.\n\nDuring the filtering, Qdrant will check the conditions over those values that match the type of the filtering condition. If the stored value type does not fit the filtering condition - it will be considered not satisfied.\n\nFor example, you will get an empty output if you apply the [range condition](https://qdrant.tech/documentation/concepts/filtering/#range) on the string data.\n\nHowever, arrays (multiple values of the same type) are treated a little bit different.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 13,
      "token_count": 232,
      "char_count": 1011,
      "start_char": 11839,
      "end_char": 12850
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:14",
    "content": "string data.\n\nHowever, arrays (multiple values of the same type) are treated a little bit different. When we apply a filter to an array, it will succeed if at least one of the values inside the array meets the condition.\n\nThe filtering process is discussed in detail in the section [Filtering](https://qdrant.tech/documentation/concepts/filtering/).\n\nLet’s look at the data types that Qdrant supports for searching:\n\n### Integer\n\n`integer` - 64-bit integer in the range from `-9223372036854775808` to `9223372036854775807`.\n\nExample of single and multiple `integer` values:\n\n```json\n{\n    \"count\": 10,\n    \"sizes\": [35, 36, 38]\n}\n```\n\n### Float\n\n`float` - 64-bit floating point number.\n\nExample of single and multiple `float` values:\n\n```json\n{\n    \"price\": 11.99,\n    \"ratings\": [9.1, 9.2, 9.4]\n}\n```\n\n### Bool\n\nBool - binary value. Equals to `true` or `false`.\n\nExample of single and multiple `bool` values:\n\n```json\n{\n    \"is_delivered\": true,\n    \"responses\": [false, false, true, false]\n}\n```\n\n### Keyword",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 14,
      "token_count": 309,
      "char_count": 1010,
      "start_char": 12750,
      "end_char": 13762
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:15",
    "content": "``json\n{\n    \"is_delivered\": true,\n    \"responses\": [false, false, true, false]\n}\n```\n\n### Keyword\n\n`keyword` - string value.\n\nExample of single and multiple `keyword` values:\n\n```json\n{\n    \"name\": \"Alice\",\n    \"friends\": [\n        \"bob\",\n        \"eva\",\n        \"jack\"\n    ]\n}\n```\n\n### Geo\n\n`geo` is used to represent geographical coordinates.\n\nExample of single and multiple `geo` values:\n\n```json\n{\n    \"location\": {\n        \"lon\": 52.5200,\n        \"lat\": 13.4050\n    },\n    \"cities\": [\n        {\n            \"lon\": 51.5072,\n            \"lat\": 0.1276\n        },\n        {\n            \"lon\": 40.7128,\n            \"lat\": 74.0060\n        }\n    ]\n}\n```\n\nCoordinate should be described as an object containing two fields: `lon` - for longitude, and `lat` - for latitude.\n\n### Datetime\n\n*Available as of v1.8.0*\n\n`datetime` - date and time in [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6) format.\n\nSee the following examples of single and multiple `datetime` values:\n\n```json\n{",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 15,
      "token_count": 308,
      "char_count": 998,
      "start_char": 13662,
      "end_char": 14661
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:16",
    "content": "ction-5.6) format.\n\nSee the following examples of single and multiple `datetime` values:\n\n```json\n{\n    \"created_at\": \"2023-02-08T10:49:00Z\",\n    \"updated_at\": [\n        \"2023-02-08T13:52:00Z\",\n        \"2023-02-21T21:23:00Z\"\n    ]\n}\n```\n\nThe following formats are supported:\n\n- `\"2023-02-08T10:49:00Z\"` ([RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6), UTC)\n- `\"2023-02-08T11:49:00+01:00\"` ([RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339#section-5.6), with timezone)\n- `\"2023-02-08T10:49:00\"` (without timezone, UTC is assumed)\n- `\"2023-02-08T10:49\"` (without timezone and seconds)\n- `\"2023-02-08\"` (only date, midnight is assumed)\n\nNotes about the format:\n\n- `T` can be replaced with a space.\n- The `T` and `Z` symbols are case-insensitive.\n- UTC is always assumed when the timezone is not specified.\n- Timezone can have the following formats: `±HH:MM`, `±HHMM`, `±HH`, or `Z`.\n- Seconds can have up to 6 decimals, so the finest granularity for `datetime` is microseconds.\n\n### UUID",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 16,
      "token_count": 402,
      "char_count": 1015,
      "start_char": 14561,
      "end_char": 15578
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:17",
    "content": "nds can have up to 6 decimals, so the finest granularity for `datetime` is microseconds.\n\n### UUID\n\n*Available as of v1.11.0*\n\nIn addition to the basic `keyword` type, Qdrant supports `uuid` type for storing UUID values. Functionally, it works the same as `keyword`, internally stores parsed UUID values.\n\n```json\n{\n    \"uuid\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"uuids\": [\n        \"550e8400-e29b-41d4-a716-446655440000\",\n        \"550e8400-e29b-41d4-a716-446655440001\"\n    ]\n}\n```\n\nString representation of UUID (e.g. `550e8400-e29b-41d4-a716-446655440000`) occupies 36 bytes. But when numeric representation is used, it is only 128 bits (16 bytes).\n\nUsage of `uuid` index type is recommended in payload-heavy collections to save RAM and improve search performance.\n\n## Create point with payload\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/upsert-points))\n\n```http\nPUT /collections/{collection_name}/points\n{\n    \"points\": [\n        {\n            \"id\": 1,\n            \"vector\": [0.05, 0.61, 0.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 17,
      "token_count": 367,
      "char_count": 1023,
      "start_char": 15478,
      "end_char": 16501
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:18",
    "content": "_name}/points\n{\n    \"points\": [\n        {\n            \"id\": 1,\n            \"vector\": [0.05, 0.61, 0.76, 0.74],\n            \"payload\": {\"city\": \"Berlin\", \"price\": 1.99}\n        },\n        {\n            \"id\": 2,\n            \"vector\": [0.19, 0.81, 0.75, 0.11],\n            \"payload\": {\"city\": [\"Berlin\", \"London\"], \"price\": 1.99}\n        },\n        {\n            \"id\": 3,\n            \"vector\": [0.36, 0.55, 0.47, 0.94],\n            \"payload\": {\"city\": [\"Berlin\", \"Moscow\"], \"price\": [1.99, 2.99]}\n        }\n    ]\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.upsert(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointStruct(\n            id=1,\n            vector=[0.05, 0.61, 0.76, 0.74],\n            payload={\n                \"city\": \"Berlin\",\n                \"price\": 1.99,\n            },\n        ),\n        models.PointStruct(\n            id=2,\n            vector=[0.19, 0.81, 0.75, 0.11],\n            payload={",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 18,
      "token_count": 348,
      "char_count": 1012,
      "start_char": 16401,
      "end_char": 17414
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:19",
    "content": "s.PointStruct(\n            id=2,\n            vector=[0.19, 0.81, 0.75, 0.11],\n            payload={\n                \"city\": [\"Berlin\", \"London\"],\n                \"price\": 1.99,\n            },\n        ),\n        models.PointStruct(\n            id=3,\n            vector=[0.36, 0.55, 0.47, 0.94],\n            payload={\n                \"city\": [\"Berlin\", \"Moscow\"],\n                \"price\": [1.99, 2.99],\n            },\n        ),\n    ],\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.upsert(\"{collection_name}\", {\n  points: [\n    {\n      id: 1,\n      vector: [0.05, 0.61, 0.76, 0.74],\n      payload: {\n        city: \"Berlin\",\n        price: 1.99,\n      },\n    },\n    {\n      id: 2,\n      vector: [0.19, 0.81, 0.75, 0.11],\n      payload: {\n        city: [\"Berlin\", \"London\"],\n        price: 1.99,\n      },\n    },\n    {\n      id: 3,\n      vector: [0.36, 0.55, 0.47, 0.94],\n      payload: {",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 19,
      "token_count": 348,
      "char_count": 990,
      "start_char": 17314,
      "end_char": 18305
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:20",
    "content": ": 1.99,\n      },\n    },\n    {\n      id: 3,\n      vector: [0.36, 0.55, 0.47, 0.94],\n      payload: {\n        city: [\"Berlin\", \"Moscow\"],\n        price: [1.99, 2.99],\n      },\n    },\n  ],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{PointStruct, UpsertPointsBuilder};\nuse qdrant_client::{Payload, Qdrant, QdrantError};\nuse serde_json::json;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nlet points = vec![\n    PointStruct::new(\n        1,\n        vec![0.05, 0.61, 0.76, 0.74],\n        Payload::try_from(json!({\"city\": \"Berlin\", \"price\": 1.99})).unwrap(),\n    ),\n    PointStruct::new(\n        2,\n        vec![0.19, 0.81, 0.75, 0.11],\n        Payload::try_from(json!({\"city\": [\"Berlin\", \"London\"]})).unwrap(),\n    ),\n    PointStruct::new(\n        3,\n        vec![0.36, 0.55, 0.47, 0.94],\n        Payload::try_from(json!({\"city\": [\"Berlin\", \"Moscow\"], \"price\": [1.99, 2.99]}))\n            .unwrap(),\n    ),\n];\n\nclient\n    .upsert_points(UpsertPointsBuilder::new(\"{collection_name}\", points).wait(true))\n    .",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 20,
      "token_count": 376,
      "char_count": 1024,
      "start_char": 18205,
      "end_char": 19229
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:21",
    "content": ";\n\nclient\n    .upsert_points(UpsertPointsBuilder::new(\"{collection_name}\", points).wait(true))\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\nimport static io.qdrant.client.VectorsFactory.vectors;\n\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.PointStruct;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .upsertAsync(\n        \"{collection_name}\",\n        List.of(\n            PointStruct.newBuilder()\n                .setId(id(1))\n                .setVectors(vectors(0.05f, 0.61f, 0.76f, 0.74f))\n                .putAllPayload(Map.of(\"city\", value(\"Berlin\"), \"price\", value(1.99)))\n                .build(),\n            PointStruct.newBuilder()\n                .setId(id(2))\n                .setVectors(vectors(0.19f, 0.81f, 0.75f, 0.11f))",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 21,
      "token_count": 283,
      "char_count": 1008,
      "start_char": 19129,
      "end_char": 20138
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:22",
    "content": "er()\n                .setId(id(2))\n                .setVectors(vectors(0.19f, 0.81f, 0.75f, 0.11f))\n                .putAllPayload(\n                    Map.of(\"city\", list(List.of(value(\"Berlin\"), value(\"London\")))))\n                .build(),\n            PointStruct.newBuilder()\n                .setId(id(3))\n                .setVectors(vectors(0.36f, 0.55f, 0.47f, 0.94f))\n                .putAllPayload(\n                    Map.of(\n                        \"city\",\n                        list(List.of(value(\"Berlin\"), value(\"London\"))),\n                        \"price\",\n                        list(List.of(value(1.99), value(2.99)))))\n                .build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpsertAsync(\n    collectionName: \"{collection_name}\",\n    points: new List<PointStruct>\n    {\n        new PointStruct\n        {\n            Id = 1,\n            Vectors = new[] { 0.05f, 0.61f, 0.76f, 0.74f },",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 22,
      "token_count": 284,
      "char_count": 1012,
      "start_char": 20038,
      "end_char": 21051
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:23",
    "content": "intStruct\n        {\n            Id = 1,\n            Vectors = new[] { 0.05f, 0.61f, 0.76f, 0.74f },\n            Payload = { [\"city\"] = \"Berlin\", [\"price\"] = 1.99 }\n        },\n        new PointStruct\n        {\n            Id = 2,\n            Vectors = new[] { 0.19f, 0.81f, 0.75f, 0.11f },\n            Payload = { [\"city\"] = new[] { \"Berlin\", \"London\" } }\n        },\n        new PointStruct\n        {\n            Id = 3,\n            Vectors = new[] { 0.36f, 0.55f, 0.47f, 0.94f },\n            Payload =\n            {\n                [\"city\"] = new[] { \"Berlin\", \"Moscow\" },\n                [\"price\"] = new Value\n                {\n                    ListValue = new ListValue { Values = { new Value[] { 1.99, 2.99 } } }\n                }\n            }\n        }\n    }\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.Upsert(context.Background(), &qdrant.UpsertPoints{",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 23,
      "token_count": 327,
      "char_count": 997,
      "start_char": 20951,
      "end_char": 21949
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:24",
    "content": "Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.Upsert(context.Background(), &qdrant.UpsertPoints{\n    CollectionName: \"{collection_name}\",\n    Points: []*qdrant.PointStruct{\n        {\n            Id:      qdrant.NewIDNum(1),\n            Vectors: qdrant.NewVectors(0.05, 0.61, 0.76, 0.74),\n            Payload: qdrant.NewValueMap(map[string]any{\n                \"city\": \"Berlin\", \"price\": 1.99}),\n        },\n        {\n            Id:      qdrant.NewIDNum(2),\n            Vectors: qdrant.NewVectors(0.19, 0.81, 0.75, 0.11),\n            Payload: qdrant.NewValueMap(map[string]any{\n                \"city\": []any{\"Berlin\", \"London\"}}),\n        },\n        {\n            Id:      qdrant.NewIDNum(3),\n            Vectors: qdrant.NewVectors(0.36, 0.55, 0.47, 0.94),\n            Payload: qdrant.NewValueMap(map[string]any{\n                \"city\":  []any{\"Berlin\", \"London\"},\n                \"price\": []any{1.99, 2.99}}),\n        },\n    },\n})\n```\n\n## Update payload",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 24,
      "token_count": 312,
      "char_count": 953,
      "start_char": 21849,
      "end_char": 22807
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:25",
    "content": "ondon\"},\n                \"price\": []any{1.99, 2.99}}),\n        },\n    },\n})\n```\n\n## Update payload\n\nUpdating payloads in Qdrant offers flexible methods to manage vector metadata. The **set payload** method updates specific fields while keeping others unchanged, while the **overwrite** method replaces the entire payload. Developers can also use **clear payload** to remove all metadata or delete fields to remove specific keys without affecting the rest. These options provide precise control for adapting to dynamic datasets.\n\n### Set payload\n\nSet only the given payload values on a point.\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/set-payload)):\n\n```http\nPOST /collections/{collection_name}/points/payload\n{\n    \"payload\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n    },\n    \"points\": [\n        0, 3, 100\n    ]\n}\n```\n\n```python\nclient.set_payload(\n    collection_name=\"{collection_name}\",\n    payload={\n        \"property1\": \"string\",\n        \"property2\": \"string\",\n    },",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 25,
      "token_count": 236,
      "char_count": 1019,
      "start_char": 22707,
      "end_char": 23727
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:26",
    "content": "llection_name}\",\n    payload={\n        \"property1\": \"string\",\n        \"property2\": \"string\",\n    },\n    points=[0, 3, 10],\n)\n```\n\n```typescript\nclient.setPayload(\"{collection_name}\", {\n  payload: {\n    property1: \"string\",\n    property2: \"string\",\n  },\n  points: [0, 3, 10],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    PointsIdsList, SetPayloadPointsBuilder,\n};\nuse qdrant_client::Payload,;\nuse serde_json::json;\n\nclient\n    .set_payload(\n        SetPayloadPointsBuilder::new(\n            \"{collection_name}\",\n            Payload::try_from(json!({\n                \"property1\": \"string\",\n                \"property2\": \"string\",\n            }))\n            .unwrap(),\n        )\n        .points_selector(PointsIdsList {\n            ids: vec![0.into(), 3.into(), 10.into()],\n        })\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\n\nclient\n    .setPayloadAsync(",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 26,
      "token_count": 263,
      "char_count": 1016,
      "start_char": 23627,
      "end_char": 24644
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:27",
    "content": "PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\n\nclient\n    .setPayloadAsync(\n        \"{collection_name}\",\n        Map.of(\"property1\", value(\"string\"), \"property2\", value(\"string\")),\n        List.of(id(0), id(3), id(10)),\n        true,\n        null,\n        null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.SetPayloadAsync(\n    collectionName: \"{collection_name}\",\n    payload: new Dictionary<string, Value> { { \"property1\", \"string\" }, { \"property2\", \"string\" } },\n    ids: new ulong[] { 0, 3, 10 }\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.SetPayload(context.Background(), &qdrant.SetPayloadPoints{\n    CollectionName: \"{collection_name}\",\n    Payload: qdrant.NewValueMap(\n        map[string]any{\"property1\": \"string\", \"property2\": \"string\"}),",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 27,
      "token_count": 282,
      "char_count": 1001,
      "start_char": 24544,
      "end_char": 25546
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:28",
    "content": "Payload: qdrant.NewValueMap(\n        map[string]any{\"property1\": \"string\", \"property2\": \"string\"}),\n    PointsSelector: qdrant.NewPointsSelector(\n        qdrant.NewIDNum(0),\n        qdrant.NewIDNum(3)),\n})\n```\n\nYou don’t need to know the ids of the points you want to modify. The alternative is to use filters.\n\n```http\nPOST /collections/{collection_name}/points/payload\n{\n    \"payload\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n    },\n    \"filter\": {\n        \"must\": [\n            {\n                \"key\": \"color\",\n                \"match\": {\n                    \"value\": \"red\"\n                }\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.set_payload(\n    collection_name=\"{collection_name}\",\n    payload={\n        \"property1\": \"string\",\n        \"property2\": \"string\",\n    },\n    points=models.Filter(\n        must=[\n            models.FieldCondition(\n                key=\"color\",\n                match=models.MatchValue(value=\"red\"),\n            ),\n        ],\n    ),\n)\n```\n\n```typescript",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 28,
      "token_count": 239,
      "char_count": 1021,
      "start_char": 25446,
      "end_char": 26468
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:29",
    "content": "match=models.MatchValue(value=\"red\"),\n            ),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.setPayload(\"{collection_name}\", {\n  payload: {\n    property1: \"string\",\n    property2: \"string\",\n  },\n  filter: {\n    must: [\n      {\n        key: \"color\",\n        match: {\n          value: \"red\",\n        },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, SetPayloadPointsBuilder};\nuse qdrant_client::Payload;\nuse serde_json::json;\n\nclient\n    .set_payload(\n        SetPayloadPointsBuilder::new(\n            \"{collection_name}\",\n            Payload::try_from(json!({\n                \"property1\": \"string\",\n                \"property2\": \"string\",\n            }))\n            .unwrap(),\n        )\n        .points_selector(Filter::must([Condition::matches(\n            \"color\",\n            \"red\".to_string(),\n        )]))\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.Map;\n\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\nimport static io.qdrant.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 29,
      "token_count": 240,
      "char_count": 1016,
      "start_char": 26368,
      "end_char": 27392
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:30",
    "content": "va.util.Map;\n\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\nimport static io.qdrant.client.ValueFactory.value;\n\nclient\n    .setPayloadAsync(\n        \"{collection_name}\",\n        Map.of(\"property1\", value(\"string\"), \"property2\", value(\"string\")),\n        Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build(),\n        true,\n        null,\n        null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.SetPayloadAsync(\n    collectionName: \"{collection_name}\",\n    payload: new Dictionary<string, Value> { { \"property1\", \"string\" }, { \"property2\", \"string\" } },\n    filter: MatchKeyword(\"color\", \"red\")\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.SetPayload(context.Background(), &qdrant.SetPayloadPoints{",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 30,
      "token_count": 261,
      "char_count": 1000,
      "start_char": 27292,
      "end_char": 28293
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:31",
    "content": "\"localhost\",\n    Port: 6334,\n})\n\nclient.SetPayload(context.Background(), &qdrant.SetPayloadPoints{\n    CollectionName: \"{collection_name}\",\n    Payload: qdrant.NewValueMap(\n        map[string]any{\"property1\": \"string\", \"property2\": \"string\"}),\n    PointsSelector: qdrant.NewPointsSelectorFilter(&qdrant.Filter{\n        Must: []*qdrant.Condition{\n            qdrant.NewMatch(\"color\", \"red\"),\n        },\n    }),\n})\n```\n\n*Available as of v1.8.0*\n\nIt is possible to modify only a specific key of the payload by using the `key` parameter.\n\nFor instance, given the following payload JSON object on a point:\n\n```json\n{\n    \"property1\": {\n        \"nested_property\": \"foo\",\n    },\n    \"property2\": {\n        \"nested_property\": \"bar\",\n    }\n}\n```\n\nYou can modify the `nested_property` of `property1` with the following request:\n\n```http\nPOST /collections/{collection_name}/points/payload\n{\n    \"payload\": {\n        \"nested_property\": \"qux\",\n    },\n    \"key\": \"property1\",\n    \"points\": [1]\n}\n```\n\nResulting in the following payload:",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 31,
      "token_count": 266,
      "char_count": 1022,
      "start_char": 28193,
      "end_char": 29218
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:32",
    "content": "\"qux\",\n    },\n    \"key\": \"property1\",\n    \"points\": [1]\n}\n```\n\nResulting in the following payload:\n\n```json\n{\n    \"property1\": {\n        \"nested_property\": \"qux\",\n    },\n    \"property2\": {\n        \"nested_property\": \"bar\",\n    }\n}\n```\n\n### Overwrite payload\n\nFully replace any existing payload with the given one.\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/overwrite-payload)):\n\n```http\nPUT /collections/{collection_name}/points/payload\n{\n    \"payload\": {\n        \"property1\": \"string\",\n        \"property2\": \"string\"\n    },\n    \"points\": [\n        0, 3, 100\n    ]\n}\n```\n\n```python\nclient.overwrite_payload(\n    collection_name=\"{collection_name}\",\n    payload={\n        \"property1\": \"string\",\n        \"property2\": \"string\",\n    },\n    points=[0, 3, 10],\n)\n```\n\n```typescript\nclient.overwritePayload(\"{collection_name}\", {\n  payload: {\n    property1: \"string\",\n    property2: \"string\",\n  },\n  points: [0, 3, 10],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{PointsIdsList, SetPayloadPointsBuilder};",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 32,
      "token_count": 289,
      "char_count": 1019,
      "start_char": 29118,
      "end_char": 30138
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:33",
    "content": ": [0, 3, 10],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{PointsIdsList, SetPayloadPointsBuilder};\nuse qdrant_client::Payload;\nuse serde_json::json;\n\nclient\n    .overwrite_payload(\n        SetPayloadPointsBuilder::new(\n            \"{collection_name}\",\n            Payload::try_from(json!({\n                \"property1\": \"string\",\n                \"property2\": \"string\",\n            }))\n            .unwrap(),\n        )\n        .points_selector(PointsIdsList {\n            ids: vec![0.into(), 3.into(), 10.into()],\n        })\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\n\nclient\n    .overwritePayloadAsync(\n        \"{collection_name}\",\n        Map.of(\"property1\", value(\"string\"), \"property2\", value(\"string\")),\n        List.of(id(0), id(3), id(10)),\n        true,\n        null,\n        null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 33,
      "token_count": 255,
      "char_count": 997,
      "start_char": 30038,
      "end_char": 31037
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:34",
    "content": "null,\n        null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.OverwritePayloadAsync(\n    collectionName: \"{collection_name}\",\n    payload: new Dictionary<string, Value> { { \"property1\", \"string\" }, { \"property2\", \"string\" } },\n    ids: new ulong[] { 0, 3, 10 }\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.OverwritePayload(context.Background(), &qdrant.SetPayloadPoints{\n    CollectionName: \"{collection_name}\",\n    Payload: qdrant.NewValueMap(\n        map[string]any{\"property1\": \"string\", \"property2\": \"string\"}),\n    PointsSelector: qdrant.NewPointsSelector(\n        qdrant.NewIDNum(0),\n        qdrant.NewIDNum(3)),\n})\n```\n\nLike [set payload](#set-payload.md), you don’t need to know the ids of the points you want to modify. The alternative is to use filters.\n\n### Clear payload",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 34,
      "token_count": 291,
      "char_count": 1014,
      "start_char": 30937,
      "end_char": 31958
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:35",
    "content": "ow the ids of the points you want to modify. The alternative is to use filters.\n\n### Clear payload\n\nThis method removes all payload keys from specified points\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/clear-payload)):\n\n```http\nPOST /collections/{collection_name}/points/payload/clear\n{\n    \"points\": [0, 3, 100]\n}\n```\n\n```python\nclient.clear_payload(\n    collection_name=\"{collection_name}\",\n    points_selector=[0, 3, 100],\n)\n```\n\n```typescript\nclient.clearPayload(\"{collection_name}\", {\n  points: [0, 3, 100],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{ClearPayloadPointsBuilder, PointsIdsList};\n\nclient\n    .clear_payload(\n        ClearPayloadPointsBuilder::new(\"{collection_name}\")\n            .points(PointsIdsList {\n                ids: vec![0.into(), 3.into(), 10.into()],\n            })\n            .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.PointIdFactory.id;\n\nclient\n    .clearPayloadAsync(\"{collection_name}\", List.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 35,
      "token_count": 261,
      "char_count": 1008,
      "start_char": 31858,
      "end_char": 32866
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:36",
    "content": "static io.qdrant.client.PointIdFactory.id;\n\nclient\n    .clearPayloadAsync(\"{collection_name}\", List.of(id(0), id(3), id(100)), true, null, null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ClearPayloadAsync(collectionName: \"{collection_name}\", ids: new ulong[] { 0, 3, 100 });\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient.ClearPayload(context.Background(), &qdrant.ClearPayloadPoints{\n    CollectionName: \"{collection_name}\",\n    Points: qdrant.NewPointsSelector(\n        qdrant.NewIDNum(0),\n        qdrant.NewIDNum(3)),\n})\n```\n\nYou can also use `models.FilterSelector` to remove the points matching given filter criteria, instead of providing the ids.\n\n### Delete payload keys\n\nDelete specific payload keys from points.\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/delete-payload)):\n\n```http\nPOST /collections/{collection_name}/points/payload/delete\n{\n    \"keys\": [\"color\", \"price\"],",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 36,
      "token_count": 269,
      "char_count": 1014,
      "start_char": 32766,
      "end_char": 33781
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:37",
    "content": "```http\nPOST /collections/{collection_name}/points/payload/delete\n{\n    \"keys\": [\"color\", \"price\"],\n    \"points\": [0, 3, 100]\n}\n```\n\n```python\nclient.delete_payload(\n    collection_name=\"{collection_name}\",\n    keys=[\"color\", \"price\"],\n    points=[0, 3, 100],\n)\n```\n\n```typescript\nclient.deletePayload(\"{collection_name}\", {\n  keys: [\"color\", \"price\"],\n  points: [0, 3, 100],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{DeletePayloadPointsBuilder, PointsIdsList};\n\nclient\n    .delete_payload(\n        DeletePayloadPointsBuilder::new(\n            \"{collection_name}\",\n            vec![\"color\".to_string(), \"price\".to_string()],\n        )\n        .points_selector(PointsIdsList {\n            ids: vec![0.into(), 3.into(), 10.into()],\n        })\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.PointIdFactory.id;\n\nclient\n    .deletePayloadAsync(\n        \"{collection_name}\",\n        List.of(\"color\", \"price\"),\n        List.of(id(0), id(3), id(100)),\n        true,",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 37,
      "token_count": 281,
      "char_count": 1021,
      "start_char": 33681,
      "end_char": 34703
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:38",
    "content": "on_name}\",\n        List.of(\"color\", \"price\"),\n        List.of(id(0), id(3), id(100)),\n        true,\n        null,\n        null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.DeletePayloadAsync(\n    collectionName: \"{collection_name}\",\n    keys: [\"color\", \"price\"],\n    ids: new ulong[] { 0, 3, 100 }\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.DeletePayload(context.Background(), &qdrant.DeletePayloadPoints{\n    CollectionName: \"{collection_name}\",\n    Keys:           []string{\"color\", \"price\"},\n    PointsSelector: qdrant.NewPointsSelector(\n        qdrant.NewIDNum(0),\n        qdrant.NewIDNum(3)),\n})\n```\n\nAlternatively, you can use filters to delete payload keys from the points.\n\n```http\nPOST /collections/{collection_name}/points/payload/delete\n{\n    \"keys\": [\"color\", \"price\"],\n    \"filter\": {\n        \"must\": [",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 38,
      "token_count": 287,
      "char_count": 1021,
      "start_char": 34603,
      "end_char": 35625
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:39",
    "content": "ion_name}/points/payload/delete\n{\n    \"keys\": [\"color\", \"price\"],\n    \"filter\": {\n        \"must\": [\n            {\n                \"key\": \"color\",\n                \"match\": {\n                    \"value\": \"red\"\n                }\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.delete_payload(\n    collection_name=\"{collection_name}\",\n    keys=[\"color\", \"price\"],\n    points=models.Filter(\n        must=[\n            models.FieldCondition(\n                key=\"color\",\n                match=models.MatchValue(value=\"red\"),\n            ),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.deletePayload(\"{collection_name}\", {\n  keys: [\"color\", \"price\"],\n  filter: {\n    must: [\n      {\n        key: \"color\",\n        match: {\n          value: \"red\",\n        },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, DeletePayloadPointsBuilder, Filter};\n\nclient\n    .delete_payload(\n        DeletePayloadPointsBuilder::new(\n            \"{collection_name}\",\n            vec![\"color\".to_string(), \"price\".",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 39,
      "token_count": 230,
      "char_count": 1020,
      "start_char": 35525,
      "end_char": 36545
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:40",
    "content": "dPointsBuilder::new(\n            \"{collection_name}\",\n            vec![\"color\".to_string(), \"price\".to_string()],\n        )\n        .points_selector(Filter::must([Condition::matches(\n            \"color\",\n            \"red\".to_string(),\n        )]))\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nclient\n    .deletePayloadAsync(\n        \"{collection_name}\",\n        List.of(\"color\", \"price\"),\n        Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build(),\n        true,\n        null,\n        null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.DeletePayloadAsync(\n    collectionName: \"{collection_name}\",\n    keys: [\"color\", \"price\"],\n    filter: MatchKeyword(\"color\", \"red\")\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 40,
      "token_count": 253,
      "char_count": 1019,
      "start_char": 36445,
      "end_char": 37465
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:41",
    "content": "ntext\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.DeletePayload(context.Background(), &qdrant.DeletePayloadPoints{\n    CollectionName: \"{collection_name}\",\n    Keys:           []string{\"color\", \"price\"},\n    PointsSelector: qdrant.NewPointsSelectorFilter(\n        &qdrant.Filter{\n            Must: []*qdrant.Condition{qdrant.NewMatch(\"color\", \"red\")},\n        },\n    ),\n})\n```\n\n## Payload indexing\n\nTo search more efficiently with filters, Qdrant allows you to create indexes for payload fields by specifying the name and type of field it is intended to be.\n\nThe indexed fields also affect the vector index. See [Indexing](https://qdrant.tech/documentation/concepts/indexing/) for details.\n\nIn practice, we recommend creating an index on those fields that could potentially constrain the results the most.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 41,
      "token_count": 213,
      "char_count": 905,
      "start_char": 37365,
      "end_char": 38270
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:42",
    "content": "e recommend creating an index on those fields that could potentially constrain the results the most. For example, using an index for the object ID will be much more efficient, being unique for each record, than an index by its color, which has only a few possible values.\n\nIn compound queries involving multiple fields, Qdrant will attempt to use the most restrictive index first.\n\nTo create index for the field, you can use the following:\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/indexes/create-field-index))\n\n```http\nPUT /collections/{collection_name}/index\n{\n    \"field_name\": \"name_of_the_field_to_index\",\n    \"field_schema\": \"keyword\"\n}\n```\n\n```python\nclient.create_payload_index(\n    collection_name=\"{collection_name}\",\n    field_name=\"name_of_the_field_to_index\",\n    field_schema=\"keyword\",\n)\n```\n\n```typescript\nclient.createPayloadIndex(\"{collection_name}\", {\n  field_name: \"name_of_the_field_to_index\",\n  field_schema: \"keyword\",\n});\n```\n\n```rust",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 42,
      "token_count": 216,
      "char_count": 974,
      "start_char": 38170,
      "end_char": 39145
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:43",
    "content": "n_name}\", {\n  field_name: \"name_of_the_field_to_index\",\n  field_schema: \"keyword\",\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{CreateFieldIndexCollectionBuilder, FieldType};\n\nclient\n    .create_field_index(\n        CreateFieldIndexCollectionBuilder::new(\n            \"{collection_name}\",\n            \"name_of_the_field_to_index\",\n            FieldType::Keyword,\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.grpc.Collections.PayloadSchemaType;\n\nclient.createPayloadIndexAsync(\n    \"{collection_name}\",\n    \"name_of_the_field_to_index\",\n    PayloadSchemaType.Keyword,\n    null,\n    true,\n    null,\n    null);\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreatePayloadIndexAsync(\n    collectionName: \"{collection_name}\",\n    fieldName: \"name_of_the_field_to_index\"\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 43,
      "token_count": 253,
      "char_count": 1013,
      "start_char": 39045,
      "end_char": 40059
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:44",
    "content": "/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.CreateFieldIndex(context.Background(), &qdrant.CreateFieldIndexCollection{\n    CollectionName: \"{collection_name}\",\n    FieldName:      \"name_of_the_field_to_index\",\n    FieldType:      qdrant.FieldType_FieldTypeKeyword.Enum(),\n})\n```\n\nThe index usage flag is displayed in the payload schema with the [collection info API](https://api.qdrant.tech/api-reference/collections/get-collection).\n\nPayload schema example:\n\n```json\n{\n    \"payload_schema\": {\n        \"property1\": {\n            \"data_type\": \"keyword\"\n        },\n        \"property2\": {\n            \"data_type\": \"integer\"\n        }\n    }\n}\n```\n\n## Facet counts\n\n*Available as of v1.12.0*\n\nFaceting is a special counting technique that can be used for various purposes:\n\n- Know which unique values exist for a payload key.\n- Know the number of points that contain each unique value.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 44,
      "token_count": 232,
      "char_count": 963,
      "start_char": 39959,
      "end_char": 40923
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:45",
    "content": "unique values exist for a payload key.\n- Know the number of points that contain each unique value.\n- Know how restrictive a filter would become by matching a specific value.\n\nSpecifically, it is a counting aggregation for the values in a field, akin to a `GROUP BY` with `COUNT(*)` commands in SQL.\n\nThese results for a specific field is called a “facet”. For example, when you look at an e-commerce search results page, you might see a list of brands on the sidebar, showing the number of products for each brand. This would be a facet for a `\"brand\"` field.\n\nIn Qdrant you can facet on a field **only** if you have created a field index that supports `MatchValue` conditions for it, like a `keyword` index.\n\nTo get the facet counts for a field, you can use the following:\n\nBy default, the number of `hits` returned is limited to 10. To change this, use the `limit` parameter. Keep this in mind when checking the number of unique values a payload field contains.\n\nREST API ([Facet](https://api.qdrant.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 45,
      "token_count": 232,
      "char_count": 1002,
      "start_char": 40823,
      "end_char": 41826
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:46",
    "content": "hecking the number of unique values a payload field contains.\n\nREST API ([Facet](https://api.qdrant.tech/v-1-13-x/api-reference/points/facet))\n\n```http\nPOST /collections/{collection_name}/facet\n{\n    \"key\": \"size\",\n    \"filter\": {\n      \"must\": {\n        \"key\": \"color\",\n        \"match\": { \"value\": \"red\" }\n      }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.facet(\n    collection_name=\"{collection_name}\",\n    key=\"size\",\n    facet_filter=models.Filter(must=[models.Match(\"color\", \"red\")]),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.facet(\"{collection_name}\", {\n    filter: {\n        must: [\n            {\n                key: \"color\",\n                match: {\n                    value: \"red\",\n                },\n            },\n        ],\n    },\n    key: \"size\",\n});\n```\n\n```rust",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 46,
      "token_count": 259,
      "char_count": 978,
      "start_char": 41726,
      "end_char": 42705
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:47",
    "content": "value: \"red\",\n                },\n            },\n        ],\n    },\n    key: \"size\",\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, FacetCountsBuilder, Filter};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .facet(\n         FacetCountsBuilder::new(\"{collection_name}\", \"size\")\n             .limit(10)\n             .filter(Filter::must(vec![Condition::matches(\n                 \"color\",\n                 \"red\".to_string(),\n             )])),\n     )\n     .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\n\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\nimport io.qdrant.client.grpc.Points;\nimport io.qdrant.client.grpc.Filter;\n\nQdrantClient client = new QdrantClient(\n                QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .facetAsync(\n        Points.FacetCounts.newBuilder()\n            .setCollectionName(collection_name)\n            .setKey(\"size\")",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 47,
      "token_count": 256,
      "char_count": 1019,
      "start_char": 42605,
      "end_char": 43625
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:48",
    "content": "acetCounts.newBuilder()\n            .setCollectionName(collection_name)\n            .setKey(\"size\")\n            .setFilter(Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build())\n            .build())\n        .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.FacetAsync(\n    \"{collection_name}\",\n    key: \"size\",\n    filter: MatchKeyword(\"color\", \"red\")\n);\n```\n\n```go\nimport (\n    \"context\"\n\n    \"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nres, err := client.Facet(ctx, &qdrant.FacetCounts{\n    CollectionName: \"{collection_name}\",\n    Key:            \"size\",\n        Filter: &qdrant.Filter{\n        Must: []*qdrant.Condition{\n            qdrant.NewMatch(\"color\", \"red\"),\n        },\n    },\n})\n```\n\nThe response will contain the counts for each unique value in the field:\n\n```json\n{\n  \"response\": {\n    \"hits\": [",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 48,
      "token_count": 268,
      "char_count": 1012,
      "start_char": 43525,
      "end_char": 44538
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:49",
    "content": "ill contain the counts for each unique value in the field:\n\n```json\n{\n  \"response\": {\n    \"hits\": [\n      {\"value\": \"L\", \"count\": 19},\n      {\"value\": \"S\", \"count\": 10},\n      {\"value\": \"M\", \"count\": 5},\n      {\"value\": \"XL\", \"count\": 1},\n      {\"value\": \"XXL\", \"count\": 1}\n    ]\n  },\n  \"time\": 0.0001\n}\n```\n\nThe results are sorted by the count in descending order, then by the value in ascending order. Only values with non-zero counts will be returned.\n\nBy default, the way Qdrant the counts for each value is approximate to achieve fast results. This should accurate enough for most cases, but if you need to debug your storage, you can use the `exact` parameter to get exact counts.\n\n```http\nPOST /collections/{collection_name}/facet\n{\n    \"key\": \"size\",\n    \"exact\": true\n}\n```\n\n```python\nclient.facet(\n    collection_name=\"{collection_name}\",\n    key=\"size\",\n    exact=True,\n)\n```\n\n```typescript\nclient.facet(\"{collection_name}\", {\n    key: \"size\",\n    exact: true,\n});\n```\n\n```rust",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 49,
      "token_count": 275,
      "char_count": 988,
      "start_char": 44438,
      "end_char": 45427
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:50",
    "content": "``typescript\nclient.facet(\"{collection_name}\", {\n    key: \"size\",\n    exact: true,\n});\n```\n\n```rust\nuse qdrant_client::qdrant::FacetCountsBuilder;\n\nclient\n    .facet(\n         FacetCountsBuilder::new(\"{collection_name}\", \"size\")\n             .limit(10)\n             .exact(true),\n     )\n     .await?;\n```\n\n```java\n client\n      .facetAsync(\n          Points.FacetCounts.newBuilder()\n              .setCollectionName(collection_name)\n              .setKey(\"foo\")\n              .setExact(true)\n              .build())\n      .get();\n```\n\n```csharp\nusing Qdrant.Client;\n\nawait client.FacetAsync(\n    \"{collection_name}\",\n    key: \"size\",\n    exact: true,\n);\n```\n\n```go\nres, err := client.Facet(ctx, &qdrant.FacetCounts{\n    CollectionName: \"{collection_name}\",\n    Key:            \"key\",\n    Exact:          true,\n})\n```\n\n##### Was this page useful?\n\nYes No\n\nThank you for your feedback! 🙏\n\nWe are sorry to hear that. 😔 You can [edit](https:/github.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 50,
      "token_count": 247,
      "char_count": 945,
      "start_char": 45327,
      "end_char": 46272
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:51",
    "content": "Yes No\n\nThank you for your feedback! 🙏\n\nWe are sorry to hear that. 😔 You can [edit](https:/github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/payload.md) this page on GitHub, or [create](https://github.com/qdrant/landing_page/issues/new/choose) a GitHub issue.\n\nOn this page:\n\n- [Payload](#payload.md)\n\n  - [Payload types](#payload-types.md)\n\n    - [Integer](#integer.md)\n    - [Float](#float.md)\n    - [Bool](#bool.md)\n    - [Keyword](#keyword.md)\n    - [Geo](#geo.md)\n    - [Datetime](#datetime.md)\n    - [UUID](#uuid.md)\n\n  - [Create point with payload](#create-point-with-payload.md)\n\n  - [Update payload](#update-payload.md)\n\n    - [Set payload](#set-payload.md)\n    - [Overwrite payload](#overwrite-payload.md)\n    - [Clear payload](#clear-payload.md)\n    - [Delete payload keys](#delete-payload-keys.md)\n\n  - [Payload indexing](#payload-indexing.md)\n\n  - [Facet counts](#facet-counts.md)\n\n* [Edit on Github](https://github.",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 51,
      "token_count": 281,
      "char_count": 968,
      "start_char": 46172,
      "end_char": 47142
    }
  },
  {
    "chunk_id": "qdrant_ecosystem:qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md:chunk:52",
    "content": "ing](#payload-indexing.md)\n\n  - [Facet counts](#facet-counts.md)\n\n* [Edit on Github](https://github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/payload.md)\n* [Create an issue](https://github.com/qdrant/landing_page/issues/new/choose)\n\n#### Ready to get started with Qdrant?\n\n[Start Free](https://qdrant.to/cloud/)\n\n© 2025 Qdrant.\n\n[Terms](https://qdrant.tech/legal/terms_and_conditions/) [Privacy Policy](https://qdrant.tech/legal/privacy-policy/) [Impressum](https://qdrant.tech/legal/impressum/)",
    "metadata": {
      "source_file": "qdrant_documentation\\documentation_concepts_payload\\_documentation_concepts_payload_.md",
      "source_collection": "qdrant_ecosystem",
      "subdirectory": "qdrant_documentation",
      "filename": "_documentation_concepts_payload_.md",
      "file_extension": ".md",
      "chunk_index": 52,
      "token_count": 152,
      "char_count": 535,
      "start_char": 47042,
      "end_char": 48066
    }
  }
]