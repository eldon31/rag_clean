{
  "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\qdrant_ecosystem\\qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
  "source_repo": "qdrant_documentation",
  "total_chunks": 44,
  "chunks": [
    {
      "content": "Filtering - Qdrant\n\n[](https://qdrant.tech/)\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\nSearch\n\n[Log in](https://cloud.qdrant.io/login) [Start Free](https://cloud.qdrant.io/signup)\n\nSearch\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.",
      "index": 0,
      "token_count": 527,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 0,
      "end_char": 2020
    },
    {
      "content": "[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.",
      "index": 1,
      "token_count": 507,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 1920,
      "end_char": 3924
    },
    {
      "content": "ocumentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)",
      "index": 2,
      "token_count": 472,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 3824,
      "end_char": 5839
    },
    {
      "content": "fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)",
      "index": 3,
      "token_count": 514,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 5739,
      "end_char": 7787
    },
    {
      "content": "n/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.",
      "index": 4,
      "token_count": 501,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 7687,
      "end_char": 9684
    },
    {
      "content": "nced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n- [Documentation](https://qdrant.tech/documentation/)\n-\n- [Concepts](https://qdrant.tech/documentation/concepts/)\n-\n- Filtering\n\n# Filtering\n\nWith Qdrant, you can set conditions when searching or retrieving points. For example, you can impose conditions on both the [payload](https://qdrant.",
      "index": 5,
      "token_count": 479,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 9584,
      "end_char": 11607
    },
    {
      "content": "g or retrieving points. For example, you can impose conditions on both the [payload](https://qdrant.tech/documentation/concepts/payload/) and the `id` of the point.\n\nSetting additional conditions is important when it is impossible to express all the features of the object in the embedding. Examples include a variety of business requirements: stock availability, user location, or desired price range.\n\n## Related Content\n\n| [A Complete Guide to Filtering in Vector Search](https://qdrant.tech/articles/vector-search-filtering/) | Developer advice on proper usage and advanced practices. |\n| ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------- |\n\n## Filtering clauses\n\nQdrant allows you to combine conditions in clauses. Clauses are different logical operations, such as `OR`, `AND`, and `NOT`. Clauses can be recursively nested into each other so that you can reproduce an arbitrary boolean expression.\n\nLet’s take a look at the clauses implemented in Qdrant.\n\nSuppose we have a set of points with the following payload:\n\n```json\n[\n  { \"id\": 1, \"city\": \"London\", \"color\": \"green\" },\n  { \"id\": 2, \"city\": \"London\", \"color\": \"red\" },\n  { \"id\": 3, \"city\": \"London\", \"color\": \"blue\" },\n  { \"id\": 4, \"city\": \"Berlin\", \"color\": \"red\" },\n  { \"id\": 5, \"city\": \"Moscow\", \"color\": \"green\" },\n  { \"id\": 6, \"city\": \"Moscow\", \"color\": \"blue\" }\n]\n```\n\n### Must\n\nExample:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [\n            { \"key\": \"city\", \"match\": { \"value\": \"London\" } },\n            { \"key\": \"color\", \"match\": { \"value\": \"red\" } }\n        ]\n    }\n    ...\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.FieldCondition(\n                key=\"city\",\n                match=models.",
      "index": 6,
      "token_count": 484,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 11507,
      "end_char": 13532
    },
    {
      "content": "must=[\n            models.FieldCondition(\n                key=\"city\",\n                match=models.MatchValue(value=\"London\"),\n            ),\n            models.FieldCondition(\n                key=\"color\",\n                match=models.MatchValue(value=\"red\"),\n            ),\n        ]\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        key: \"city\",\n        match: { value: \"London\" },\n      },\n      {\n        key: \"color\",\n        match: { value: \"red\" },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::must([\n            Condition::matches(\"city\", \"london\".to_string()),\n            Condition::matches(\"color\", \"red\".to_string()),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addAllMust(\n                        List.of(matchKeyword(\"city\", \"London\"), matchKeyword(\"color\", \"red\")))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\n// & operator combines two conditions in an AND conjunction(must)\nawait client.",
      "index": 7,
      "token_count": 486,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 13432,
      "end_char": 15477
    },
    {
      "content": "\"localhost\", 6334);\n\n// & operator combines two conditions in an AND conjunction(must)\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: MatchKeyword(\"city\", \"London\") & MatchKeyword(\"color\", \"red\")\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"city\", \"London\"),\n\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t},\n\t},\n})\n```\n\nFiltered points would be:\n\n```json\n[{ \"id\": 2, \"city\": \"London\", \"color\": \"red\" }]\n```\n\nWhen using `must`, the clause becomes `true` only if every condition listed inside `must` is satisfied. In this sense, `must` is equivalent to the operator `AND`.\n\n### Should\n\nExample:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"should\": [\n            { \"key\": \"city\", \"match\": { \"value\": \"London\" } },\n            { \"key\": \"color\", \"match\": { \"value\": \"red\" } }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        should=[\n            models.FieldCondition(\n                key=\"city\",\n                match=models.MatchValue(value=\"London\"),\n            ),\n            models.FieldCondition(\n                key=\"color\",\n                match=models.MatchValue(value=\"red\"),\n            ),\n        ]\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    should: [\n      {\n        key: \"city\",\n        match: { value: \"London\" },\n      },\n      {\n        key: \"color\",\n        match: { value: \"red\" },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").",
      "index": 8,
      "token_count": 529,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 15377,
      "end_char": 17414
    },
    {
      "content": "calhost:6334\").build()?;\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::should([\n            Condition::matches(\"city\", \"london\".to_string()),\n            Condition::matches(\"color\", \"red\".to_string()),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\nimport java.util.List;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addAllShould(\n                        List.of(matchKeyword(\"city\", \"London\"), matchKeyword(\"color\", \"red\")))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\n// | operator combines two conditions in an OR disjunction(should)\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: MatchKeyword(\"city\", \"London\") | MatchKeyword(\"color\", \"red\")\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tShould: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"city\", \"London\"),\n\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t},\n\t},\n})\n```\n\nFiltered points would be:\n\n```json\n[\n  { \"id\": 1, \"city\": \"London\", \"color\": \"green\" },\n  { \"id\": 2, \"city\": \"London\", \"color\": \"red\" },\n  { \"id\": 3, \"city\": \"London\", \"color\": \"blue\" },\n  { \"id\": 4, \"city\": \"Berlin\", \"color\": \"red\" }\n]\n```\n\nWhen using `should`, the clause becomes `true` if at least one condition listed inside `should` is satisfied. In this sense, `should` is equivalent to the operator `OR`.\n\n### Must Not\n\nExample:\n\n```http",
      "index": 9,
      "token_count": 532,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 17314,
      "end_char": 19334
    },
    {
      "content": "sfied. In this sense, `should` is equivalent to the operator `OR`.\n\n### Must Not\n\nExample:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must_not\": [\n            { \"key\": \"city\", \"match\": { \"value\": \"London\" } },\n            { \"key\": \"color\", \"match\": { \"value\": \"red\" } }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must_not=[\n            models.FieldCondition(key=\"city\", match=models.MatchValue(value=\"London\")),\n            models.FieldCondition(key=\"color\", match=models.MatchValue(value=\"red\")),\n        ]\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must_not: [\n      {\n        key: \"city\",\n        match: { value: \"London\" },\n      },\n      {\n        key: \"color\",\n        match: { value: \"red\" },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::must_not([\n            Condition::matches(\"city\", \"london\".to_string()),\n            Condition::matches(\"color\", \"red\".to_string()),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addAllMustNot(\n                        List.of(matchKeyword(\"city\", \"London\"), matchKeyword(\"color\", \"red\")))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\n// The !",
      "index": 10,
      "token_count": 490,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 19234,
      "end_char": 21258
    },
    {
      "content": "g static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\n// The ! operator negates the condition(must not)\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: !(MatchKeyword(\"city\", \"London\") & MatchKeyword(\"color\", \"red\"))\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMustNot: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"city\", \"London\"),\n\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t},\n\t},\n})\n```\n\nFiltered points would be:\n\n```json\n[\n  { \"id\": 5, \"city\": \"Moscow\", \"color\": \"green\" },\n  { \"id\": 6, \"city\": \"Moscow\", \"color\": \"blue\" }\n]\n```\n\nWhen using `must_not`, the clause becomes `true` if none of the conditions listed inside `must_not` is satisfied. In this sense, `must_not` is equivalent to the expression `(NOT A) AND (NOT B) AND (NOT C)`.\n\n### Clauses combination\n\nIt is also possible to use several clauses simultaneously:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [\n            { \"key\": \"city\", \"match\": { \"value\": \"London\" } }\n        ],\n        \"must_not\": [\n            { \"key\": \"color\", \"match\": { \"value\": \"red\" } }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.FieldCondition(key=\"city\", match=models.MatchValue(value=\"London\")),\n        ],\n        must_not=[\n            models.FieldCondition(key=\"color\", match=models.MatchValue(value=\"red\")),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        key: \"city\",\n        match: { value: \"London\" },\n      },\n    ],\n    must_not: [\n      {\n        key: \"color\",\n        match: { value: \"red\" },\n      },\n    ],\n  },\n});\n```\n\n```rust",
      "index": 11,
      "token_count": 545,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 21158,
      "end_char": 23168
    },
    {
      "content": "{\n        key: \"color\",\n        match: { value: \"red\" },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter {\n            must: vec![Condition::matches(\"city\", \"London\".to_string())],\n            must_not: vec![Condition::matches(\"color\", \"red\".to_string())],\n            ..Default::default()\n        }),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addMust(matchKeyword(\"city\", \"London\"))\n                    .addMustNot(matchKeyword(\"color\", \"red\"))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: MatchKeyword(\"city\", \"London\") & !MatchKeyword(\"color\", \"red\")\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"city\", \"London\"),\n\t\t},\n\t\tMustNot: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t},\n\t},\n})\n```\n\nFiltered points would be:\n\n```json\n[\n  { \"id\": 1, \"city\": \"London\", \"color\": \"green\" },\n  { \"id\": 3, \"city\": \"London\", \"color\": \"blue\" }\n]\n```\n\nIn this case, the conditions are combined by `AND`.\n\nAlso, the conditions could be recursively nested. Example:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {",
      "index": 12,
      "token_count": 532,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 23068,
      "end_char": 25111
    },
    {
      "content": "ively nested. Example:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must_not\": [\n            {\n                \"must\": [\n                    { \"key\": \"city\", \"match\": { \"value\": \"London\" } },\n                    { \"key\": \"color\", \"match\": { \"value\": \"red\" } }\n                ]\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must_not=[\n            models.Filter(\n                must=[\n                    models.FieldCondition(\n                        key=\"city\", match=models.MatchValue(value=\"London\")\n                    ),\n                    models.FieldCondition(\n                        key=\"color\", match=models.MatchValue(value=\"red\")\n                    ),\n                ],\n            ),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must_not: [\n      {\n        must: [\n          {\n            key: \"city\",\n            match: { value: \"London\" },\n          },\n          {\n            key: \"color\",\n            match: { value: \"red\" },\n          },\n        ],\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::must_not([Filter::must(\n            [\n                Condition::matches(\"city\", \"London\".to_string()),\n                Condition::matches(\"color\", \"red\".to_string()),\n            ],\n        )\n        .into()])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.filter;\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addMustNot(",
      "index": 13,
      "token_count": 427,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 25011,
      "end_char": 27052
    },
    {
      "content": "ame}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addMustNot(\n                        filter(\n                            Filter.newBuilder()\n                                .addAllMust(\n                                    List.of(\n                                        matchKeyword(\"city\", \"London\"),\n                                        matchKeyword(\"color\", \"red\")))\n                                .build()))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: new Filter { MustNot = { MatchKeyword(\"city\", \"London\") & MatchKeyword(\"color\", \"red\") } }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMustNot: []*qdrant.Condition{\n\t\t\tqdrant.NewFilterAsCondition(&qdrant.Filter{\n\t\t\t\tMust: []*qdrant.Condition{\n\t\t\t\t\tqdrant.NewMatch(\"city\", \"London\"),\n\t\t\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t\t\t},\n\t\t\t}),\n\t\t},\n\t},\n})\n```\n\nFiltered points would be:\n\n```json\n[\n  { \"id\": 1, \"city\": \"London\", \"color\": \"green\" },\n  { \"id\": 3, \"city\": \"London\", \"color\": \"blue\" },\n  { \"id\": 4, \"city\": \"Berlin\", \"color\": \"red\" },\n  { \"id\": 5, \"city\": \"Moscow\", \"color\": \"green\" },\n  { \"id\": 6, \"city\": \"Moscow\", \"color\": \"blue\" }\n]\n```\n\n## Filtering conditions\n\nDifferent types of values in payload correspond to different kinds of queries that we can apply to them. Let’s look at the existing condition variants and what types of data they apply to.\n\n### Match\n\n```json\n{\n  \"key\": \"color\",\n  \"match\": {\n    \"value\": \"red\"\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"color\",\n    match=models.MatchValue(value=\"red\"),\n)\n```\n\n```typescript\n{",
      "index": 14,
      "token_count": 529,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 26952,
      "end_char": 29001
    },
    {
      "content": "s.FieldCondition(\n    key=\"color\",\n    match=models.MatchValue(value=\"red\"),\n)\n```\n\n```typescript\n{\n    key: 'color', \n    match: {value: 'red'}\n}\n```\n\n```rust\nCondition::matches(\"color\", \"red\".to_string())\n```\n\n```java\nmatchKeyword(\"color\", \"red\");\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nMatchKeyword(\"color\", \"red\");\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewMatch(\"color\", \"red\")\n```\n\nFor the other types, the match condition will look exactly the same, except for the type used:\n\n```json\n{\n  \"key\": \"count\",\n  \"match\": {\n    \"value\": 0\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"count\",\n    match=models.MatchValue(value=0),\n)\n```\n\n```typescript\n{\n    key: 'count',\n    match: {value: 0}    \n}\n```\n\n```rust\nCondition::matches(\"count\", 0)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.match;\n\nmatch(\"count\", 0);\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nMatch(\"count\", 0);\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewMatchInt(\"count\", 0)\n```\n\nThe simplest kind of condition is one that checks if the stored value equals the given one. If several values are stored, at least one of them should match the condition. You can apply it to [keyword](https://qdrant.tech/documentation/concepts/payload/#keyword), [integer](https://qdrant.tech/documentation/concepts/payload/#integer) and [bool](https://qdrant.tech/documentation/concepts/payload/#bool) payloads.\n\n### Match Any\n\n*Available as of v1.1.0*\n\nIn case you want to check if the stored value is one of multiple values, you can use the Match Any condition. Match Any works as a logical OR for the given values. It can also be described as a `IN` operator.\n\nYou can apply it to [keyword](https://qdrant.tech/documentation/concepts/payload/#keyword) and [integer](https://qdrant.tech/documentation/concepts/payload/#integer) payloads.\n\nExample:\n\n```json\n{\n  \"key\": \"color\",\n  \"match\": {\n    \"any\": [\"black\", \"yellow\"]\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"color\",",
      "index": 15,
      "token_count": 557,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 28901,
      "end_char": 30942
    },
    {
      "content": "tch\": {\n    \"any\": [\"black\", \"yellow\"]\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"color\",\n    match=models.MatchAny(any=[\"black\", \"yellow\"]),\n)\n```\n\n```typescript\n{\n    key: 'color',\n    match: {any: ['black', 'yellow']}    \n}\n```\n\n```rust\nCondition::matches(\"color\", vec![\"black\".to_string(), \"yellow\".to_string()])\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeywords;\n\nmatchKeywords(\"color\", List.of(\"black\", \"yellow\"));\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nMatch(\"color\", [\"black\", \"yellow\"]);\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewMatchKeywords(\"color\", \"black\", \"yellow\")\n```\n\nIn this example, the condition will be satisfied if the stored value is either `black` or `yellow`.\n\nIf the stored value is an array, it should have at least one value matching any of the given values. E.g. if the stored value is `[\"black\", \"green\"]`, the condition will be satisfied, because `\"black\"` is in `[\"black\", \"yellow\"]`.\n\n### Match Except\n\n*Available as of v1.2.0*\n\nIn case you want to check if the stored value is not one of multiple values, you can use the Match Except condition. Match Except works as a logical NOR for the given values. It can also be described as a `NOT IN` operator.\n\nYou can apply it to [keyword](https://qdrant.tech/documentation/concepts/payload/#keyword) and [integer](https://qdrant.tech/documentation/concepts/payload/#integer) payloads.\n\nExample:\n\n```json\n{\n  \"key\": \"color\",\n  \"match\": {\n    \"except\": [\"black\", \"yellow\"]\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"color\",\n    match=models.MatchExcept(**{\"except\": [\"black\", \"yellow\"]}),\n)\n```\n\n```typescript\n{\n    key: 'color',\n    match: {except: ['black', 'yellow']}\n}\n```\n\n```rust\nuse qdrant_client::qdrant::r#match::MatchValue;\n\nCondition::matches(\n    \"color\",\n    !MatchValue::from(vec![\"black\".to_string(), \"yellow\".to_string()]),\n)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchExceptKeywords;\n\nmatchExceptKeywords(\"color\", List.",
      "index": 16,
      "token_count": 539,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 30842,
      "end_char": 32868
    },
    {
      "content": "rt static io.qdrant.client.ConditionFactory.matchExceptKeywords;\n\nmatchExceptKeywords(\"color\", List.of(\"black\", \"yellow\"));\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nMatch(\"color\", [\"black\", \"yellow\"]);\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewMatchExcept(\"color\", \"black\", \"yellow\")\n```\n\nIn this example, the condition will be satisfied if the stored value is neither `black` nor `yellow`.\n\nIf the stored value is an array, it should have at least one value not matching any of the given values. E.g. if the stored value is `[\"black\", \"green\"]`, the condition will be satisfied, because `\"green\"` does not match `\"black\"` nor `\"yellow\"`.\n\n### Nested key\n\n*Available as of v1.1.0*\n\nPayloads being arbitrary JSON object, it is likely that you will need to filter on a nested field.\n\nFor convenience, we use a syntax similar to what can be found in the [Jq](https://stedolan.github.io/jq/manual/#Basicfilters) project.\n\nSuppose we have a set of points with the following payload:\n\n```json\n[\n  {\n    \"id\": 1,\n    \"country\": {\n      \"name\": \"Germany\",\n      \"cities\": [\n        {\n          \"name\": \"Berlin\",\n          \"population\": 3.7,\n          \"sightseeing\": [\"Brandenburg Gate\", \"Reichstag\"]\n        },\n        {\n          \"name\": \"Munich\",\n          \"population\": 1.5,\n          \"sightseeing\": [\"Marienplatz\", \"Olympiapark\"]\n        }\n      ]\n    }\n  },\n  {\n    \"id\": 2,\n    \"country\": {\n      \"name\": \"Japan\",\n      \"cities\": [\n        {\n          \"name\": \"Tokyo\",\n          \"population\": 9.3,\n          \"sightseeing\": [\"Tokyo Tower\", \"Tokyo Skytree\"]\n        },\n        {\n          \"name\": \"Osaka\",\n          \"population\": 2.7,\n          \"sightseeing\": [\"Osaka Castle\", \"Universal Studios Japan\"]\n        }\n      ]\n    }\n  }\n]\n```\n\nYou can search on a nested field using a dot notation.\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"should\": [\n            {\n                \"key\": \"country.name\",\n                \"match\": {\n                    \"value\": \"Germany\"",
      "index": 17,
      "token_count": 534,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 32768,
      "end_char": 34817
    },
    {
      "content": "\"key\": \"country.name\",\n                \"match\": {\n                    \"value\": \"Germany\"\n                }\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        should=[\n            models.FieldCondition(\n                key=\"country.name\", match=models.MatchValue(value=\"Germany\")\n            ),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    should: [\n      {\n        key: \"country.name\",\n        match: { value: \"Germany\" },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::should([\n            Condition::matches(\"country.name\", \"Germany\".to_string()),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addShould(matchKeyword(\"country.name\", \"Germany\"))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(collectionName: \"{collection_name}\", filter: MatchKeyword(\"country.name\", \"Germany\"));\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tShould: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"country.name\", \"Germany\"),\n\t\t},\n\t},\n})\n```",
      "index": 18,
      "token_count": 468,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 34717,
      "end_char": 36722
    },
    {
      "content": "ter{\n\t\tShould: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"country.name\", \"Germany\"),\n\t\t},\n\t},\n})\n```\n\nYou can also search through arrays by projecting inner values using the `[]` syntax.\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"should\": [\n            {\n                \"key\": \"country.cities[].population\",\n                \"range\": {\n                    \"gte\": 9.0,\n                }\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        should=[\n            models.FieldCondition(\n                key=\"country.cities[].population\",\n                range=models.Range(\n                    gt=None,\n                    gte=9.0,\n                    lt=None,\n                    lte=None,\n                ),\n            ),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    should: [\n      {\n        key: \"country.cities[].population\",\n        range: {\n          gt: null,\n          gte: 9.0,\n          lt: null,\n          lte: null,\n        },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, Range, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::should([\n            Condition::range(\n                \"country.cities[].population\",\n                Range {\n                    gte: Some(9.0),\n                    ..Default::default()\n                },\n            ),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.range;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.Range;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addShould(\n                        range(",
      "index": 19,
      "token_count": 431,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 36622,
      "end_char": 38636
    },
    {
      "content": "Filter.newBuilder()\n                    .addShould(\n                        range(\n                            \"country.cities[].population\",\n                            Range.newBuilder().setGte(9.0).build()))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: Range(\"country.cities[].population\", new Qdrant.Client.Grpc.Range { Gte = 9.0 })\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tShould: []*qdrant.Condition{\n\t\t\tqdrant.NewRange(\"country.cities[].population\", &qdrant.Range{\n\t\t\t\tGte: qdrant.PtrOf(9.0),\n\t\t\t}),\n\t\t},\n\t},\n})\n```\n\nThis query would only output the point with id 2 as only Japan has a city with population greater than 9.0.\n\nAnd the leaf nested field can also be an array.\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"should\": [\n            {\n                \"key\": \"country.cities[].sightseeing\",\n                \"match\": {\n                    \"value\": \"Osaka Castle\"\n                }\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        should=[\n            models.FieldCondition(\n                key=\"country.cities[].sightseeing\",\n                match=models.MatchValue(value=\"Osaka Castle\"),\n            ),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    should: [\n      {\n        key: \"country.cities[].sightseeing\",\n        match: { value: \"Osaka Castle\" },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};",
      "index": 20,
      "token_count": 497,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 38536,
      "end_char": 40579
    },
    {
      "content": "],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::should([\n            Condition::matches(\"country.cities[].sightseeing\", \"Osaka Castle\".to_string()),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addShould(matchKeyword(\"country.cities[].sightseeing\", \"Germany\"))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: MatchKeyword(\"country.cities[].sightseeing\", \"Germany\")\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tShould: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"country.cities[].sightseeing\", \"Germany\"),\n\t\t},\n\t},\n})\n```\n\nThis query would only output the point with id 2 as only Japan has a city with the “Osaka castke” as part of the sightseeing.\n\n### Nested object filter\n\n*Available as of v1.2.0*\n\nBy default, the conditions are taking into account the entire payload of a point.\n\nFor instance, given two points with the following payload:\n\n```json\n[\n  {\n    \"id\": 1,\n    \"dinosaur\": \"t-rex\",\n    \"diet\": [\n      { \"food\": \"leaves\", \"likes\": false},\n      { \"food\": \"meat\", \"likes\": true}\n    ]\n  },\n  {\n    \"id\": 2,\n    \"dinosaur\": \"diplodocus\",\n    \"diet\": [",
      "index": 21,
      "token_count": 526,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 40479,
      "end_char": 42491
    },
    {
      "content": "od\": \"meat\", \"likes\": true}\n    ]\n  },\n  {\n    \"id\": 2,\n    \"dinosaur\": \"diplodocus\",\n    \"diet\": [\n      { \"food\": \"leaves\", \"likes\": true},\n      { \"food\": \"meat\", \"likes\": false}\n    ]\n  }\n]\n```\n\nThe following query would match both points:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [\n            {\n                \"key\": \"diet[].food\",\n                  \"match\": {\n                    \"value\": \"meat\"\n                }\n            },\n            {\n                \"key\": \"diet[].likes\",\n                  \"match\": {\n                    \"value\": true\n                }\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.FieldCondition(\n                key=\"diet[].food\", match=models.MatchValue(value=\"meat\")\n            ),\n            models.FieldCondition(\n                key=\"diet[].likes\", match=models.MatchValue(value=True)\n            ),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        key: \"diet[].food\",\n        match: { value: \"meat\" },\n      },\n      {\n        key: \"diet[].likes\",\n        match: { value: true },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::must([\n            Condition::matches(\"diet[].food\", \"meat\".to_string()),\n            Condition::matches(\"diet[].likes\", true),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.match;\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.",
      "index": 22,
      "token_count": 486,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 42391,
      "end_char": 44405
    },
    {
      "content": "drant.client.grpc.Points.ScrollPoints;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addAllMust(\n                        List.of(matchKeyword(\"diet[].food\", \"meat\"), match(\"diet[].likes\", true)))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: MatchKeyword(\"diet[].food\", \"meat\") & Match(\"diet[].likes\", true)\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"diet[].food\", \"meat\"),\n\t\t\tqdrant.NewMatchBool(\"diet[].likes\", true),\n\t\t},\n\t},\n})\n```\n\nThis happens because both points are matching the two conditions:\n\n- the “t-rex” matches food=meat on `diet[1].food` and likes=true on `diet[1].likes`\n- the “diplodocus” matches food=meat on `diet[1].food` and likes=true on `diet[0].likes`\n\nTo retrieve only the points which are matching the conditions on an array element basis, that is the point with id 1 in this example, you would need to use a nested object filter.\n\nNested object filters allow arrays of objects to be queried independently of each other.\n\nIt is achieved by using the `nested` condition type formed by a payload key to focus on and a filter to apply.\n\nThe key should point to an array of objects and can be used with or without the bracket notation (“data” or “data\\[]”).\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [{",
      "index": 23,
      "token_count": 519,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 44305,
      "end_char": 46348
    },
    {
      "content": "”).\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [{\n            \"nested\": {\n                \"key\": \"diet\",\n                \"filter\":{\n                    \"must\": [\n                        {\n                            \"key\": \"food\",\n                            \"match\": {\n                                \"value\": \"meat\"\n                            }\n                        },\n                        {\n                            \"key\": \"likes\",\n                            \"match\": {\n                                \"value\": true\n                            }\n                        }\n                    ]\n                }\n            }\n        }]\n    }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.NestedCondition(\n                nested=models.Nested(\n                    key=\"diet\",\n                    filter=models.Filter(\n                        must=[\n                            models.FieldCondition(\n                                key=\"food\", match=models.MatchValue(value=\"meat\")\n                            ),\n                            models.FieldCondition(\n                                key=\"likes\", match=models.MatchValue(value=True)\n                            ),\n                        ]\n                    ),\n                )\n            )\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        nested: {\n          key: \"diet\",\n          filter: {\n            must: [\n              {\n                key: \"food\",\n                match: { value: \"meat\" },\n              },\n              {\n                key: \"likes\",\n                match: { value: true },\n              },\n            ],\n          },\n        },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, NestedCondition, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").",
      "index": 24,
      "token_count": 346,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 46248,
      "end_char": 48297
    },
    {
      "content": "n, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::must([NestedCondition {\n            key: \"diet\".to_string(),\n            filter: Some(Filter::must([\n                Condition::matches(\"food\", \"meat\".to_string()),\n                Condition::matches(\"likes\", true),\n            ])),\n        }\n        .into()])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.match;\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\nimport static io.qdrant.client.ConditionFactory.nested;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addMust(\n                        nested(\n                            \"diet\",\n                            Filter.newBuilder()\n                                .addAllMust(\n                                    List.of(\n                                        matchKeyword(\"food\", \"meat\"), match(\"likes\", true)))\n                                .build()))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: Nested(\"diet\", MatchKeyword(\"food\", \"meat\") & Match(\"likes\", true))\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewNestedFilter(\"diet\", &qdrant.Filter{\n\t\t\t\tMust: []*qdrant.Condition{\n\t\t\t\t\tqdrant.NewMatch(\"food\", \"meat\"),\n\t\t\t\t\tqdrant.",
      "index": 25,
      "token_count": 451,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 48197,
      "end_char": 50222
    },
    {
      "content": "\", &qdrant.Filter{\n\t\t\t\tMust: []*qdrant.Condition{\n\t\t\t\t\tqdrant.NewMatch(\"food\", \"meat\"),\n\t\t\t\t\tqdrant.NewMatchBool(\"likes\", true),\n\t\t\t\t},\n\t\t\t}),\n\t\t},\n\t},\n})\n```\n\nThe matching logic is modified to be applied at the level of an array element within the payload.\n\nNested filters work in the same way as if the nested filter was applied to a single element of the array at a time. Parent document is considered to match the condition if at least one element of the array matches the nested filter.\n\n**Limitations**\n\nThe `has_id` condition is not supported within the nested object filter. If you need it, place it in an adjacent `must` clause.\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n   \"filter\":{\n      \"must\":[\n         {\n            \"nested\":{\n               \"key\":\"diet\",\n               \"filter\":{\n                  \"must\":[\n                     {\n                        \"key\":\"food\",\n                        \"match\":{\n                           \"value\":\"meat\"\n                        }\n                     },\n                     {\n                        \"key\":\"likes\",\n                        \"match\":{\n                           \"value\":true\n                        }\n                     }\n                  ]\n               }\n            }\n         },\n         {\n            \"has_id\":[\n               1\n            ]\n         }\n      ]\n   }\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.NestedCondition(\n                nested=models.Nested(\n                    key=\"diet\",\n                    filter=models.Filter(\n                        must=[\n                            models.FieldCondition(\n                                key=\"food\", match=models.MatchValue(value=\"meat\")\n                            ),\n                            models.FieldCondition(\n                                key=\"likes\", match=models.MatchValue(value=True)\n                            ),\n                        ]\n                    ),",
      "index": 26,
      "token_count": 367,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 50122,
      "end_char": 52166
    },
    {
      "content": "chValue(value=True)\n                            ),\n                        ]\n                    ),\n                )\n            ),\n            models.HasIdCondition(has_id=[1]),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        nested: {\n          key: \"diet\",\n          filter: {\n            must: [\n              {\n                key: \"food\",\n                match: { value: \"meat\" },\n              },\n              {\n                key: \"likes\",\n                match: { value: true },\n              },\n            ],\n          },\n        },\n      },\n      {\n        has_id: [1],\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, NestedCondition, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\").filter(Filter::must([\n            NestedCondition {\n                key: \"diet\".to_string(),\n                filter: Some(Filter::must([\n                    Condition::matches(\"food\", \"meat\".to_string()),\n                    Condition::matches(\"likes\", true),\n                ])),\n            }\n            .into(),\n            Condition::has_id([1]),\n        ])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.hasId;\nimport static io.qdrant.client.ConditionFactory.match;\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\nimport static io.qdrant.client.ConditionFactory.nested;\nimport static io.qdrant.client.PointIdFactory.id;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addMust(\n                        nested(\n                            \"diet\",\n                            Filter.newBuilder()\n                                .addAllMust(",
      "index": 27,
      "token_count": 392,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 52066,
      "end_char": 54075
    },
    {
      "content": "diet\",\n                            Filter.newBuilder()\n                                .addAllMust(\n                                    List.of(\n                                        matchKeyword(\"food\", \"meat\"), match(\"likes\", true)))\n                                .build()))\n                    .addMust(hasId(id(1)))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: Nested(\"diet\", MatchKeyword(\"food\", \"meat\") & Match(\"likes\", true)) & HasId(1)\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewNestedFilter(\"diet\", &qdrant.Filter{\n\t\t\t\tMust: []*qdrant.Condition{\n\t\t\t\t\tqdrant.NewMatch(\"food\", \"meat\"),\n\t\t\t\t\tqdrant.NewMatchBool(\"likes\", true),\n\t\t\t\t},\n\t\t\t}),\n\t\t\tqdrant.NewHasID(qdrant.NewIDNum(1)),\n\t\t},\n\t},\n})\n```\n\n### Full Text Match\n\n*Available as of v0.10.0*\n\nA special case of the `match` condition is the `text` match condition. It allows you to search for a specific substring, token or phrase within the text field.\n\nExact texts that will match the condition depend on full-text index configuration. Configuration is defined during the index creation and describe at [full-text index](https://qdrant.tech/documentation/concepts/indexing/#full-text-index).\n\nIf there is no full-text index for the field, the condition will work as exact substring match.\n\n```json\n{\n  \"key\": \"description\",\n  \"match\": {\n    \"text\": \"good cheap\"\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"description\",\n    match=models.MatchText(text=\"good cheap\"),\n)\n```\n\n```typescript\n{\n    key: 'description',\n    match: {text: 'good cheap'}    \n}\n```\n\n```rust",
      "index": 28,
      "token_count": 509,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 53975,
      "end_char": 56019
    },
    {
      "content": ",\n)\n```\n\n```typescript\n{\n    key: 'description',\n    match: {text: 'good cheap'}    \n}\n```\n\n```rust\nuse qdrant_client::qdrant::Condition;\n\nCondition::matches_text(\"description\", \"good cheap\")\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchText;\n\nmatchText(\"description\", \"good cheap\");\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nMatchText(\"description\", \"good cheap\");\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewMatchText(\"description\", \"good cheap\")\n```\n\nIf the query has several words, then the condition will be satisfied only if all of them are present in the text.\n\n### Phrase Match\n\n*Available as of v1.15.0*\n\nA match `phrase` condition also leverages [full-text index](https://qdrant.tech/documentation/concepts/indexing/#full-text-index), to perform exact phrase comparisons. It allows you to search for a specific token phrase within the text field.\n\nFor example, the text `\"quick brown fox\"` will be matched by the query `\"brown fox\"`, but not by `\"fox brown\"`.\n\nThe index must be configured with `phrase_matching` parameter set to `true`. If the index has phrase matching disabled, phrase conditions won't match anything.\n\nIf there is no full-text index for the field, the condition will work as exact substring match.\n\n```json\n{\n  \"key\": \"description\",\n  \"match\": {\n    \"phrase\": \"brown fox\"\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"description\",\n    match=models.MatchPhrase(phrase=\"brown fox\"),\n)\n```\n\n```typescript\n{\n    key: 'description',\n    match: {phrase: 'brown fox'}\n}\n```\n\n```rust\nuse qdrant_client::qdrant::Condition;\n\nCondition::matches_phrase(\"description\", \"brown fox\")\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchPhrase;\n\nmatchPhrase(\"description\", \"brown fox\");\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nMatchPhrase(\"description\", \"brown fox\");\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewMatchPhrase(\"description\", \"brown fox\")\n```\n\n### Range\n\n```json\n{\n  \"key\": \"price\",\n  \"range\": {",
      "index": 29,
      "token_count": 518,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 55919,
      "end_char": 57967
    },
    {
      "content": "NewMatchPhrase(\"description\", \"brown fox\")\n```\n\n### Range\n\n```json\n{\n  \"key\": \"price\",\n  \"range\": {\n    \"gt\": null,\n    \"gte\": 100.0,\n    \"lt\": null,\n    \"lte\": 450.0\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"price\",\n    range=models.Range(\n        gt=None,\n        gte=100.0,\n        lt=None,\n        lte=450.0,\n    ),\n)\n```\n\n```typescript\n{\n    key: 'price',\n    range: {\n        gt: null,\n        gte: 100.0,\n        lt: null,\n        lte: 450.0    \n    }    \n}\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Range};\n\nCondition::range(\n    \"price\",\n    Range {\n        gt: None,\n        gte: Some(100.0),\n        lt: None,\n        lte: Some(450.0),\n    },\n)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.range;\n\nimport io.qdrant.client.grpc.Points.Range;\n\nrange(\"price\", Range.newBuilder().setGte(100.0).setLte(450).build());\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nRange(\"price\", new Qdrant.Client.Grpc.Range { Gte = 100.0, Lte = 450 });\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewRange(\"price\", &qdrant.Range{\n\tGte: qdrant.PtrOf(100.0),\n\tLte: qdrant.PtrOf(450.0),\n})\n```\n\nThe `range` condition sets the range of possible values for stored payload values. If several values are stored, at least one of them should match the condition.\n\nComparisons that can be used:\n\n- `gt` - greater than\n- `gte` - greater than or equal\n- `lt` - less than\n- `lte` - less than or equal\n\nCan be applied to [float](https://qdrant.tech/documentation/concepts/payload/#float) and [integer](https://qdrant.tech/documentation/concepts/payload/#integer) payloads.\n\n### Datetime Range\n\nThe datetime range is a unique range condition, used for [datetime](https://qdrant.tech/documentation/concepts/payload/#datetime) payloads, which supports RFC 3339 formats. You do not need to convert dates to UNIX timestaps. During comparison, timestamps are parsed and converted to UTC.\n\n*Available as of v1.8.0*\n\n```json\n{\n  \"key\": \"date\",\n  \"range\": {\n    \"gt\": \"2023-02-08T10:49:00Z\",\n    \"gte\": null,",
      "index": 30,
      "token_count": 647,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 57867,
      "end_char": 59912
    },
    {
      "content": "v1.8.0*\n\n```json\n{\n  \"key\": \"date\",\n  \"range\": {\n    \"gt\": \"2023-02-08T10:49:00Z\",\n    \"gte\": null,\n    \"lt\": null,\n    \"lte\": \"2024-01-31 10:14:31Z\"\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"date\",\n    range=models.DatetimeRange(\n        gt=\"2023-02-08T10:49:00Z\",\n        gte=None,\n        lt=None,\n        lte=\"2024-01-31T10:14:31Z\",\n    ),\n)\n```\n\n```typescript\n{\n    key: 'date',\n    range: {\n        gt: '2023-02-08T10:49:00Z',\n        gte: null,\n        lt: null,\n        lte: '2024-01-31T10:14:31Z'\n    }\n}\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, DatetimeRange, Timestamp};\n\nCondition::datetime_range(\n    \"date\",\n    DatetimeRange {\n        gt: Some(Timestamp::date_time(2023, 2, 8, 10, 49, 0).unwrap()),\n        gte: None,\n        lt: None,\n        lte: Some(Timestamp::date_time(2024, 1, 31, 10, 14, 31).unwrap()),\n    },\n)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.datetimeRange;\n\nimport com.google.protobuf.Timestamp;\nimport io.qdrant.client.grpc.Points.DatetimeRange;\nimport java.time.Instant;\n\nlong gt = Instant.parse(\"2023-02-08T10:49:00Z\").getEpochSecond();\nlong lte = Instant.parse(\"2024-01-31T10:14:31Z\").getEpochSecond();\n\ndatetimeRange(\"date\",\n    DatetimeRange.newBuilder()\n        .setGt(Timestamp.newBuilder().setSeconds(gt))\n        .setLte(Timestamp.newBuilder().setSeconds(lte))\n        .build());\n```\n\n```csharp\nusing Qdrant.Client.Grpc;\n\nConditions.DatetimeRange(\n    field: \"date\",\n    gt: new DateTime(2023, 2, 8, 10, 49, 0, DateTimeKind.Utc),\n    lte: new DateTime(2024, 1, 31, 10, 14, 31, DateTimeKind.Utc)\n);\n```\n\n```go\nimport (\n\t\"time\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n\t\"google.golang.org/protobuf/types/known/timestamppb\"\n)\n\nqdrant.NewDatetimeRange(\"date\", &qdrant.DatetimeRange{\n\tGt:  timestamppb.New(time.Date(2023, 2, 8, 10, 49, 0, 0, time.UTC)),\n\tLte: timestamppb.New(time.Date(2024, 1, 31, 10, 14, 31, 0, time.UTC)),\n})\n```\n\n### UUID Match\n\n*Available as of v1.11.0*\n\nMatching of UUID values works similarly to the regular `match` condition for strings.",
      "index": 31,
      "token_count": 784,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 59812,
      "end_char": 61853
    },
    {
      "content": "s of v1.11.0*\n\nMatching of UUID values works similarly to the regular `match` condition for strings. Functionally, it will work with `keyword` and `uuid` indexes exactly the same, but `uuid` index is more memory efficient.\n\n```json\n{\n  \"key\": \"uuid\",\n  \"match\": {\n    \"value\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"uuid\",\n    match=models.MatchValue(value=\"f47ac10b-58cc-4372-a567-0e02b2c3d479\"),\n)\n```\n\n```typescript\n{\n    key: 'uuid',\n    match: {value: 'f47ac10b-58cc-4372-a567-0e02b2c3d479'}    \n}\n```\n\n```rust\nCondition::matches(\"uuid\", \"f47ac10b-58cc-4372-a567-0e02b2c3d479\".to_string())\n```\n\n```java\nmatchKeyword(\"uuid\", \"f47ac10b-58cc-4372-a567-0e02b2c3d479\");\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nMatchKeyword(\"uuid\", \"f47ac10b-58cc-4372-a567-0e02b2c3d479\");\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewMatch(\"uuid\", \"f47ac10b-58cc-4372-a567-0e02b2c3d479\")\n```\n\n### Geo\n\n#### Geo Bounding Box\n\n```json\n{\n  \"key\": \"location\",\n  \"geo_bounding_box\": {\n    \"bottom_right\": {\n      \"lon\": 13.455868,\n      \"lat\": 52.495862\n    },\n    \"top_left\": {\n      \"lon\": 13.403683,\n      \"lat\": 52.520711\n    }\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"location\",\n    geo_bounding_box=models.GeoBoundingBox(\n        bottom_right=models.GeoPoint(\n            lon=13.455868,\n            lat=52.495862,\n        ),\n        top_left=models.GeoPoint(\n            lon=13.403683,\n            lat=52.520711,\n        ),\n    ),\n)\n```\n\n```typescript\n{\n    key: 'location',\n    geo_bounding_box: {\n        bottom_right: {\n            lon: 13.455868,\n            lat: 52.495862\n        },\n        top_left: {\n            lon: 13.403683,\n            lat: 52.520711\n        }\n    }\n}\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, GeoBoundingBox, GeoPoint};\n\nCondition::geo_bounding_box(\n    \"location\",\n    GeoBoundingBox {\n        bottom_right: Some(GeoPoint {\n            lon: 13.455868,\n            lat: 52.495862,\n        }),",
      "index": 32,
      "token_count": 813,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 61753,
      "end_char": 63777
    },
    {
      "content": "bottom_right: Some(GeoPoint {\n            lon: 13.455868,\n            lat: 52.495862,\n        }),\n        top_left: Some(GeoPoint {\n            lon: 13.403683,\n            lat: 52.520711,\n        }),\n    },\n)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.geoBoundingBox;\n\ngeoBoundingBox(\"location\", 52.520711, 13.403683, 52.495862, 13.455868);\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nGeoBoundingBox(\"location\", 52.520711, 13.403683, 52.495862, 13.455868);\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewGeoBoundingBox(\"location\", 52.520711, 13.403683, 52.495862, 13.455868)\n```\n\nIt matches with `location`s inside a rectangle with the coordinates of the upper left corner in `bottom_right` and the coordinates of the lower right corner in `top_left`.\n\n#### Geo Radius\n\n```json\n{\n  \"key\": \"location\",\n  \"geo_radius\": {\n    \"center\": {\n      \"lon\": 13.403683,\n      \"lat\": 52.520711\n    },\n    \"radius\": 1000.0\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"location\",\n    geo_radius=models.GeoRadius(\n        center=models.GeoPoint(\n            lon=13.403683,\n            lat=52.520711,\n        ),\n        radius=1000.0,\n    ),\n)\n```\n\n```typescript\n{\n    key: 'location',\n    geo_radius: {\n        center: {\n            lon: 13.403683,\n            lat: 52.520711\n        },\n        radius: 1000.0\n    }    \n}\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, GeoPoint, GeoRadius};\n\nCondition::geo_radius(\n    \"location\",\n    GeoRadius {\n        center: Some(GeoPoint {\n            lon: 13.403683,\n            lat: 52.520711,\n        }),\n        radius: 1000.0,\n    },\n)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.geoRadius;\n\ngeoRadius(\"location\", 52.520711, 13.403683, 1000.0f);\n```\n\n```csharp\nusing static Qdrant.Client.Grpc.Conditions;\n\nGeoRadius(\"location\", 52.520711, 13.403683, 1000.0f);\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewGeoRadius(\"location\", 52.520711, 13.403683, 1000.0)\n```",
      "index": 33,
      "token_count": 783,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 63677,
      "end_char": 65674
    },
    {
      "content": "ub.com/qdrant/go-client/qdrant\"\n\nqdrant.NewGeoRadius(\"location\", 52.520711, 13.403683, 1000.0)\n```\n\nIt matches with `location`s inside a circle with the `center` at the center and a radius of `radius` meters.\n\nIf several values are stored, at least one of them should match the condition. These conditions can only be applied to payloads that match the [geo-data format](https://qdrant.tech/documentation/concepts/payload/#geo).\n\n#### Geo Polygon\n\nGeo Polygons search is useful for when you want to find points inside an irregularly shaped area, for example a country boundary or a forest boundary. A polygon always has an exterior ring and may optionally include interior rings. A lake with an island would be an example of an interior ring. If you wanted to find points in the water but not on the island, you would make an interior ring for the island.\n\nWhen defining a ring, you must pick either a clockwise or counterclockwise ordering for your points. The first and last point of the polygon must be the same.\n\nCurrently, we only support unprojected global coordinates (decimal degrees longitude and latitude) and we are datum agnostic.\n\n```json\n\n{\n  \"key\": \"location\",\n  \"geo_polygon\": {\n    \"exterior\": {\n      \"points\": [\n        { \"lon\": -70.0, \"lat\": -70.0 },\n        { \"lon\": 60.0, \"lat\": -70.0 },\n        { \"lon\": 60.0, \"lat\": 60.0 },\n        { \"lon\": -70.0, \"lat\": 60.0 },\n        { \"lon\": -70.0, \"lat\": -70.0 }\n      ]\n    },\n    \"interiors\": [\n      {\n        \"points\": [\n          { \"lon\": -65.0, \"lat\": -65.0 },\n          { \"lon\": 0.0, \"lat\": -65.0 },\n          { \"lon\": 0.0, \"lat\": 0.0 },\n          { \"lon\": -65.0, \"lat\": 0.0 },\n          { \"lon\": -65.0, \"lat\": -65.0 }\n        ]\n      }\n    ]\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"location\",\n    geo_polygon=models.GeoPolygon(\n        exterior=models.GeoLineString(\n            points=[\n                models.GeoPoint(\n                    lon=-70.0,\n                    lat=-70.0,\n                ),\n                models.GeoPoint(\n                    lon=60.0,",
      "index": 34,
      "token_count": 590,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 65574,
      "end_char": 67623
    },
    {
      "content": "lat=-70.0,\n                ),\n                models.GeoPoint(\n                    lon=60.0,\n                    lat=-70.0,\n                ),\n                models.GeoPoint(\n                    lon=60.0,\n                    lat=60.0,\n                ),\n                models.GeoPoint(\n                    lon=-70.0,\n                    lat=60.0,\n                ),\n                models.GeoPoint(\n                    lon=-70.0,\n                    lat=-70.0,\n                ),\n            ]\n        ),\n        interiors=[\n            models.GeoLineString(\n                points=[\n                    models.GeoPoint(\n                        lon=-65.0,\n                        lat=-65.0,\n                    ),\n                    models.GeoPoint(\n                        lon=0.0,\n                        lat=-65.0,\n                    ),\n                    models.GeoPoint(\n                        lon=0.0,\n                        lat=0.0,\n                    ),\n                    models.GeoPoint(\n                        lon=-65.0,\n                        lat=0.0,\n                    ),\n                    models.GeoPoint(\n                        lon=-65.0,\n                        lat=-65.0,\n                    ),\n                ]\n            )\n        ],\n    ),\n)\n```\n\n```typescript\n{\n  key: \"location\",\n  geo_polygon: {\n    exterior: {\n      points: [\n        {\n          lon: -70.0,\n          lat: -70.0\n        },\n        {\n          lon: 60.0,\n          lat: -70.0\n        },\n        {\n          lon: 60.0,\n          lat: 60.0\n        },\n        {\n          lon: -70.0,\n          lat: 60.0\n        },\n        {\n          lon: -70.0,\n          lat: -70.0\n        }\n      ]\n    },\n    interiors: [\n      {\n        points: [\n          {\n            lon: -65.0,\n            lat: -65.0\n          },\n          {\n            lon: 0,\n            lat: -65.0\n          },\n          {\n            lon: 0,\n            lat: 0\n          },\n          {\n            lon: -65.0,\n            lat: 0\n          },\n          {",
      "index": 35,
      "token_count": 475,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 67523,
      "end_char": 69556
    },
    {
      "content": "lat: 0\n          },\n          {\n            lon: -65.0,\n            lat: 0\n          },\n          {\n            lon: -65.0,\n            lat: -65.0\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, GeoLineString, GeoPoint, GeoPolygon};\n\nCondition::geo_polygon(\n    \"location\",\n    GeoPolygon {\n        exterior: Some(GeoLineString {\n            points: vec![\n                GeoPoint {\n                    lon: -70.0,\n                    lat: -70.0,\n                },\n                GeoPoint {\n                    lon: 60.0,\n                    lat: -70.0,\n                },\n                GeoPoint {\n                    lon: 60.0,\n                    lat: 60.0,\n                },\n                GeoPoint {\n                    lon: -70.0,\n                    lat: 60.0,\n                },\n                GeoPoint {\n                    lon: -70.0,\n                    lat: -70.0,\n                },\n            ],\n        }),\n        interiors: vec![GeoLineString {\n            points: vec![\n                GeoPoint {\n                    lon: -65.0,\n                    lat: -65.0,\n                },\n                GeoPoint {\n                    lon: 0.0,\n                    lat: -65.0,\n                },\n                GeoPoint { lon: 0.0, lat: 0.0 },\n                GeoPoint {\n                    lon: -65.0,\n                    lat: 0.0,\n                },\n                GeoPoint {\n                    lon: -65.0,\n                    lat: -65.0,\n                },\n            ],\n        }],\n    },\n)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.geoPolygon;\n\nimport io.qdrant.client.grpc.Points.GeoLineString;\nimport io.qdrant.client.grpc.Points.GeoPoint;\n\ngeoPolygon(\n    \"location\",\n    GeoLineString.newBuilder()\n        .addAllPoints(\n            List.of(\n                GeoPoint.newBuilder().setLon(-70.0).setLat(-70.0).build(),\n                GeoPoint.newBuilder().setLon(60.0).setLat(-70.0).build(),\n                GeoPoint.newBuilder().setLon(60.0).setLat(60.",
      "index": 36,
      "token_count": 497,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 69456,
      "end_char": 71503
    },
    {
      "content": "().setLon(60.0).setLat(-70.0).build(),\n                GeoPoint.newBuilder().setLon(60.0).setLat(60.0).build(),\n                GeoPoint.newBuilder().setLon(-70.0).setLat(60.0).build(),\n                GeoPoint.newBuilder().setLon(-70.0).setLat(-70.0).build()))\n        .build(),\n    List.of(\n        GeoLineString.newBuilder()\n            .addAllPoints(\n                List.of(\n                    GeoPoint.newBuilder().setLon(-65.0).setLat(-65.0).build(),\n                    GeoPoint.newBuilder().setLon(0.0).setLat(-65.0).build(),\n                    GeoPoint.newBuilder().setLon(0.0).setLat(0.0).build(),\n                    GeoPoint.newBuilder().setLon(-65.0).setLat(0.0).build(),\n                    GeoPoint.newBuilder().setLon(-65.0).setLat(-65.0).build()))\n            .build()));\n```\n\n```csharp\nusing Qdrant.Client.Grpc;\nusing static Qdrant.Client.Grpc.Conditions;\n\nGeoPolygon(\n\tfield: \"location\",\n\texterior: new GeoLineString\n\t{\n\t\tPoints =\n\t\t{\n\t\t\tnew GeoPoint { Lat = -70.0, Lon = -70.0 },\n\t\t\tnew GeoPoint { Lat = 60.0, Lon = -70.0 },\n\t\t\tnew GeoPoint { Lat = 60.0, Lon = 60.0 },\n\t\t\tnew GeoPoint { Lat = -70.0, Lon = 60.0 },\n\t\t\tnew GeoPoint { Lat = -70.0, Lon = -70.0 }\n\t\t}\n\t},\n\tinteriors: [\n\t\tnew()\n\t\t{\n\t\t\tPoints =\n\t\t\t{\n\t\t\t\tnew GeoPoint { Lat = -65.0, Lon = -65.0 },\n\t\t\t\tnew GeoPoint { Lat = 0.0, Lon = -65.0 },\n\t\t\t\tnew GeoPoint { Lat = 0.0, Lon = 0.0 },\n\t\t\t\tnew GeoPoint { Lat = -65.0, Lon = 0.0 },\n\t\t\t\tnew GeoPoint { Lat = -65.0, Lon = -65.0 }\n\t\t\t}\n\t\t}\n\t]\n);\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewGeoPolygon(\"location\",\n\t&qdrant.GeoLineString{\n\t\tPoints: []*qdrant.GeoPoint{\n\t\t\t{Lat: -70, Lon: -70},\n\t\t\t{Lat: 60, Lon: -70},\n\t\t\t{Lat: 60, Lon: 60},\n\t\t\t{Lat: -70, Lon: 60},\n\t\t\t{Lat: -70, Lon: -70},\n\t\t},\n\t}, &qdrant.GeoLineString{\n\t\tPoints: []*qdrant.GeoPoint{\n\t\t\t{Lat: -65, Lon: -65},\n\t\t\t{Lat: 0, Lon: -65},\n\t\t\t{Lat: 0, Lon: 0},\n\t\t\t{Lat: -65, Lon: 0},\n\t\t\t{Lat: -65, Lon: -65},\n\t\t},\n\t})\n```",
      "index": 37,
      "token_count": 740,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 71403,
      "end_char": 73334
    },
    {
      "content": "t: 0, Lon: -65},\n\t\t\t{Lat: 0, Lon: 0},\n\t\t\t{Lat: -65, Lon: 0},\n\t\t\t{Lat: -65, Lon: -65},\n\t\t},\n\t})\n```\n\nA match is considered any point location inside or on the boundaries of the given polygon’s exterior but not inside any interiors.\n\nIf several location values are stored for a point, then any of them matching will include that point as a candidate in the resultset. These conditions can only be applied to payloads that match the [geo-data format](https://qdrant.tech/documentation/concepts/payload/#geo).\n\n### Values count\n\nIn addition to the direct value comparison, it is also possible to filter by the amount of values.\n\nFor example, given the data:\n\n```json\n[\n  { \"id\": 1, \"name\": \"product A\", \"comments\": [\"Very good!\", \"Excellent\"] },\n  { \"id\": 2, \"name\": \"product B\", \"comments\": [\"meh\", \"expected more\", \"ok\"] }\n]\n```\n\nWe can perform the search only among the items with more than two comments:\n\n```json\n{\n  \"key\": \"comments\",\n  \"values_count\": {\n    \"gt\": 2\n  }\n}\n```\n\n```python\nmodels.FieldCondition(\n    key=\"comments\",\n    values_count=models.ValuesCount(gt=2),\n)\n```\n\n```typescript\n{\n    key: 'comments',\n    values_count: {gt: 2}    \n}\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, ValuesCount};\n\nCondition::values_count(\n    \"comments\",\n    ValuesCount {\n        gt: Some(2),\n        ..Default::default()\n    },\n)\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.valuesCount;\n\nimport io.qdrant.client.grpc.Points.ValuesCount;\n\nvaluesCount(\"comments\", ValuesCount.newBuilder().setGt(2).build());\n```\n\n```csharp\nusing Qdrant.Client.Grpc;\nusing static Qdrant.Client.Grpc.Conditions;\n\nValuesCount(\"comments\", new ValuesCount { Gt = 2 });\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewValuesCount(\"comments\", &qdrant.ValuesCount{\n\tGt: qdrant.PtrOf(uint64(2)),\n})\n```\n\nThe result would be:\n\n```json\n[{ \"id\": 2, \"name\": \"product B\", \"comments\": [\"meh\", \"expected more\", \"ok\"] }]\n```\n\nIf stored value is not an array - it is assumed that the amount of values is equals to 1.\n\n### Is Empty",
      "index": 38,
      "token_count": 576,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 73234,
      "end_char": 75270
    },
    {
      "content": "ored value is not an array - it is assumed that the amount of values is equals to 1.\n\n### Is Empty\n\nSometimes it is also useful to filter out records that are missing some value. The `IsEmpty` condition may help you with that:\n\n```json\n{\n  \"is_empty\": {\n    \"key\": \"reports\"\n  }\n}\n```\n\n```python\nmodels.IsEmptyCondition(\n    is_empty=models.PayloadField(key=\"reports\"),\n)\n```\n\n```typescript\n{\n  is_empty: {\n    key: \"reports\"\n  }\n}\n```\n\n```rust\nuse qdrant_client::qdrant::Condition;\n\nCondition::is_empty(\"reports\")\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.isEmpty;\n\nisEmpty(\"reports\");\n```\n\n```csharp\nusing Qdrant.Client.Grpc;\nusing static Qdrant.Client.Grpc.Conditions;\n\nIsEmpty(\"reports\");\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewIsEmpty(\"reports\")\n```\n\nThis condition will match all records where the field `reports` either does not exist, or has `null` or `[]` value.\n\nThe **IsEmpty** is often useful together with the logical negation **must\\_not**. In this case all non-empty values will be selected.\n\n### Is Null\n\nIt is not possible to test for `NULL` values with the **match** condition. We have to use `IsNull` condition instead:\n\n```json\n{\n    \"is_null\": {\n        \"key\": \"reports\"\n    }\n}\n```\n\n```python\nmodels.IsNullCondition(\n    is_null=models.PayloadField(key=\"reports\"),\n)\n```\n\n```typescript\n{\n  is_null: {\n    key: \"reports\"\n  }\n}\n```\n\n```rust\nuse qdrant_client::qdrant::Condition;\n\nCondition::is_null(\"reports\")\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.isNull;\n\nisNull(\"reports\");\n```\n\n```csharp\nusing Qdrant.Client.Grpc;\nusing static Qdrant.Client.Grpc.Conditions;\n\nIsNull(\"reports\");\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.NewIsNull(\"reports\")\n```\n\nThis condition will match all records where the field `reports` exists and has `NULL` value.\n\n### Has id\n\nThis type of query is not related to payload, but can be very useful in some situations.",
      "index": 39,
      "token_count": 506,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 75170,
      "end_char": 77123
    },
    {
      "content": "### Has id\n\nThis type of query is not related to payload, but can be very useful in some situations. For example, the user could mark some specific search results as irrelevant, or we want to search only among the specified points.\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [\n            { \"has_id\": [1,3,5,7,9,11] }\n        ]\n    }\n    ...\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.HasIdCondition(has_id=[1, 3, 5, 7, 9, 11]),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        has_id: [1, 3, 5, 7, 9, 11],\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n    \nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\")\n            .filter(Filter::must([Condition::has_id([1, 3, 5, 7, 9, 11])])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.hasId;\nimport static io.qdrant.client.PointIdFactory.id;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addMust(hasId(List.of(id(1), id(3), id(5), id(7), id(9), id(11))))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(collectionName: \"{collection_name}\", filter: HasId([1, 3, 5, 7, 9, 11]));\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})",
      "index": 40,
      "token_count": 573,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 77023,
      "end_char": 79069
    },
    {
      "content": "ent/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewHasID(\n\t\t\t\tqdrant.NewIDNum(1),\n\t\t\t\tqdrant.NewIDNum(3),\n\t\t\t\tqdrant.NewIDNum(5),\n\t\t\t\tqdrant.NewIDNum(7),\n\t\t\t\tqdrant.NewIDNum(9),\n\t\t\t\tqdrant.NewIDNum(11),\n\t\t\t),\n\t\t},\n\t},\n})\n```\n\nFiltered points would be:\n\n```json\n[\n  { \"id\": 1, \"city\": \"London\", \"color\": \"green\" },\n  { \"id\": 3, \"city\": \"London\", \"color\": \"blue\" },\n  { \"id\": 5, \"city\": \"Moscow\", \"color\": \"green\" }\n]\n```\n\n### Has vector\n\n*Available as of v1.13.0*\n\nThis condition enables filtering by the presence of a given named vector on a point.\n\nFor example, if we have two named vector in our collection.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n        \"image\": {\n            \"size\": 4,\n            \"distance\": \"Dot\"\n        },\n        \"text\": {\n            \"size\": 8,\n            \"distance\": \"Cosine\"\n        }\n    },\n    \"sparse_vectors\": {\n        \"sparse-image\": {},\n        \"sparse-text\": {},\n    },\n}\n```\n\nSome points in the collection might have all vectors, some might have only a subset of them.\n\nIf your collection does not have named vectors, use an empty (`\"\"`) name.\n\nThis is how you can search for points which have the dense `image` vector defined:\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [\n            { \"has_vector\": \"image\" }\n        ]\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.HasVectorCondition(has_vector=\"image\"),\n        ],\n    ),\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        has_vector: \"image\",\n      },\n    ],\n  },\n});\n```\n\n```rust",
      "index": 41,
      "token_count": 564,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 78969,
      "end_char": 80977
    },
    {
      "content": "filter: {\n    must: [\n      {\n        has_vector: \"image\",\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n    \nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\")\n            .filter(Filter::must([Condition::has_vector(\"image\")])),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.ConditionFactory.hasVector;\nimport static io.qdrant.client.PointIdFactory.id;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(\n                Filter.newBuilder()\n                    .addMust(hasVector(\"image\"))\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(collectionName: \"{collection_name}\", filter: HasVector(\"image\"));\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewHasVector(\n        \"image\",\n\t\t\t),\n\t\t},\n\t},\n})\n```\n\n##### Was this page useful?\n\nYes No\n\nThank you for your feedback! 🙏\n\nWe are sorry to hear that. 😔 You can [edit](https:/github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/filtering.md) this page on GitHub, or [create](https://github.com/qdrant/landing_page/issues/new/choose) a GitHub issue.\n\nOn this page:\n\n- [Filtering](#filtering.md)\n\n  - [Related Content](#related-content.md)\n\n  - [Filtering clauses](#filtering-clauses.md)\n\n    - [Must](#must.md)",
      "index": 42,
      "token_count": 529,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 80877,
      "end_char": 82918
    },
    {
      "content": "ntent](#related-content.md)\n\n  - [Filtering clauses](#filtering-clauses.md)\n\n    - [Must](#must.md)\n    - [Should](#should.md)\n    - [Must Not](#must-not.md)\n    - [Clauses combination](#clauses-combination.md)\n\n  - [Filtering conditions](#filtering-conditions.md)\n\n    - [Match](#match.md)\n    - [Match Any](#match-any.md)\n    - [Match Except](#match-except.md)\n    - [Nested key](#nested-key.md)\n    - [Nested object filter](#nested-object-filter.md)\n    - [Full Text Match](#full-text-match.md)\n    - [Phrase Match](#phrase-match.md)\n    - [Range](#range.md)\n    - [Datetime Range](#datetime-range.md)\n    - [UUID Match](#uuid-match.md)\n    - [Geo](#geo.md)\n    - [Values count](#values-count.md)\n    - [Is Empty](#is-empty.md)\n    - [Is Null](#is-null.md)\n    - [Has id](#has-id.md)\n    - [Has vector](#has-vector.md)\n\n* [Edit on Github](https://github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/filtering.md)\n* [Create an issue](https://github.com/qdrant/landing_page/issues/new/choose)\n\n#### Ready to get started with Qdrant?\n\n[Start Free](https://qdrant.to/cloud/)\n\n© 2025 Qdrant.\n\n[Terms](https://qdrant.tech/legal/terms_and_conditions/) [Privacy Policy](https://qdrant.tech/legal/privacy-policy/) [Impressum](https://qdrant.tech/legal/impressum/)",
      "index": 43,
      "token_count": 386,
      "metadata": {
        "title": "_documentation_concepts_filtering_",
        "source": "qdrant_documentation\\documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_filtering",
        "category": "concepts",
        "file_path": "documentation_concepts_filtering\\_documentation_concepts_filtering_.md",
        "file_name": "_documentation_concepts_filtering_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.738352",
        "total_chunks": 44
      },
      "start_char": 82818,
      "end_char": 84866
    }
  ]
}