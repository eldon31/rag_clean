{
  "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\qdrant_ecosystem\\qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
  "source_repo": "qdrant_documentation",
  "total_chunks": 40,
  "chunks": [
    {
      "content": "Points - Qdrant\n\n[](https://qdrant.tech/)\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\nSearch\n\n[Log in](https://cloud.qdrant.io/login) [Start Free](https://cloud.qdrant.io/signup)\n\nSearch\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.",
      "index": 0,
      "token_count": 526,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 0,
      "end_char": 2017
    },
    {
      "content": "[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.",
      "index": 1,
      "token_count": 507,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 1917,
      "end_char": 3921
    },
    {
      "content": "ocumentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)",
      "index": 2,
      "token_count": 472,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 3821,
      "end_char": 5836
    },
    {
      "content": "fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)",
      "index": 3,
      "token_count": 514,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 5736,
      "end_char": 7784
    },
    {
      "content": "n/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.",
      "index": 4,
      "token_count": 501,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 7684,
      "end_char": 9681
    },
    {
      "content": "nced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n- [Documentation](https://qdrant.tech/documentation/)\n-\n- [Concepts](https://qdrant.tech/documentation/concepts/)\n-\n- Points\n\n# Points\n\nThe points are the central entity that Qdrant operates with. A point is a record consisting of a [vector](https://qdrant.",
      "index": 5,
      "token_count": 475,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 9581,
      "end_char": 11570
    },
    {
      "content": "ntral entity that Qdrant operates with. A point is a record consisting of a [vector](https://qdrant.tech/documentation/concepts/vectors/) and an optional [payload](https://qdrant.tech/documentation/concepts/payload/).\n\nIt looks like this:\n\n```json\n// This is a simple point\n{\n    \"id\": 129,\n    \"vector\": [0.1, 0.2, 0.3, 0.4],\n    \"payload\": {\"color\": \"red\"},\n}\n```\n\nYou can search among the points grouped in one [collection](https://qdrant.tech/documentation/concepts/collections/) based on vector similarity. This procedure is described in more detail in the [search](https://qdrant.tech/documentation/concepts/search/) and [filtering](https://qdrant.tech/documentation/concepts/filtering/) sections.\n\nThis section explains how to create and manage vectors.\n\nAny point modification operation is asynchronous and takes place in 2 steps. At the first stage, the operation is written to the Write-ahead-log.\n\nAfter this moment, the service will not lose the data, even if the machine loses power supply.\n\n## Point IDs\n\nQdrant supports using both `64-bit unsigned integers` and `UUID` as identifiers for points.\n\nExamples of UUID string representations:\n\n- simple: `936DA01F9ABD4d9d80C702AF85C822A8`\n- hyphenated: `550e8400-e29b-41d4-a716-446655440000`\n- urn: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n\nThat means that in every request UUID string could be used instead of numerical id. Example:\n\n```http\nPUT /collections/{collection_name}/points\n{\n    \"points\": [\n        {\n            \"id\": \"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\",\n            \"payload\": {\"color\": \"red\"},\n            \"vector\": [0.9, 0.1, 0.1]\n        }\n    ]\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.upsert(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointStruct(\n            id=\"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\",\n            payload={\n                \"color\": \"red\",\n            },\n            vector=[0.9, 0.1, 0.1],\n        ),\n    ],\n)\n```\n\n```typescript",
      "index": 6,
      "token_count": 631,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 11470,
      "end_char": 13516
    },
    {
      "content": "\": \"red\",\n            },\n            vector=[0.9, 0.1, 0.1],\n        ),\n    ],\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.upsert(\"{collection_name}\", {\n  points: [\n    {\n      id: \"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\",\n      payload: {\n        color: \"red\",\n      },\n      vector: [0.9, 0.1, 0.1],\n    },\n  ],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{PointStruct, UpsertPointsBuilder};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .upsert_points(\n        UpsertPointsBuilder::new(\n            \"{collection_name}\",\n            vec![PointStruct::new(\n                \"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\",\n                vec![0.9, 0.1, 0.1],\n                [(\"color\", \"Red\".into())],\n            )],\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\nimport static io.qdrant.client.VectorsFactory.vectors;\n\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.PointStruct;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .upsertAsync(\n        \"{collection_name}\",\n        List.of(\n            PointStruct.newBuilder()\n                .setId(id(UUID.fromString(\"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\")))\n                .setVectors(vectors(0.05f, 0.61f, 0.76f, 0.74f))\n                .putAllPayload(Map.of(\"color\", value(\"Red\")))\n                .build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpsertAsync(\n\tcollectionName: \"{collection_name}\",\n\tpoints: new List<PointStruct>\n\t{\n\t\tnew()\n\t\t{\n\t\t\tId = Guid.Parse(\"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\"),",
      "index": 7,
      "token_count": 670,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 13416,
      "end_char": 15461
    },
    {
      "content": "s: new List<PointStruct>\n\t{\n\t\tnew()\n\t\t{\n\t\t\tId = Guid.Parse(\"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\"),\n\t\t\tVectors = new[] { 0.05f, 0.61f, 0.76f, 0.74f },\n\t\t\tPayload = { [\"color\"] = \"Red\" }\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Upsert(context.Background(), &qdrant.UpsertPoints{\n\tCollectionName: \"{collection_name}\",\n\tPoints: []*qdrant.PointStruct{\n\t\t{\n\t\t\tId:      qdrant.NewID(\"5c56c793-69f3-4fbf-87e6-c4bf54c28c26\"),\n\t\t\tVectors: qdrant.NewVectors(0.05, 0.61, 0.76, 0.74),\n\t\t\tPayload: qdrant.NewValueMap(map[string]any{\"color\": \"Red\"}),\n\t\t},\n\t},\n})\n```\n\nand\n\n```http\nPUT /collections/{collection_name}/points\n{\n    \"points\": [\n        {\n            \"id\": 1,\n            \"payload\": {\"color\": \"red\"},\n            \"vector\": [0.9, 0.1, 0.1]\n        }\n    ]\n}\n```\n\n```python\nclient.upsert(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointStruct(\n            id=1,\n            payload={\n                \"color\": \"red\",\n            },\n            vector=[0.9, 0.1, 0.1],\n        ),\n    ],\n)\n```\n\n```typescript\nclient.upsert(\"{collection_name}\", {\n  points: [\n    {\n      id: 1,\n      payload: {\n        color: \"red\",\n      },\n      vector: [0.9, 0.1, 0.1],\n    },\n  ],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{PointStruct, UpsertPointsBuilder};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .upsert_points(\n        UpsertPointsBuilder::new(\n            \"{collection_name}\",\n            vec![PointStruct::new(\n                1,\n                vec![0.9, 0.1, 0.1],\n                [(\"color\", \"Red\".into())],\n            )],\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\nimport static io.qdrant.client.VectorsFactory.vectors;\n\nimport io.qdrant.client.QdrantClient;",
      "index": 8,
      "token_count": 682,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 15361,
      "end_char": 17405
    },
    {
      "content": "alue;\nimport static io.qdrant.client.VectorsFactory.vectors;\n\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.PointStruct;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .upsertAsync(\n        \"{collection_name}\",\n        List.of(\n            PointStruct.newBuilder()\n                .setId(id(1))\n                .setVectors(vectors(0.05f, 0.61f, 0.76f, 0.74f))\n                .putAllPayload(Map.of(\"color\", value(\"Red\")))\n                .build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpsertAsync(\n\tcollectionName: \"{collection_name}\",\n\tpoints: new List<PointStruct>\n\t{\n\t\tnew()\n\t\t{\n\t\t\tId = 1,\n\t\t\tVectors = new[] { 0.05f, 0.61f, 0.76f, 0.74f },\n\t\t\tPayload = { [\"color\"] = \"Red\" }\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Upsert(context.Background(), &qdrant.UpsertPoints{\n\tCollectionName: \"{collection_name}\",\n\tPoints: []*qdrant.PointStruct{\n\t\t{\n\t\t\tId:      qdrant.NewIDNum(1),\n\t\t\tVectors: qdrant.NewVectors(0.05, 0.61, 0.76, 0.74),\n\t\t\tPayload: qdrant.NewValueMap(map[string]any{\"color\": \"Red\"}),\n\t\t},\n\t},\n})\n```\n\nare both possible.\n\n## Vectors\n\nEach point in qdrant may have one or more vectors. Vectors are the central component of the Qdrant architecture, qdrant relies on different types of vectors to provide different types of data exploration and search.\n\nHere is a list of supported vector types:\n\n|                |                                                                                                                                           |\n| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |",
      "index": 9,
      "token_count": 533,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 17305,
      "end_char": 19308
    },
    {
      "content": "------------------------------------------------------------------------------------------------- |\n| Dense Vectors  | A regular vectors, generated by majority of the embedding models.                                                                         |\n| Sparse Vectors | Vectors with no fixed length, but only a few non-zero elements. Useful for exact token match and collaborative filtering recommendations. |\n| MultiVectors   | Matrices of numbers with fixed length but variable height. Usually obtained from late interaction models like ColBERT.                    |\n\nIt is possible to attach more than one type of vector to a single point. In Qdrant we call these Named Vectors.\n\nRead more about vector types, how they are stored and optimized in the [vectors](https://qdrant.tech/documentation/concepts/vectors/) section.\n\n## Upload points\n\nTo optimize performance, Qdrant supports batch loading of points. I.e., you can load several points into the service in one API call. Batching allows you to minimize the overhead of creating a network connection.\n\nThe Qdrant API supports two ways of creating batches - record-oriented and column-oriented. Internally, these options do not differ and are made only for the convenience of interaction.\n\nCreate points with batch:\n\n```http\nPUT /collections/{collection_name}/points\n{\n    \"batch\": {\n        \"ids\": [1, 2, 3],\n        \"payloads\": [\n            {\"color\": \"red\"},\n            {\"color\": \"green\"},\n            {\"color\": \"blue\"}\n        ],\n        \"vectors\": [\n            [0.9, 0.1, 0.1],\n            [0.1, 0.9, 0.1],\n            [0.1, 0.1, 0.9]\n        ]\n    }\n}\n```\n\n```python\nclient.upsert(\n    collection_name=\"{collection_name}\",\n    points=models.Batch(\n        ids=[1, 2, 3],\n        payloads=[\n            {\"color\": \"red\"},\n            {\"color\": \"green\"},\n            {\"color\": \"blue\"},\n        ],\n        vectors=[\n            [0.9, 0.1, 0.1],\n            [0.1, 0.9, 0.1],\n            [0.1, 0.1, 0.9],\n        ],\n    ),\n)\n```\n\n```typescript\nclient.upsert(\"{collection_name}\", {",
      "index": 10,
      "token_count": 475,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 19208,
      "end_char": 21255
    },
    {
      "content": "[0.1, 0.1, 0.9],\n        ],\n    ),\n)\n```\n\n```typescript\nclient.upsert(\"{collection_name}\", {\n  batch: {\n    ids: [1, 2, 3],\n    payloads: [{ color: \"red\" }, { color: \"green\" }, { color: \"blue\" }],\n    vectors: [\n      [0.9, 0.1, 0.1],\n      [0.1, 0.9, 0.1],\n      [0.1, 0.1, 0.9],\n    ],\n  },\n});\n```\n\nor record-oriented equivalent:\n\n```http\nPUT /collections/{collection_name}/points\n{\n    \"points\": [\n        {\n            \"id\": 1,\n            \"payload\": {\"color\": \"red\"},\n            \"vector\": [0.9, 0.1, 0.1]\n        },\n        {\n            \"id\": 2,\n            \"payload\": {\"color\": \"green\"},\n            \"vector\": [0.1, 0.9, 0.1]\n        },\n        {\n            \"id\": 3,\n            \"payload\": {\"color\": \"blue\"},\n            \"vector\": [0.1, 0.1, 0.9]\n        }\n    ]\n}\n```\n\n```python\nclient.upsert(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointStruct(\n            id=1,\n            payload={\n                \"color\": \"red\",\n            },\n            vector=[0.9, 0.1, 0.1],\n        ),\n        models.PointStruct(\n            id=2,\n            payload={\n                \"color\": \"green\",\n            },\n            vector=[0.1, 0.9, 0.1],\n        ),\n        models.PointStruct(\n            id=3,\n            payload={\n                \"color\": \"blue\",\n            },\n            vector=[0.1, 0.1, 0.9],\n        ),\n    ],\n)\n```\n\n```typescript\nclient.upsert(\"{collection_name}\", {\n  points: [\n    {\n      id: 1,\n      payload: { color: \"red\" },\n      vector: [0.9, 0.1, 0.1],\n    },\n    {\n      id: 2,\n      payload: { color: \"green\" },\n      vector: [0.1, 0.9, 0.1],\n    },\n    {\n      id: 3,\n      payload: { color: \"blue\" },\n      vector: [0.1, 0.1, 0.9],\n    },\n  ],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{PointStruct, UpsertPointsBuilder};\n\nclient\n    .upsert_points(\n        UpsertPointsBuilder::new(\n            \"{collection_name}\",\n            vec![\n                PointStruct::new(1, vec![0.9, 0.1, 0.1], [(\"city\", \"red\".into())]),\n                PointStruct::new(2, vec![0.1, 0.9, 0.",
      "index": 11,
      "token_count": 660,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 21155,
      "end_char": 23195
    },
    {
      "content": "ec![0.9, 0.1, 0.1], [(\"city\", \"red\".into())]),\n                PointStruct::new(2, vec![0.1, 0.9, 0.1], [(\"city\", \"green\".into())]),\n                PointStruct::new(3, vec![0.1, 0.1, 0.9], [(\"city\", \"blue\".into())]),\n            ],\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\nimport static io.qdrant.client.VectorsFactory.vectors;\n\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.PointStruct;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .upsertAsync(\n        \"{collection_name}\",\n        List.of(\n            PointStruct.newBuilder()\n                .setId(id(1))\n                .setVectors(vectors(0.9f, 0.1f, 0.1f))\n                .putAllPayload(Map.of(\"color\", value(\"red\")))\n                .build(),\n            PointStruct.newBuilder()\n                .setId(id(2))\n                .setVectors(vectors(0.1f, 0.9f, 0.1f))\n                .putAllPayload(Map.of(\"color\", value(\"green\")))\n                .build(),\n            PointStruct.newBuilder()\n                .setId(id(3))\n                .setVectors(vectors(0.1f, 0.1f, 0.9f))\n                .putAllPayload(Map.of(\"color\", value(\"blue\")))\n                .build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpsertAsync(\n\tcollectionName: \"{collection_name}\",\n\tpoints: new List<PointStruct>\n\t{\n\t\tnew()\n\t\t{\n\t\t\tId = 1,\n\t\t\tVectors = new[] { 0.9f, 0.1f, 0.1f },\n\t\t\tPayload = { [\"color\"] = \"red\" }\n\t\t},\n\t\tnew()\n\t\t{\n\t\t\tId = 2,\n\t\t\tVectors = new[] { 0.1f, 0.9f, 0.1f },\n\t\t\tPayload = { [\"color\"] = \"green\" }\n\t\t},\n\t\tnew()\n\t\t{\n\t\t\tId = 3,\n\t\t\tVectors = new[] { 0.1f, 0.1f, 0.9f },\n\t\t\tPayload = { [\"color\"] = \"blue\" }\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.",
      "index": 12,
      "token_count": 643,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 23095,
      "end_char": 25122
    },
    {
      "content": ".1f, 0.9f },\n\t\t\tPayload = { [\"color\"] = \"blue\" }\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Upsert(context.Background(), &qdrant.UpsertPoints{\n\tCollectionName: \"{collection_name}\",\n\tPoints: []*qdrant.PointStruct{\n\t\t{\n\t\t\tId:      qdrant.NewIDNum(1),\n\t\t\tVectors: qdrant.NewVectors(0.9, 0.1, 0.1),\n\t\t\tPayload: qdrant.NewValueMap(map[string]any{\"color\": \"red\"}),\n\t\t},\n\t\t{\n\t\t\tId:      qdrant.NewIDNum(2),\n\t\t\tVectors: qdrant.NewVectors(0.1, 0.9, 0.1),\n\t\t\tPayload: qdrant.NewValueMap(map[string]any{\"color\": \"green\"}),\n\t\t},\n\t\t{\n\t\t\tId:      qdrant.NewIDNum(3),\n\t\t\tVectors: qdrant.NewVectors(0.1, 0.1, 0.9),\n\t\t\tPayload: qdrant.NewValueMap(map[string]any{\"color\": \"blue\"}),\n\t\t},\n\t},\n})\n```\n\nThe Python client has additional features for loading points, which include:\n\n- Parallelization\n- A retry mechanism\n- Lazy batching support\n\nFor example, you can read your data directly from hard drives, to avoid storing all data in RAM. You can use these features with the `upload_collection` and `upload_points` methods. Similar to the basic upsert API, these methods support both record-oriented and column-oriented formats.\n\n`upload_points` is available as of v1.7.1. It has replaced `upload_records` which is now deprecated.\n\nColumn-oriented format:\n\n```python\nclient.upload_collection(\n    collection_name=\"{collection_name}\",\n    ids=[1, 2],\n    payload=[\n        {\"color\": \"red\"},\n        {\"color\": \"green\"},\n    ],\n    vectors=[\n        [0.9, 0.1, 0.1],\n        [0.1, 0.9, 0.1],\n    ],\n    parallel=4,\n    max_retries=3,\n)\n```\n\nIf `ids` are not provided, Qdrant Client will generate them automatically as random UUIDs.\n\nRecord-oriented format:\n\n```python\nclient.upload_points(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointStruct(\n            id=1,\n            payload={\n                \"color\": \"red\",\n            },\n            vector=[0.9, 0.1, 0.1],\n        ),\n        models.PointStruct(",
      "index": 13,
      "token_count": 606,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 25022,
      "end_char": 27065
    },
    {
      "content": "\": \"red\",\n            },\n            vector=[0.9, 0.1, 0.1],\n        ),\n        models.PointStruct(\n            id=2,\n            payload={\n                \"color\": \"green\",\n            },\n            vector=[0.1, 0.9, 0.1],\n        ),\n    ],\n    parallel=4,\n    max_retries=3,\n)\n```\n\nAll APIs in Qdrant, including point loading, are idempotent. It means that executing the same method several times in a row is equivalent to a single execution.\n\nIn this case, it means that points with the same id will be overwritten when re-uploaded.\n\nIdempotence property is useful if you use, for example, a message queue that doesn’t provide an exactly-ones guarantee. Even with such a system, Qdrant ensures data consistency.\n\n[*Available as of v0.10.0*](#create-vector-name.md)\n\nIf the collection was created with multiple vectors, each vector data can be provided using the vector’s name:\n\n```http\nPUT /collections/{collection_name}/points\n{\n    \"points\": [\n        {\n            \"id\": 1,\n            \"vector\": {\n                \"image\": [0.9, 0.1, 0.1, 0.2],\n                \"text\": [0.4, 0.7, 0.1, 0.8, 0.1, 0.1, 0.9, 0.2]\n            }\n        },\n        {\n            \"id\": 2,\n            \"vector\": {\n                \"image\": [0.2, 0.1, 0.3, 0.9],\n                \"text\": [0.5, 0.2, 0.7, 0.4, 0.7, 0.2, 0.3, 0.9]\n            }\n        }\n    ]\n}\n```\n\n```python\nclient.upsert(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointStruct(\n            id=1,\n            vector={\n                \"image\": [0.9, 0.1, 0.1, 0.2],\n                \"text\": [0.4, 0.7, 0.1, 0.8, 0.1, 0.1, 0.9, 0.2],\n            },\n        ),\n        models.PointStruct(\n            id=2,\n            vector={\n                \"image\": [0.2, 0.1, 0.3, 0.9],\n                \"text\": [0.5, 0.2, 0.7, 0.4, 0.7, 0.2, 0.3, 0.9],\n            },\n        ),\n    ],\n)\n```\n\n```typescript\nclient.upsert(\"{collection_name}\", {\n  points: [\n    {\n      id: 1,\n      vector: {\n        image: [0.9, 0.1, 0.1, 0.2],\n        text: [0.4, 0.7, 0.1, 0.8, 0.1, 0.1, 0.9, 0.2],",
      "index": 14,
      "token_count": 697,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 26965,
      "end_char": 29007
    },
    {
      "content": "tor: {\n        image: [0.9, 0.1, 0.1, 0.2],\n        text: [0.4, 0.7, 0.1, 0.8, 0.1, 0.1, 0.9, 0.2],\n      },\n    },\n    {\n      id: 2,\n      vector: {\n        image: [0.2, 0.1, 0.3, 0.9],\n        text: [0.5, 0.2, 0.7, 0.4, 0.7, 0.2, 0.3, 0.9],\n      },\n    },\n  ],\n});\n```\n\n```rust\nuse std::collections::HashMap;\n\nuse qdrant_client::qdrant::{PointStruct, UpsertPointsBuilder};\nuse qdrant_client::Payload;\n\nclient\n    .upsert_points(\n        UpsertPointsBuilder::new(\n            \"{collection_name}\",\n            vec![\n                PointStruct::new(\n                    1,\n                    HashMap::from([\n                        (\"image\".to_string(), vec![0.9, 0.1, 0.1, 0.2]),\n                        (\n                            \"text\".to_string(),\n                            vec![0.4, 0.7, 0.1, 0.8, 0.1, 0.1, 0.9, 0.2],\n                        ),\n                    ]),\n                    Payload::default(),\n                ),\n                PointStruct::new(\n                    2,\n                    HashMap::from([\n                        (\"image\".to_string(), vec![0.2, 0.1, 0.3, 0.9]),\n                        (\n                            \"text\".to_string(),\n                            vec![0.5, 0.2, 0.7, 0.4, 0.7, 0.2, 0.3, 0.9],\n                        ),\n                    ]),\n                    Payload::default(),\n                ),\n            ],\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.VectorFactory.vector;\nimport static io.qdrant.client.VectorsFactory.namedVectors;\n\nimport io.qdrant.client.grpc.Points.PointStruct;\n\nclient\n    .upsertAsync(\n        \"{collection_name}\",\n        List.of(\n            PointStruct.newBuilder()\n                .setId(id(1))\n                .setVectors(\n                    namedVectors(\n                        Map.of(\n                            \"image\",\n                            vector(List.of(0.9f, 0.1f, 0.1f, 0.2f)),",
      "index": 15,
      "token_count": 581,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 28907,
      "end_char": 30950
    },
    {
      "content": "\"image\",\n                            vector(List.of(0.9f, 0.1f, 0.1f, 0.2f)),\n                            \"text\",\n                            vector(List.of(0.4f, 0.7f, 0.1f, 0.8f, 0.1f, 0.1f, 0.9f, 0.2f)))))\n                .build(),\n            PointStruct.newBuilder()\n                .setId(id(2))\n                .setVectors(\n                    namedVectors(\n                        Map.of(\n                            \"image\",\n                            List.of(0.2f, 0.1f, 0.3f, 0.9f),\n                            \"text\",\n                            List.of(0.5f, 0.2f, 0.7f, 0.4f, 0.7f, 0.2f, 0.3f, 0.9f))))\n                .build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpsertAsync(\n\tcollectionName: \"{collection_name}\",\n\tpoints: new List<PointStruct>\n\t{\n\t\tnew()\n\t\t{\n\t\t\tId = 1,\n\t\t\tVectors = new Dictionary<string, float[]>\n\t\t\t{\n\t\t\t\t[\"image\"] = [0.9f, 0.1f, 0.1f, 0.2f],\n\t\t\t\t[\"text\"] = [0.4f, 0.7f, 0.1f, 0.8f, 0.1f, 0.1f, 0.9f, 0.2f]\n\t\t\t}\n\t\t},\n\t\tnew()\n\t\t{\n\t\t\tId = 2,\n\t\t\tVectors = new Dictionary<string, float[]>\n\t\t\t{\n\t\t\t\t[\"image\"] = [0.2f, 0.1f, 0.3f, 0.9f],\n\t\t\t\t[\"text\"] = [0.5f, 0.2f, 0.7f, 0.4f, 0.7f, 0.2f, 0.3f, 0.9f]\n\t\t\t}\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Upsert(context.Background(), &qdrant.UpsertPoints{\n\tCollectionName: \"{collection_name}\",\n\tPoints: []*qdrant.PointStruct{\n\t\t{\n\t\t\tId: qdrant.NewIDNum(1),\n\t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{\n\t\t\t\t\"image\": qdrant.NewVector(0.9, 0.1, 0.1, 0.2),\n\t\t\t\t\"text\":  qdrant.NewVector(0.4, 0.7, 0.1, 0.8, 0.1, 0.1, 0.9, 0.2),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tId: qdrant.NewIDNum(2),\n\t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{\n\t\t\t\t\"image\": qdrant.NewVector(0.2, 0.1, 0.3, 0.9),\n\t\t\t\t\"text\":  qdrant.NewVector(0.5, 0.2, 0.7, 0.4, 0.7, 0.2, 0.3, 0.9),\n\t\t\t}),\n\t\t},\n\t},\n})\n```\n\n*Available as of v1.2.0*",
      "index": 16,
      "token_count": 845,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 30850,
      "end_char": 32898
    },
    {
      "content": "ewVector(0.5, 0.2, 0.7, 0.4, 0.7, 0.2, 0.3, 0.9),\n\t\t\t}),\n\t\t},\n\t},\n})\n```\n\n*Available as of v1.2.0*\n\nNamed vectors are optional. When uploading points, some vectors may be omitted. For example, you can upload one point with only the `image` vector and a second one with only the `text` vector.\n\nWhen uploading a point with an existing ID, the existing point is deleted first, then it is inserted with just the specified vectors. In other words, the entire point is replaced, and any unspecified vectors are set to null. To keep existing vectors unchanged and only update specified vectors, see [update vectors](#update-vectors.md).\n\n*Available as of v1.7.0*\n\nPoints can contain dense and sparse vectors.\n\nA sparse vector is an array in which most of the elements have a value of zero.\n\nIt is possible to take advantage of this property to have an optimized representation, for this reason they have a different shape than dense vectors.\n\nThey are represented as a list of `(index, value)` pairs, where `index` is an integer and `value` is a floating point number. The `index` is the position of the non-zero value in the vector. The `values` is the value of the non-zero element.\n\nFor example, the following vector:\n\n```\n[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 0.0, 0.0]\n```\n\ncan be represented as a sparse vector:\n\n```\n[(6, 1.0), (7, 2.0)]\n```\n\nQdrant uses the following JSON representation throughout its APIs.\n\n```json\n{\n  \"indices\": [6, 7],\n  \"values\": [1.0, 2.0]\n}\n```\n\nThe `indices` and `values` arrays must have the same length. And the `indices` must be unique.\n\nIf the `indices` are not sorted, Qdrant will sort them internally so you may not rely on the order of the elements.\n\nSparse vectors must be named and can be uploaded in the same way as dense vectors.\n\n```http\nPUT /collections/{collection_name}/points\n{\n    \"points\": [\n        {\n            \"id\": 1,\n            \"vector\": {\n                \"text\": {\n                    \"indices\": [6, 7],\n                    \"values\": [1.0, 2.0]\n                }\n            }\n        },",
      "index": 17,
      "token_count": 565,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 32798,
      "end_char": 34842
    },
    {
      "content": "dices\": [6, 7],\n                    \"values\": [1.0, 2.0]\n                }\n            }\n        },\n        {\n            \"id\": 2,\n            \"vector\": {\n                \"text\": {\n                    \"indices\": [1, 2, 4, 15, 33, 34],\n                    \"values\": [0.1, 0.2, 0.3, 0.4, 0.5]\n                }\n            }\n        }\n    ]\n}\n```\n\n```python\nclient.upsert(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointStruct(\n            id=1,\n            vector={\n                \"text\": models.SparseVector(\n                    indices=[6, 7],\n                    values=[1.0, 2.0],\n                )\n            },\n        ),\n        models.PointStruct(\n            id=2,\n            vector={\n                \"text\": models.SparseVector(\n                    indices=[1, 2, 3, 4, 5],\n                    values=[0.1, 0.2, 0.3, 0.4, 0.5],\n                )\n            },\n        ),\n    ],\n)\n```\n\n```typescript\nclient.upsert(\"{collection_name}\", {\n  points: [\n    {\n      id: 1,\n      vector: {\n        text: {\n          indices: [6, 7],\n          values: [1.0, 2.0],\n        },\n      },\n    },\n    {\n      id: 2,\n      vector: {\n        text: {\n          indices: [1, 2, 3, 4, 5],\n          values: [0.1, 0.2, 0.3, 0.4, 0.5],\n        },\n      },\n    },\n  ],\n});\n```\n\n```rust\nuse std::collections::HashMap;\n\nuse qdrant_client::qdrant::{PointStruct, UpsertPointsBuilder, Vector};\nuse qdrant_client::Payload;\n\nclient\n    .upsert_points(\n        UpsertPointsBuilder::new(\n            \"{collection_name}\",\n            vec![\n                PointStruct::new(\n                    1,\n                    HashMap::from([(\"text\".to_string(), vec![(6, 1.0), (7, 2.0)])]),\n                    Payload::default(),\n                ),\n                PointStruct::new(\n                    2,\n                    HashMap::from([(\n                        \"text\".to_string(),\n                        vec![(1, 0.1), (2, 0.2), (3, 0.3), (4, 0.4), (5, 0.5)],\n                    )]),\n                    Payload::default(),",
      "index": 18,
      "token_count": 570,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 34742,
      "end_char": 36774
    },
    {
      "content": "2), (3, 0.3), (4, 0.4), (5, 0.5)],\n                    )]),\n                    Payload::default(),\n                ),\n            ],\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.VectorFactory.vector;\n\nimport io.qdrant.client.grpc.Points.NamedVectors;\nimport io.qdrant.client.grpc.Points.PointStruct;\nimport io.qdrant.client.grpc.Points.Vectors;\n\nclient\n    .upsertAsync(\n        \"{collection_name}\",\n        List.of(\n            PointStruct.newBuilder()\n                .setId(id(1))\n                .setVectors(\n                    Vectors.newBuilder()\n                        .setVectors(\n                            NamedVectors.newBuilder()\n                                .putAllVectors(\n                                    Map.of(\n                                        \"text\", vector(List.of(1.0f, 2.0f), List.of(6, 7))))\n                                .build())\n                        .build())\n                .build(),\n            PointStruct.newBuilder()\n                .setId(id(2))\n                .setVectors(\n                    Vectors.newBuilder()\n                        .setVectors(\n                            NamedVectors.newBuilder()\n                                .putAllVectors(\n                                    Map.of(\n                                        \"text\",\n                                        vector(\n                                            List.of(0.1f, 0.2f, 0.3f, 0.4f, 0.5f),\n                                            List.of(1, 2, 3, 4, 5))))\n                                .build())\n                        .build())\n                .build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpsertAsync(\n\tcollectionName: \"{collection_name}\",\n\tpoints: new List<PointStruct>\n\t{\n\t\tnew()\n\t\t{\n\t\t\tId = 1,",
      "index": 19,
      "token_count": 409,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 36674,
      "end_char": 38671
    },
    {
      "content": "ync(\n\tcollectionName: \"{collection_name}\",\n\tpoints: new List<PointStruct>\n\t{\n\t\tnew()\n\t\t{\n\t\t\tId = 1,\n\t\t\tVectors = new Dictionary<string, Vector> { [\"text\"] = ([1.0f, 2.0f], [6, 7]) }\n\t\t},\n\t\tnew()\n\t\t{\n\t\t\tId = 2,\n\t\t\tVectors = new Dictionary<string, Vector>\n\t\t\t{\n\t\t\t\t[\"text\"] = ([0.1f, 0.2f, 0.3f, 0.4f, 0.5f], [1, 2, 3, 4, 5])\n\t\t\t}\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Upsert(context.Background(), &qdrant.UpsertPoints{\n\tCollectionName: \"{collection_name}\",\n\tPoints: []*qdrant.PointStruct{\n\t\t{\n\t\t\tId: qdrant.NewIDNum(1),\n\t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{\n\t\t\t\t\"text\": qdrant.NewVectorSparse(\n\t\t\t\t\t[]uint32{6, 7},\n\t\t\t\t\t[]float32{1.0, 2.0}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tId: qdrant.NewIDNum(2),\n\t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{\n\t\t\t\t\"text\": qdrant.NewVectorSparse(\n\t\t\t\t\t[]uint32{1, 2, 3, 4, 5},\n\t\t\t\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5}),\n\t\t\t}),\n\t\t},\n\t},\n})\n```\n\n## Modify points\n\nTo change a point, you can modify its vectors or its payload. There are several ways to do this.\n\n### Update vectors\n\n*Available as of v1.2.0*\n\nThis method updates the specified vectors on the given points. Unspecified vectors are kept unchanged. All given points must exist.\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/update-vectors)):\n\n```http\nPUT /collections/{collection_name}/points/vectors\n{\n    \"points\": [\n        {\n            \"id\": 1,\n            \"vector\": {\n                \"image\": [0.1, 0.2, 0.3, 0.4]\n            }\n        },\n        {\n            \"id\": 2,\n            \"vector\": {\n                \"text\": [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]\n            }\n        }\n    ]\n}\n```\n\n```python\nclient.update_vectors(\n    collection_name=\"{collection_name}\",\n    points=[\n        models.PointVectors(\n            id=1,\n            vector={\n                \"image\": [0.1, 0.2, 0.3, 0.4],\n            },\n        ),\n        models.PointVectors(\n            id=2,",
      "index": 20,
      "token_count": 707,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 38571,
      "end_char": 40618
    },
    {
      "content": "ge\": [0.1, 0.2, 0.3, 0.4],\n            },\n        ),\n        models.PointVectors(\n            id=2,\n            vector={\n                \"text\": [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2],\n            },\n        ),\n    ],\n)\n```\n\n```typescript\nclient.updateVectors(\"{collection_name}\", {\n  points: [\n    {\n      id: 1,\n      vector: {\n        image: [0.1, 0.2, 0.3, 0.4],\n      },\n    },\n    {\n      id: 2,\n      vector: {\n        text: [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2],\n      },\n    },\n  ],\n});\n```\n\n```rust\nuse std::collections::HashMap;\n\nuse qdrant_client::qdrant::{\n    PointVectors, UpdatePointVectorsBuilder,\n};\n\nclient\n    .update_vectors(\n        UpdatePointVectorsBuilder::new(\n            \"{collection_name}\",\n            vec![\n                PointVectors {\n                    id: Some(1.into()),\n                    vectors: Some(\n                        HashMap::from([(\"image\".to_string(), vec![0.1, 0.2, 0.3, 0.4])]).into(),\n                    ),\n                },\n                PointVectors {\n                    id: Some(2.into()),\n                    vectors: Some(\n                        HashMap::from([(\n                            \"text\".to_string(),\n                            vec![0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2],\n                        )])\n                        .into(),\n                    ),\n                },\n            ],\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.VectorFactory.vector;\nimport static io.qdrant.client.VectorsFactory.namedVectors;\n\nclient\n    .updateVectorsAsync(\n        \"{collection_name}\",\n        List.of(\n            PointVectors.newBuilder()\n                .setId(id(1))\n                .setVectors(namedVectors(Map.of(\"image\", vector(List.of(0.1f, 0.2f, 0.3f, 0.4f)))))\n                .build(),\n            PointVectors.newBuilder()\n                .setId(id(2))\n                .setVectors(",
      "index": 21,
      "token_count": 556,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 40518,
      "end_char": 42535
    },
    {
      "content": "),\n            PointVectors.newBuilder()\n                .setId(id(2))\n                .setVectors(\n                    namedVectors(\n                        Map.of(\n                            \"text\", vector(List.of(0.9f, 0.8f, 0.7f, 0.6f, 0.5f, 0.4f, 0.3f, 0.2f)))))\n                .build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpdateVectorsAsync(\n\tcollectionName: \"{collection_name}\",\n\tpoints: new List<PointVectors>\n\t{\n\t\tnew() { Id = 1, Vectors = (\"image\", new float[] { 0.1f, 0.2f, 0.3f, 0.4f }) },\n\t\tnew()\n\t\t{\n\t\t\tId = 2,\n\t\t\tVectors = (\"text\", new float[] { 0.9f, 0.8f, 0.7f, 0.6f, 0.5f, 0.4f, 0.3f, 0.2f })\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.UpdateVectors(context.Background(), &qdrant.UpdatePointVectors{\n\tCollectionName: \"{collection_name}\",\n\tPoints: []*qdrant.PointVectors{\n\t\t{\n\t\t\tId: qdrant.NewIDNum(1),\n\t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{\n\t\t\t\t\"image\": qdrant.NewVector(0.1, 0.2, 0.3, 0.4),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tId: qdrant.NewIDNum(2),\n\t\t\tVectors: qdrant.NewVectorsMap(map[string]*qdrant.Vector{\n\t\t\t\t\"text\": qdrant.NewVector(0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2),\n\t\t\t}),\n\t\t},\n\t},\n})\n```\n\nTo update points and replace all of its vectors, see [uploading points](#upload-points.md).\n\n### Delete vectors\n\n*Available as of v1.2.0*\n\nThis method deletes just the specified vectors from the given points. Other vectors are kept unchanged. Points are never deleted.\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/delete-vectors)):\n\n```http\nPOST /collections/{collection_name}/points/vectors/delete\n{\n    \"points\": [0, 3, 100],\n    \"vectors\": [\"text\", \"image\"]\n}\n```\n\n```python\nclient.delete_vectors(\n    collection_name=\"{collection_name}\",\n    points=[0, 3, 100],\n    vectors=[\"text\", \"image\"],\n)\n```\n\n```typescript\nclient.deleteVectors(\"{collection_name}\", {",
      "index": 22,
      "token_count": 690,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 42435,
      "end_char": 44484
    },
    {
      "content": "0],\n    vectors=[\"text\", \"image\"],\n)\n```\n\n```typescript\nclient.deleteVectors(\"{collection_name}\", {\n  points: [0, 3, 10],\n  vector: [\"text\", \"image\"],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    DeletePointVectorsBuilder, PointsIdsList,\n};\n\nclient\n    .delete_vectors(\n        DeletePointVectorsBuilder::new(\"{collection_name}\")\n            .points_selector(PointsIdsList {\n                ids: vec![0.into(), 3.into(), 10.into()],\n            })\n            .vectors(vec![\"text\".into(), \"image\".into()])\n            .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.PointIdFactory.id;\n\nclient\n    .deleteVectorsAsync(\n        \"{collection_name}\", List.of(\"text\", \"image\"), List.of(id(0), id(3), id(10)))\n    .get();\n```\n\n```csharp\nawait client.DeleteVectorsAsync(\"{collection_name}\", [\"text\", \"image\"], [0, 3, 10]);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient.DeleteVectors(context.Background(), &qdrant.DeletePointVectors{\n\tCollectionName: \"{collection_name}\",\n\tPointsSelector: qdrant.NewPointsSelector(\n\t\tqdrant.NewIDNum(0), qdrant.NewIDNum(3), qdrant.NewIDNum(10)),\n\tVectors: &qdrant.VectorsSelector{\n\t\tNames: []string{\"text\", \"image\"},\n\t},\n})\n```\n\nTo delete entire points, see [deleting points](#delete-points.md).\n\n### Update payload\n\nLearn how to modify the payload of a point in the [Payload](https://qdrant.tech/documentation/concepts/payload/#update-payload) section.\n\n## Delete points\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/delete-points)):\n\n```http\nPOST /collections/{collection_name}/points/delete\n{\n    \"points\": [0, 3, 100]\n}\n```\n\n```python\nclient.delete(\n    collection_name=\"{collection_name}\",\n    points_selector=models.PointIdsList(\n        points=[0, 3, 100],\n    ),\n)\n```\n\n```typescript\nclient.delete(\"{collection_name}\", {\n  points: [0, 3, 100],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{DeletePointsBuilder, PointsIdsList};\n\nclient\n    .delete_points(",
      "index": 23,
      "token_count": 553,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 44384,
      "end_char": 46381
    },
    {
      "content": "``rust\nuse qdrant_client::qdrant::{DeletePointsBuilder, PointsIdsList};\n\nclient\n    .delete_points(\n        DeletePointsBuilder::new(\"{collection_name}\")\n            .points(PointsIdsList {\n                ids: vec![0.into(), 3.into(), 100.into()],\n            })\n            .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.PointIdFactory.id;\n\nclient.deleteAsync(\"{collection_name}\", List.of(id(0), id(3), id(100)));\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.DeleteAsync(collectionName: \"{collection_name}\", ids: [0, 3, 100]);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Delete(context.Background(), &qdrant.DeletePoints{\n\tCollectionName: \"{collection_name}\",\n\tPoints: qdrant.NewPointsSelector(\n\t\tqdrant.NewIDNum(0), qdrant.NewIDNum(3), qdrant.NewIDNum(100),\n\t),\n})\n```\n\nAlternative way to specify which points to remove is to use filter.\n\n```http\nPOST /collections/{collection_name}/points/delete\n{\n    \"filter\": {\n        \"must\": [\n            {\n                \"key\": \"color\",\n                \"match\": {\n                    \"value\": \"red\"\n                }\n            }\n        ]\n    }\n}\n```\n\n```python\nclient.delete(\n    collection_name=\"{collection_name}\",\n    points_selector=models.FilterSelector(\n        filter=models.Filter(\n            must=[\n                models.FieldCondition(\n                    key=\"color\",\n                    match=models.MatchValue(value=\"red\"),\n                ),\n            ],\n        )\n    ),\n)\n```\n\n```typescript\nclient.delete(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        key: \"color\",\n        match: {\n          value: \"red\",\n        },\n      },\n    ],\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, DeletePointsBuilder, Filter};\n\nclient\n    .delete_points(\n        DeletePointsBuilder::new(\"{collection_name}\")\n            .",
      "index": 24,
      "token_count": 506,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 46281,
      "end_char": 48315
    },
    {
      "content": "er};\n\nclient\n    .delete_points(\n        DeletePointsBuilder::new(\"{collection_name}\")\n            .points(Filter::must([Condition::matches(\n                \"color\",\n                \"red\".to_string(),\n            )]))\n            .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\n\nclient\n    .deleteAsync(\n        \"{collection_name}\",\n        Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.DeleteAsync(collectionName: \"{collection_name}\", filter: MatchKeyword(\"color\", \"red\"));\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Delete(context.Background(), &qdrant.DeletePoints{\n\tCollectionName: \"{collection_name}\",\n\tPoints: qdrant.NewPointsSelectorFilter(\n\t\t&qdrant.Filter{\n\t\t\tMust: []*qdrant.Condition{\n\t\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t\t},\n\t\t},\n\t),\n})\n```\n\nThis example removes all points with `{ \"color\": \"red\" }` from the collection.\n\n## Retrieve points\n\nThere is a method for retrieving points by their ids.\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/get-points)):\n\n```http\nPOST /collections/{collection_name}/points\n{\n    \"ids\": [0, 3, 100]\n}\n```\n\n```python\nclient.retrieve(\n    collection_name=\"{collection_name}\",\n    ids=[0, 3, 100],\n)\n```\n\n```typescript\nclient.retrieve(\"{collection_name}\", {\n  ids: [0, 3, 100],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::GetPointsBuilder;\n\nclient\n    .get_points(GetPointsBuilder::new(\n        \"{collection_name}\",\n        vec![0.into(), 30.into(), 100.into()],\n    ))\n    .await?;\n```\n\n```java\nimport java.util.List;\n\nimport static io.qdrant.client.PointIdFactory.id;\n\nclient\n    .retrieveAsync(\"{collection_name}\", List.of(id(0), id(30), id(100)), false, false, null)\n    .",
      "index": 25,
      "token_count": 553,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 48215,
      "end_char": 50259
    },
    {
      "content": "t\n    .retrieveAsync(\"{collection_name}\", List.of(id(0), id(30), id(100)), false, false, null)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.RetrieveAsync(\n\tcollectionName: \"{collection_name}\",\n\tids: [0, 30, 100],\n\twithPayload: false,\n\twithVectors: false\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Get(context.Background(), &qdrant.GetPoints{\n\tCollectionName: \"{collection_name}\",\n\tIds: []*qdrant.PointId{\n\t\tqdrant.NewIDNum(0), qdrant.NewIDNum(3), qdrant.NewIDNum(100),\n\t},\n})\n```\n\nThis method has additional parameters `with_vectors` and `with_payload`. Using these parameters, you can select parts of the point you want as a result. Excluding helps you not to waste traffic transmitting useless data.\n\nThe single point can also be retrieved via the API:\n\nREST API ([Schema](https://api.qdrant.tech/api-reference/points/get-point)):\n\n```http\nGET /collections/{collection_name}/points/{point_id}\n```\n\n## Scroll points\n\nSometimes it might be necessary to get all stored points without knowing ids, or iterate over points that correspond to a filter.\n\nREST API ([Schema](https://api.qdrant.tech/master/api-reference/points/scroll-points)):\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"filter\": {\n        \"must\": [\n            {\n                \"key\": \"color\",\n                \"match\": {\n                    \"value\": \"red\"\n                }\n            }\n        ]\n    },\n    \"limit\": 1,\n    \"with_payload\": true,\n    \"with_vector\": false\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    scroll_filter=models.Filter(\n        must=[\n            models.FieldCondition(key=\"color\", match=models.MatchValue(value=\"red\")),\n        ]\n    ),\n    limit=1,\n    with_payload=True,\n    with_vectors=False,\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        key: \"color\",",
      "index": 26,
      "token_count": 528,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 50159,
      "end_char": 52204
    },
    {
      "content": "pescript\nclient.scroll(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        key: \"color\",\n        match: {\n          value: \"red\",\n        },\n      },\n    ],\n  },\n  limit: 1,\n  with_payload: true,\n  with_vector: false,\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, Filter, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\")\n            .filter(Filter::must([Condition::matches(\n                \"color\",\n                \"red\".to_string(),\n            )]))\n            .limit(1)\n            .with_payload(true)\n            .with_vectors(false),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\nimport static io.qdrant.client.WithPayloadSelectorFactory.enable;\n\nimport io.qdrant.client.grpc.Points.Filter;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient\n    .scrollAsync(\n        ScrollPoints.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setFilter(Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build())\n            .setLimit(1)\n            .setWithPayload(enable(true))\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ScrollAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: MatchKeyword(\"color\", \"red\"),\n\tlimit: 1,\n\tpayloadSelector: true\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t},\n\t},\n\tLimit:       qdrant.PtrOf(uint32(1)),\n\tWithPayload: qdrant.NewWithPayload(true),\n})\n```\n\nReturns all point with `color` = `red`.\n\n```json\n{\n  \"result\": {\n    \"next_page_offset\": 1,\n    \"points\": [\n      {\n        \"id\": 0,\n        \"payload\": {",
      "index": 27,
      "token_count": 526,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 52104,
      "end_char": 54140
    },
    {
      "content": "result\": {\n    \"next_page_offset\": 1,\n    \"points\": [\n      {\n        \"id\": 0,\n        \"payload\": {\n          \"color\": \"red\"\n        }\n      }\n    ]\n  },\n  \"status\": \"ok\",\n  \"time\": 0.0001\n}\n```\n\nThe Scroll API will return all points that match the filter in a page-by-page manner.\n\nAll resulting points are sorted by ID. To query the next page it is necessary to specify the largest seen ID in the `offset` field. For convenience, this ID is also returned in the field `next_page_offset`. If the value of the `next_page_offset` field is `null` - the last page is reached.\n\n### Order points by payload key\n\n*Available as of v1.8.0*\n\nWhen using the [`scroll`](#scroll-points.md) API, you can sort the results by payload key. For example, you can retrieve points in chronological order if your payloads have a `\"timestamp\"` field, as is shown from the example below:\n\nWithout an appropriate index, payload-based ordering would create too much load on the system for each request. Qdrant therefore requires a payload index which supports [Range filtering conditions](https://qdrant.tech/documentation/concepts/indexing/#payload-index) on the field used for `order_by`\n\n```http\nPOST /collections/{collection_name}/points/scroll\n{\n    \"limit\": 15,\n    \"order_by\": \"timestamp\", // <-- this!\n}\n```\n\n```python\nclient.scroll(\n    collection_name=\"{collection_name}\",\n    limit=15,\n    order_by=\"timestamp\", # <-- this!\n)\n```\n\n```typescript\nclient.scroll(\"{collection_name}\", {\n  limit: 15,\n  order_by: \"timestamp\", // <-- this!\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{OrderByBuilder, ScrollPointsBuilder};\n\nclient\n    .scroll(\n        ScrollPointsBuilder::new(\"{collection_name}\")\n            .limit(15)\n            .order_by(OrderByBuilder::new(\"timestamp\")),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.grpc.Points.OrderBy;\nimport io.qdrant.client.grpc.Points.ScrollPoints;\n\nclient.scrollAsync(ScrollPoints.newBuilder()\n  .setCollectionName(\"{collection_name}\")\n  .setLimit(15)\n  .setOrderBy(OrderBy.newBuilder().setKey(\"timestamp\").",
      "index": 28,
      "token_count": 506,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 54040,
      "end_char": 56083
    },
    {
      "content": "ionName(\"{collection_name}\")\n  .setLimit(15)\n  .setOrderBy(OrderBy.newBuilder().setKey(\"timestamp\").build())\n  .build()).get();\n```\n\n```csharp\nawait client.ScrollAsync(\"{collection_name}\", limit: 15, orderBy: \"timestamp\");\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Scroll(context.Background(), &qdrant.ScrollPoints{\n\tCollectionName: \"{collection_name}\",\n\tLimit:          qdrant.PtrOf(uint32(15)),\n\tOrderBy: &qdrant.OrderBy{\n\t\tKey: \"timestamp\",\n\t},\n})\n```\n\nYou need to use the `order_by` `key` parameter to specify the payload key. Then you can add other fields to control the ordering, such as `direction` and `start_from`:\n\n```http\n\"order_by\": {\n    \"key\": \"timestamp\",\n    \"direction\": \"desc\" // default is \"asc\"\n    \"start_from\": 123, // start from this value\n}\n```\n\n```python\norder_by=models.OrderBy(\n    key=\"timestamp\",\n    direction=\"desc\",  # default is \"asc\"\n    start_from=123,  # start from this value\n)\n```\n\n```typescript\norder_by: {\n    key: \"timestamp\",\n    direction: \"desc\", // default is \"asc\"\n    start_from: 123, // start from this value\n}\n```\n\n```rust\nuse qdrant_client::qdrant::{start_from::Value, Direction, OrderByBuilder};\n\nOrderByBuilder::new(\"timestamp\")\n    .direction(Direction::Desc.into())\n    .start_from(Value::Integer(123))\n    .build();\n```\n\n```java\nimport io.qdrant.client.grpc.Points.Direction;\nimport io.qdrant.client.grpc.Points.OrderBy;\nimport io.qdrant.client.grpc.Points.StartFrom;\n\nOrderBy.newBuilder()\n  .setKey(\"timestamp\")\n  .setDirection(Direction.Desc)\n  .setStartFrom(StartFrom.newBuilder()\n    .setInteger(123)\n    .build())\n  .build();\n```\n\n```csharp\nusing Qdrant.Client.Grpc;\n\nnew OrderBy\n{\n Key = \"timestamp\",\n Direction = Direction.Desc,\n StartFrom = 123\n};\n```\n\n```go\nimport \"github.com/qdrant/go-client/qdrant\"\n\nqdrant.OrderBy{\n\tKey:       \"timestamp\",\n\tDirection: qdrant.Direction_Desc.Enum(),\n\tStartFrom: qdrant.NewStartFromInt(123),\n}\n```",
      "index": 29,
      "token_count": 572,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 55983,
      "end_char": 58004
    },
    {
      "content": "mestamp\",\n\tDirection: qdrant.Direction_Desc.Enum(),\n\tStartFrom: qdrant.NewStartFromInt(123),\n}\n```\n\nWhen you use the `order_by` parameter, pagination is disabled.\n\nWhen sorting is based on a non-unique value, it is not possible to rely on an ID offset. Thus, next\\_page\\_offset is not returned within the response. However, you can still do pagination by combining `\"order_by\": { \"start_from\": ... }` with a `{ \"must_not\": [{ \"has_id\": [...] }] }` filter.\n\n## Counting points\n\n*Available as of v0.8.4*\n\nSometimes it can be useful to know how many points fit the filter conditions without doing a real search.\n\nAmong others, for example, we can highlight the following scenarios:\n\n- Evaluation of results size for faceted search\n- Determining the number of pages for pagination\n- Debugging the query execution speed\n\nREST API ([Schema](https://api.qdrant.tech/master/api-reference/points/count-points)):\n\n```http\nPOST /collections/{collection_name}/points/count\n{\n    \"filter\": {\n        \"must\": [\n            {\n                \"key\": \"color\",\n                \"match\": {\n                    \"value\": \"red\"\n                }\n            }\n        ]\n    },\n    \"exact\": true\n}\n```\n\n```python\nclient.count(\n    collection_name=\"{collection_name}\",\n    count_filter=models.Filter(\n        must=[\n            models.FieldCondition(key=\"color\", match=models.MatchValue(value=\"red\")),\n        ]\n    ),\n    exact=True,\n)\n```\n\n```typescript\nclient.count(\"{collection_name}\", {\n  filter: {\n    must: [\n      {\n        key: \"color\",\n        match: {\n          value: \"red\",\n        },\n      },\n    ],\n  },\n  exact: true,\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Condition, CountPointsBuilder, Filter};\n\nclient\n    .count(\n        CountPointsBuilder::new(\"{collection_name}\")\n            .filter(Filter::must([Condition::matches(\n                \"color\",\n                \"red\".to_string(),\n            )]))\n            .exact(true),\n    )\n    .await?;\n```\n\n```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.",
      "index": 30,
      "token_count": 480,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 57904,
      "end_char": 59952
    },
    {
      "content": "```java\nimport static io.qdrant.client.ConditionFactory.matchKeyword;\n\nimport io.qdrant.client.grpc.Points.Filter;\n\nclient\n    .countAsync(\n        \"{collection_name}\",\n        Filter.newBuilder().addMust(matchKeyword(\"color\", \"red\")).build(),\n        true)\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing static Qdrant.Client.Grpc.Conditions;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CountAsync(\n\tcollectionName: \"{collection_name}\",\n\tfilter: MatchKeyword(\"color\", \"red\"),\n\texact: true\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\t\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Count(context.Background(), &qdrant.CountPoints{\n\tCollectionName: \"midlib\",\n\tFilter: &qdrant.Filter{\n\t\tMust: []*qdrant.Condition{\n\t\t\tqdrant.NewMatch(\"color\", \"red\"),\n\t\t},\n\t},\n})\n```\n\nReturns number of counts matching given filtering conditions:\n\n```json\n{\n  \"count\": 3811\n}\n```\n\n## Batch update\n\n*Available as of v1.5.0*\n\nYou can batch multiple point update operations. This includes inserting, updating and deleting points, vectors and payload.\n\nA batch update request consists of a list of operations. These are executed in order. These operations can be batched:\n\n- [Upsert points](#upload-points.md): `upsert` or `UpsertOperation`\n- [Delete points](#delete-points.md): `delete_points` or `DeleteOperation`\n- [Update vectors](#update-vectors.md): `update_vectors` or `UpdateVectorsOperation`\n- [Delete vectors](#delete-vectors.md): `delete_vectors` or `DeleteVectorsOperation`\n- [Set payload](https://qdrant.tech/documentation/concepts/payload/#set-payload): `set_payload` or `SetPayloadOperation`\n- [Overwrite payload](https://qdrant.tech/documentation/concepts/payload/#overwrite-payload): `overwrite_payload` or `OverwritePayload`\n- [Delete payload](https://qdrant.tech/documentation/concepts/payload/#delete-payload-keys): `delete_payload` or `DeletePayloadOperation`\n- [Clear payload](https://qdrant.",
      "index": 31,
      "token_count": 514,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 59852,
      "end_char": 61845
    },
    {
      "content": "delete-payload-keys): `delete_payload` or `DeletePayloadOperation`\n- [Clear payload](https://qdrant.tech/documentation/concepts/payload/#clear-payload): `clear_payload` or `ClearPayloadOperation`\n\nThe following example snippet makes use of all operations.\n\nREST API ([Schema](https://api.qdrant.tech/master/api-reference/points/batch-update)):\n\n```http\nPOST /collections/{collection_name}/points/batch\n{\n    \"operations\": [\n        {\n            \"upsert\": {\n                \"points\": [\n                    {\n                        \"id\": 1,\n                        \"vector\": [1.0, 2.0, 3.0, 4.0],\n                        \"payload\": {}\n                    }\n                ]\n            }\n        },\n        {\n            \"update_vectors\": {\n                \"points\": [\n                    {\n                        \"id\": 1,\n                        \"vector\": [1.0, 2.0, 3.0, 4.0]\n                    }\n                ]\n            }\n        },\n        {\n            \"delete_vectors\": {\n                \"points\": [1],\n                \"vector\": [\"\"]\n            }\n        },\n        {\n            \"overwrite_payload\": {\n                \"payload\": {\n                    \"test_payload\": \"1\"\n                },\n                \"points\": [1]\n            }\n        },\n        {\n            \"set_payload\": {\n                \"payload\": {\n                    \"test_payload_2\": \"2\",\n                    \"test_payload_3\": \"3\"\n                },\n                \"points\": [1]\n            }\n        },\n        {\n            \"delete_payload\": {\n                \"keys\": [\"test_payload_2\"],\n                \"points\": [1]\n            }\n        },\n        {\n            \"clear_payload\": {\n                \"points\": [1]\n            }\n        },\n        {\"delete\": {\"points\": [1]}}\n    ]\n}\n```\n\n```python\nclient.batch_update_points(\n    collection_name=\"{collection_name}\",\n    update_operations=[\n        models.UpsertOperation(\n            upsert=models.PointsList(\n                points=[\n                    models.PointStruct(\n                        id=1,",
      "index": 32,
      "token_count": 427,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 61745,
      "end_char": 63788
    },
    {
      "content": "ist(\n                points=[\n                    models.PointStruct(\n                        id=1,\n                        vector=[1.0, 2.0, 3.0, 4.0],\n                        payload={},\n                    ),\n                ]\n            )\n        ),\n        models.UpdateVectorsOperation(\n            update_vectors=models.UpdateVectors(\n                points=[\n                    models.PointVectors(\n                        id=1,\n                        vector=[1.0, 2.0, 3.0, 4.0],\n                    )\n                ]\n            )\n        ),\n        models.DeleteVectorsOperation(\n            delete_vectors=models.DeleteVectors(points=[1], vector=[\"\"])\n        ),\n        models.OverwritePayloadOperation(\n            overwrite_payload=models.SetPayload(\n                payload={\"test_payload\": 1},\n                points=[1],\n            )\n        ),\n        models.SetPayloadOperation(\n            set_payload=models.SetPayload(\n                payload={\n                    \"test_payload_2\": 2,\n                    \"test_payload_3\": 3,\n                },\n                points=[1],\n            )\n        ),\n        models.DeletePayloadOperation(\n            delete_payload=models.DeletePayload(keys=[\"test_payload_2\"], points=[1])\n        ),\n        models.ClearPayloadOperation(clear_payload=models.PointIdsList(points=[1])),\n        models.DeleteOperation(delete=models.PointIdsList(points=[1])),\n    ],\n)\n```\n\n```typescript\nclient.batchUpdate(\"{collection_name}\", {\n  operations: [\n    {\n      upsert: {\n        points: [\n          {\n            id: 1,\n            vector: [1.0, 2.0, 3.0, 4.0],\n            payload: {},\n          },\n        ],\n      },\n    },\n    {\n      update_vectors: {\n        points: [\n          {\n            id: 1,\n            vector: [1.0, 2.0, 3.0, 4.0],\n          },\n        ],\n      },\n    },\n    {\n      delete_vectors: {\n        points: [1],\n        vector: [\"\"],\n      },\n    },\n    {\n      overwrite_payload: {\n        payload: {\n          test_payload: 1,\n        },\n        points: [1],",
      "index": 33,
      "token_count": 433,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 63688,
      "end_char": 65733
    },
    {
      "content": "overwrite_payload: {\n        payload: {\n          test_payload: 1,\n        },\n        points: [1],\n      },\n    },\n    {\n      set_payload: {\n        payload: {\n          test_payload_2: 2,\n          test_payload_3: 3,\n        },\n        points: [1],\n      },\n    },\n    {\n      delete_payload: {\n        keys: [\"test_payload_2\"],\n        points: [1],\n      },\n    },\n    {\n      clear_payload: {\n        points: [1],\n      },\n    },\n    {\n      delete: {\n        points: [1],\n      },\n    },\n  ],\n});\n```\n\n```rust\nuse std::collections::HashMap;\n\nuse qdrant_client::qdrant::{\n    points_update_operation::{\n        ClearPayload, DeletePayload, DeletePoints, DeleteVectors, Operation, OverwritePayload,\n        PointStructList, SetPayload, UpdateVectors,\n    },\n    PointStruct, PointVectors, PointsUpdateOperation, UpdateBatchPointsBuilder, VectorsSelector,\n};\nuse qdrant_client::Payload;\n\nclient\n    .update_points_batch(\n        UpdateBatchPointsBuilder::new(\n            \"{collection_name}\",\n            vec![\n                PointsUpdateOperation {\n                    operation: Some(Operation::Upsert(PointStructList {\n                        points: vec![PointStruct::new(\n                            1,\n                            vec![1.0, 2.0, 3.0, 4.0],\n                            Payload::default(),\n                        )],\n                        ..Default::default()\n                    })),\n                },\n                PointsUpdateOperation {\n                    operation: Some(Operation::UpdateVectors(UpdateVectors {\n                        points: vec![PointVectors {\n                            id: Some(1.into()),\n                            vectors: Some(vec![1.0, 2.0, 3.0, 4.0].into()),\n                        }],\n                        ..Default::default()\n                    })),\n                },\n                PointsUpdateOperation {\n                    operation: Some(Operation::DeleteVectors(DeleteVectors {\n                        points_selector: Some(vec![1.into()].into()),",
      "index": 34,
      "token_count": 414,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 65633,
      "end_char": 67661
    },
    {
      "content": "DeleteVectors(DeleteVectors {\n                        points_selector: Some(vec![1.into()].into()),\n                        vectors: Some(VectorsSelector {\n                            names: vec![\"\".into()],\n                        }),\n                        ..Default::default()\n                    })),\n                },\n                PointsUpdateOperation {\n                    operation: Some(Operation::OverwritePayload(OverwritePayload {\n                        points_selector: Some(vec![1.into()].into()),\n                        payload: HashMap::from([(\"test_payload\".to_string(), 1.into())]),\n                        ..Default::default()\n                    })),\n                },\n                PointsUpdateOperation {\n                    operation: Some(Operation::SetPayload(SetPayload {\n                        points_selector: Some(vec![1.into()].into()),\n                        payload: HashMap::from([\n                            (\"test_payload_2\".to_string(), 2.into()),\n                            (\"test_payload_3\".to_string(), 3.into()),\n                        ]),\n                        ..Default::default()\n                    })),\n                },\n                PointsUpdateOperation {\n                    operation: Some(Operation::DeletePayload(DeletePayload {\n                        points_selector: Some(vec![1.into()].into()),\n                        keys: vec![\"test_payload_2\".to_string()],\n                        ..Default::default()\n                    })),\n                },\n                PointsUpdateOperation {\n                    operation: Some(Operation::ClearPayload(ClearPayload {\n                        points: Some(vec![1.into()].into()),\n                        ..Default::default()\n                    })),\n                },\n                PointsUpdateOperation {\n                    operation: Some(Operation::DeletePoints(DeletePoints {\n                        points: Some(vec![1.into()].into()),\n                        ..Default::default()\n                    })),",
      "index": 35,
      "token_count": 309,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 67561,
      "end_char": 69598
    },
    {
      "content": "Some(vec![1.into()].into()),\n                        ..Default::default()\n                    })),\n                },\n            ],\n        )\n        .wait(true),\n    )\n    .await?;\n```\n\n```java\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.qdrant.client.PointIdFactory.id;\nimport static io.qdrant.client.ValueFactory.value;\nimport static io.qdrant.client.VectorsFactory.vectors;\n\nimport io.qdrant.client.grpc.Points.PointStruct;\nimport io.qdrant.client.grpc.Points.PointVectors;\nimport io.qdrant.client.grpc.Points.PointsIdsList;\nimport io.qdrant.client.grpc.Points.PointsSelector;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation.ClearPayload;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation.DeletePayload;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation.DeletePoints;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation.DeleteVectors;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation.PointStructList;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation.SetPayload;\nimport io.qdrant.client.grpc.Points.PointsUpdateOperation.UpdateVectors;\nimport io.qdrant.client.grpc.Points.VectorsSelector;\n\nclient\n    .batchUpdateAsync(\n        \"{collection_name}\",\n        List.of(\n            PointsUpdateOperation.newBuilder()\n                .setUpsert(\n                    PointStructList.newBuilder()\n                        .addPoints(\n                            PointStruct.newBuilder()\n                                .setId(id(1))\n                                .setVectors(vectors(1.0f, 2.0f, 3.0f, 4.0f))\n                                .build())\n                        .build())\n                .build(),\n            PointsUpdateOperation.newBuilder()\n                .setUpdateVectors(\n                    UpdateVectors.newBuilder()\n                        .addPoints(\n                            PointVectors.newBuilder()\n                                .setId(id(1))\n                                .",
      "index": 36,
      "token_count": 382,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 69498,
      "end_char": 71533
    },
    {
      "content": "Vectors.newBuilder()\n                                .setId(id(1))\n                                .setVectors(vectors(1.0f, 2.0f, 3.0f, 4.0f))\n                                .build())\n                        .build())\n                .build(),\n            PointsUpdateOperation.newBuilder()\n                .setDeleteVectors(\n                    DeleteVectors.newBuilder()\n                        .setPointsSelector(\n                            PointsSelector.newBuilder()\n                                .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())\n                                .build())\n                        .setVectors(VectorsSelector.newBuilder().addNames(\"\").build())\n                        .build())\n                .build(),\n            PointsUpdateOperation.newBuilder()\n                .setOverwritePayload(\n                    SetPayload.newBuilder()\n                        .setPointsSelector(\n                            PointsSelector.newBuilder()\n                                .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())\n                                .build())\n                        .putAllPayload(Map.of(\"test_payload\", value(1)))\n                        .build())\n                .build(),\n            PointsUpdateOperation.newBuilder()\n                .setSetPayload(\n                    SetPayload.newBuilder()\n                        .setPointsSelector(\n                            PointsSelector.newBuilder()\n                                .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())\n                                .build())\n                        .putAllPayload(\n                            Map.of(\"test_payload_2\", value(2), \"test_payload_3\", value(3)))\n                        .build())\n                .build(),\n            PointsUpdateOperation.newBuilder()\n                .setDeletePayload(\n                    DeletePayload.newBuilder()\n                        .setPointsSelector(\n                            PointsSelector.newBuilder()",
      "index": 37,
      "token_count": 313,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 71433,
      "end_char": 73466
    },
    {
      "content": ".setPointsSelector(\n                            PointsSelector.newBuilder()\n                                .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())\n                                .build())\n                        .addKeys(\"test_payload_2\")\n                        .build())\n                .build(),\n            PointsUpdateOperation.newBuilder()\n                .setClearPayload(\n                    ClearPayload.newBuilder()\n                        .setPoints(\n                            PointsSelector.newBuilder()\n                                .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())\n                                .build())\n                        .build())\n                .build(),\n            PointsUpdateOperation.newBuilder()\n                .setDeletePoints(\n                    DeletePoints.newBuilder()\n                        .setPoints(\n                            PointsSelector.newBuilder()\n                                .setPoints(PointsIdsList.newBuilder().addIds(id(1)).build())\n                                .build())\n                        .build())\n                .build()))\n    .get();\n```\n\nTo batch many points with a single operation type, please use batching functionality in that operation directly.\n\n## Awaiting result\n\nIf the API is called with the `&wait=false` parameter, or if it is not explicitly specified, the client will receive an acknowledgment of receiving data:\n\n```json\n{\n  \"result\": {\n    \"operation_id\": 123,\n    \"status\": \"acknowledged\"\n  },\n  \"status\": \"ok\",\n  \"time\": 0.000206061\n}\n```\n\nThis response does not mean that the data is available for retrieval yet. This uses a form of eventual consistency. It may take a short amount of time before it is actually processed as updating the collection happens in the background. In fact, it is possible that such request eventually fails. If inserting a lot of vectors, we also recommend using asynchronous requests to take advantage of pipelining.",
      "index": 38,
      "token_count": 361,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 73366,
      "end_char": 75385
    },
    {
      "content": "g a lot of vectors, we also recommend using asynchronous requests to take advantage of pipelining.\n\nIf the logic of your application requires a guarantee that the vector will be available for searching immediately after the API responds, then use the flag `?wait=true`. In this case, the API will return the result only after the operation is finished:\n\n```json\n{\n  \"result\": {\n    \"operation_id\": 0,\n    \"status\": \"completed\"\n  },\n  \"status\": \"ok\",\n  \"time\": 0.000206061\n}\n```\n\n##### Was this page useful?\n\nYes No\n\nThank you for your feedback! 🙏\n\nWe are sorry to hear that. 😔 You can [edit](https:/github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/points.md) this page on GitHub, or [create](https://github.com/qdrant/landing_page/issues/new/choose) a GitHub issue.\n\nOn this page:\n\n- [Points](#points.md)\n\n  - [Point IDs](#point-ids.md)\n\n  - [Vectors](#vectors.md)\n\n  - [Upload points](#upload-points.md)\n\n  - [Modify points](#modify-points.md)\n\n    - [Update vectors](#update-vectors.md)\n    - [Delete vectors](#delete-vectors.md)\n    - [Update payload](#update-payload.md)\n\n  - [Delete points](#delete-points.md)\n\n  - [Retrieve points](#retrieve-points.md)\n\n  - [Scroll points](#scroll-points.md)\n    - [Order points by payload key](#order-points-by-payload-key.md)\n\n  - [Counting points](#counting-points.md)\n\n  - [Batch update](#batch-update.md)\n\n  - [Awaiting result](#awaiting-result.md)\n\n* [Edit on Github](https://github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/points.md)\n* [Create an issue](https://github.com/qdrant/landing_page/issues/new/choose)\n\n#### Ready to get started with Qdrant?\n\n[Start Free](https://qdrant.to/cloud/)\n\n© 2025 Qdrant.\n\n[Terms](https://qdrant.tech/legal/terms_and_conditions/) [Privacy Policy](https://qdrant.tech/legal/privacy-policy/) [Impressum](https://qdrant.tech/legal/impressum/)",
      "index": 39,
      "token_count": 519,
      "metadata": {
        "title": "_documentation_concepts_points_",
        "source": "qdrant_documentation\\documentation_concepts_points\\_documentation_concepts_points_.md",
        "chunk_method": "simple_fallback",
        "source_repo": "qdrant_documentation",
        "source_subdir": "documentation_concepts_points",
        "category": "concepts",
        "file_path": "documentation_concepts_points\\_documentation_concepts_points_.md",
        "file_name": "_documentation_concepts_points_.md",
        "collection": "qdrant_ecosystem",
        "processed_date": "2025-10-16T01:58:29.886149",
        "total_chunks": 40
      },
      "start_char": 75285,
      "end_char": 77333
    }
  ]
}