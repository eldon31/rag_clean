Automate filtering with LLMs - Qdrant

[](https://qdrant.tech/)

- [Qdrant](https://qdrant.tech/documentation/)
- [Cloud](https://qdrant.tech/documentation/cloud-intro/)
- [Build](https://qdrant.tech/documentation/build/)
- [Learn](https://qdrant.tech/articles/)
- [API Reference](https://api.qdrant.tech/api-reference)

Search

[Log in](https://cloud.qdrant.io/login) [Start Free](https://cloud.qdrant.io/signup)

Search

- [Qdrant](https://qdrant.tech/documentation/)
- [Cloud](https://qdrant.tech/documentation/cloud-intro/)
- [Build](https://qdrant.tech/documentation/build/)
- [Learn](https://qdrant.tech/articles/)
- [API Reference](https://api.qdrant.tech/api-reference)

### Essentials

[Data Ingestion for Beginners](https://qdrant.tech/documentation/data-ingestion-beginners/)

[Simple Agentic RAG System](https://qdrant.tech/documentation/agentic-rag-crewai-zoom/)

[Agentic RAG With LangGraph](https://qdrant.tech/documentation/agentic-rag-langgraph/)

[Agentic RAG Discord Bot with CAMEL-AI](https://qdrant.tech/documentation/agentic-rag-camelai-discord/)

[Multilingual & Multimodal RAG with LlamaIndex](https://qdrant.tech/documentation/multimodal-search/)

[5 Minute RAG with Qdrant and DeepSeek](https://qdrant.tech/documentation/rag-deepseek/)

[Automating Processes with Qdrant and n8n](https://qdrant.tech/documentation/qdrant-n8n/)

### Integrations

[Data Management](https://qdrant.tech/documentation/data-management/)

- [Airbyte](https://qdrant.tech/documentation/data-management/airbyte/)
- [Apache Airflow](https://qdrant.tech/documentation/data-management/airflow/)
- [Apache Spark](https://qdrant.tech/documentation/data-management/spark/)
- [CocoIndex](https://qdrant.tech/documentation/data-management/cocoindex/)
- [cognee](https://qdrant.tech/documentation/data-management/cognee/)
- [Confluent Kafka](https://qdrant.tech/documentation/data-management/confluent/)
- [DLT](https://qdrant.tech/documentation/data-management/dlt/)
- [InfinyOn Fluvio](https://qdrant.tech/documentation/data-management/fluvio/)
- [Redpanda Connect](https://qdrant.tech/documentation/data-management/redpanda/)
- [Unstructured](https://qdrant.tech/documentation/data-management/unstructured/)

[Embeddings](https://qdrant.tech/documentation/embeddings/)

- [Aleph Alpha](https://qdrant.tech/documentation/embeddings/aleph-alpha/)
- [AWS Bedrock](https://qdrant.tech/documentation/embeddings/bedrock/)
- [Cohere](https://qdrant.tech/documentation/embeddings/cohere/)
- [Gemini](https://qdrant.tech/documentation/embeddings/gemini/)
- [Jina Embeddings](https://qdrant.tech/documentation/embeddings/jina-embeddings/)
- [Mistral](https://qdrant.tech/documentation/embeddings/mistral/)
- [MixedBread](https://qdrant.tech/documentation/embeddings/mixedbread/)
- [Mixpeek](https://qdrant.tech/documentation/embeddings/mixpeek/)
- [Nomic](https://qdrant.tech/documentation/embeddings/nomic/)
- [Nvidia](https://qdrant.tech/documentation/embeddings/nvidia/)
- [Ollama](https://qdrant.tech/documentation/embeddings/ollama/)
- [OpenAI](https://qdrant.tech/documentation/embeddings/openai/)
- [Prem AI](https://qdrant.tech/documentation/embeddings/premai/)
- [Snowflake Models](https://qdrant.tech/documentation/embeddings/snowflake/)
- [Twelve Labs](https://qdrant.tech/documentation/embeddings/twelvelabs/)
- [Upstage](https://qdrant.tech/documentation/embeddings/upstage/)
- [Voyage AI](https://qdrant.tech/documentation/embeddings/voyage/)

[Frameworks](https://qdrant.tech/documentation/frameworks/)

- [Autogen](https://qdrant.tech/documentation/frameworks/autogen/)
- [AWS Lakechain](https://qdrant.tech/documentation/frameworks/lakechain/)
- [CamelAI](https://qdrant.tech/documentation/frameworks/camel/)
- [Cheshire Cat](https://qdrant.tech/documentation/frameworks/cheshire-cat/)
- [CrewAI](https://qdrant.tech/documentation/frameworks/crewai/)
- [Dagster](https://qdrant.tech/documentation/frameworks/dagster/)
- [DeepEval](https://qdrant.tech/documentation/frameworks/deepeval/)
- [Dynamiq](https://qdrant.tech/documentation/frameworks/dynamiq/)
- [Feast](https://qdrant.tech/documentation/frameworks/feast/)
- [FiftyOne](https://qdrant.tech/documentation/frameworks/fifty-one/)
- [Firebase Genkit](https://qdrant.tech/documentation/frameworks/genkit/)
- [Haystack](https://qdrant.tech/documentation/frameworks/haystack/)
- [HoneyHive](https://qdrant.tech/documentation/frameworks/honeyhive/)
- [Langchain](https://qdrant.tech/documentation/frameworks/langchain/)
- [Langchain4J](https://qdrant.tech/documentation/frameworks/langchain4j/)
- [LangGraph](https://qdrant.tech/documentation/frameworks/langgraph/)
- [LlamaIndex](https://qdrant.tech/documentation/frameworks/llama-index/)
- [Mastra](https://qdrant.tech/documentation/frameworks/mastra/)
- [Mem0](https://qdrant.tech/documentation/frameworks/mem0/)
- [Microsoft NLWeb](https://qdrant.tech/documentation/frameworks/nlweb/)
- [Neo4j GraphRAG](https://qdrant.tech/documentation/frameworks/neo4j-graphrag/)
- [Rig-rs](https://qdrant.tech/documentation/frameworks/rig-rs/)
- [Semantic-Router](https://qdrant.tech/documentation/frameworks/semantic-router/)
- [SmolAgents](https://qdrant.tech/documentation/frameworks/smolagents/)
- [Spring AI](https://qdrant.tech/documentation/frameworks/spring-ai/)
- [Stanford DSPy](https://qdrant.tech/documentation/frameworks/dspy/)
- [Swiftide](https://qdrant.tech/documentation/frameworks/swiftide/)
- [Sycamore](https://qdrant.tech/documentation/frameworks/sycamore/)
- [Testcontainers](https://qdrant.tech/documentation/frameworks/testcontainers/)
- [txtai](https://qdrant.tech/documentation/frameworks/txtai/)
- [Vanna.AI](https://qdrant.tech/documentation/frameworks/vanna-ai/)
- [VectaX - Mirror Security](https://qdrant.tech/documentation/frameworks/mirror-security/)
- [VoltAgent](https://qdrant.tech/documentation/frameworks/voltagent/)

[Observability](https://qdrant.tech/documentation/observability/)

- [OpenLLMetry](https://qdrant.tech/documentation/observability/openllmetry/)
- [OpenLIT](https://qdrant.tech/documentation/observability/openlit/)
- [Datadog](https://qdrant.tech/documentation/observability/datadog/)

[Platforms](https://qdrant.tech/documentation/platforms/)

- [Apify](https://qdrant.tech/documentation/platforms/apify/)
- [BuildShip](https://qdrant.tech/documentation/platforms/buildship/)
- [Keboola](https://qdrant.tech/documentation/platforms/keboola/)
- [Kotaemon](https://qdrant.tech/documentation/platforms/kotaemon/)
- [Make.com](https://qdrant.tech/documentation/platforms/make/)
- [N8N](https://qdrant.tech/documentation/platforms/n8n/)
- [Pipedream](https://qdrant.tech/documentation/platforms/pipedream/)
- [Power Apps](https://qdrant.tech/documentation/platforms/powerapps/)
- [PrivateGPT](https://qdrant.tech/documentation/platforms/privategpt/)
- [Salesforce Mulesoft](https://qdrant.tech/documentation/platforms/mulesoft/)
- [ToolJet](https://qdrant.tech/documentation/platforms/tooljet/)
- [Vectorize.io](https://qdrant.tech/documentation/platforms/vectorize/)

### Examples

[Search Enhancement](https://qdrant.tech/documentation/search-precision/reranking-semantic-search/)

- [Reranking in Semantic Search](https://qdrant.tech/documentation/search-precision/reranking-semantic-search/)
- [Automate filtering with LLMs](https://qdrant.tech/documentation/search-precision/automate-filtering-with-llms/)

[Send Data to Qdrant](https://qdrant.tech/documentation/send-data/)

- [Qdrant on Databricks](https://qdrant.tech/documentation/send-data/databricks/)
- [Semantic Querying with Airflow and Astronomer](https://qdrant.tech/documentation/send-data/qdrant-airflow-astronomer/)
- [How to Setup Seamless Data Streaming with Kafka and Qdrant](https://qdrant.tech/documentation/send-data/data-streaming-kafka-qdrant/)

[Build Prototypes](https://qdrant.tech/documentation/examples/)

- [GraphRAG with Qdrant and Neo4j](https://qdrant.tech/documentation/examples/graphrag-qdrant-neo4j/)
- [Building a Chain-of-Thought Medical Chatbot with Qdrant and DSPy](https://qdrant.tech/documentation/examples/qdrant-dspy-medicalbot/)
- [Multitenancy with LlamaIndex](https://qdrant.tech/documentation/examples/llama-index-multitenancy/)
- [Private Chatbot for Interactive Learning](https://qdrant.tech/documentation/examples/rag-chatbot-red-hat-openshift-haystack/)
- [Implement Cohere RAG connector](https://qdrant.tech/documentation/examples/cohere-rag-connector/)
- [Question-Answering System for AI Customer Support](https://qdrant.tech/documentation/examples/rag-customer-support-cohere-airbyte-aws/)
- [Chat With Product PDF Manuals Using Hybrid Search](https://qdrant.tech/documentation/examples/hybrid-search-llamaindex-jinaai/)
- [Region-Specific Contract Management System](https://qdrant.tech/documentation/examples/rag-contract-management-stackit-aleph-alpha/)
- [RAG System for Employee Onboarding](https://qdrant.tech/documentation/examples/natural-language-search-oracle-cloud-infrastructure-cohere-langchain/)
- [Private RAG Information Extraction Engine](https://qdrant.tech/documentation/examples/rag-chatbot-vultr-dspy-ollama/)
- [Movie Recommendation System](https://qdrant.tech/documentation/examples/recommendation-system-ovhcloud/)
- [Blog-Reading Chatbot with GPT-4o](https://qdrant.tech/documentation/examples/rag-chatbot-scaleway/)

[Practice Datasets](https://qdrant.tech/documentation/datasets/)

### Essentials

[Data Ingestion for Beginners](https://qdrant.tech/documentation/data-ingestion-beginners/)

[Simple Agentic RAG System](https://qdrant.tech/documentation/agentic-rag-crewai-zoom/)

[Agentic RAG With LangGraph](https://qdrant.tech/documentation/agentic-rag-langgraph/)

[Agentic RAG Discord Bot with CAMEL-AI](https://qdrant.tech/documentation/agentic-rag-camelai-discord/)

[Multilingual & Multimodal RAG with LlamaIndex](https://qdrant.tech/documentation/multimodal-search/)

[5 Minute RAG with Qdrant and DeepSeek](https://qdrant.tech/documentation/rag-deepseek/)

[Automating Processes with Qdrant and n8n](https://qdrant.tech/documentation/qdrant-n8n/)

### Integrations

[Data Management](https://qdrant.tech/documentation/data-management/)

- [Airbyte](https://qdrant.tech/documentation/data-management/airbyte/)
- [Apache Airflow](https://qdrant.tech/documentation/data-management/airflow/)
- [Apache Spark](https://qdrant.tech/documentation/data-management/spark/)
- [CocoIndex](https://qdrant.tech/documentation/data-management/cocoindex/)
- [cognee](https://qdrant.tech/documentation/data-management/cognee/)
- [Confluent Kafka](https://qdrant.tech/documentation/data-management/confluent/)
- [DLT](https://qdrant.tech/documentation/data-management/dlt/)
- [InfinyOn Fluvio](https://qdrant.tech/documentation/data-management/fluvio/)
- [Redpanda Connect](https://qdrant.tech/documentation/data-management/redpanda/)
- [Unstructured](https://qdrant.tech/documentation/data-management/unstructured/)

[Embeddings](https://qdrant.tech/documentation/embeddings/)

- [Aleph Alpha](https://qdrant.tech/documentation/embeddings/aleph-alpha/)
- [AWS Bedrock](https://qdrant.tech/documentation/embeddings/bedrock/)
- [Cohere](https://qdrant.tech/documentation/embeddings/cohere/)
- [Gemini](https://qdrant.tech/documentation/embeddings/gemini/)
- [Jina Embeddings](https://qdrant.tech/documentation/embeddings/jina-embeddings/)
- [Mistral](https://qdrant.tech/documentation/embeddings/mistral/)
- [MixedBread](https://qdrant.tech/documentation/embeddings/mixedbread/)
- [Mixpeek](https://qdrant.tech/documentation/embeddings/mixpeek/)
- [Nomic](https://qdrant.tech/documentation/embeddings/nomic/)
- [Nvidia](https://qdrant.tech/documentation/embeddings/nvidia/)
- [Ollama](https://qdrant.tech/documentation/embeddings/ollama/)
- [OpenAI](https://qdrant.tech/documentation/embeddings/openai/)
- [Prem AI](https://qdrant.tech/documentation/embeddings/premai/)
- [Snowflake Models](https://qdrant.tech/documentation/embeddings/snowflake/)
- [Twelve Labs](https://qdrant.tech/documentation/embeddings/twelvelabs/)
- [Upstage](https://qdrant.tech/documentation/embeddings/upstage/)
- [Voyage AI](https://qdrant.tech/documentation/embeddings/voyage/)

[Frameworks](https://qdrant.tech/documentation/frameworks/)

- [Autogen](https://qdrant.tech/documentation/frameworks/autogen/)
- [AWS Lakechain](https://qdrant.tech/documentation/frameworks/lakechain/)
- [CamelAI](https://qdrant.tech/documentation/frameworks/camel/)
- [Cheshire Cat](https://qdrant.tech/documentation/frameworks/cheshire-cat/)
- [CrewAI](https://qdrant.tech/documentation/frameworks/crewai/)
- [Dagster](https://qdrant.tech/documentation/frameworks/dagster/)
- [DeepEval](https://qdrant.tech/documentation/frameworks/deepeval/)
- [Dynamiq](https://qdrant.tech/documentation/frameworks/dynamiq/)
- [Feast](https://qdrant.tech/documentation/frameworks/feast/)
- [FiftyOne](https://qdrant.tech/documentation/frameworks/fifty-one/)
- [Firebase Genkit](https://qdrant.tech/documentation/frameworks/genkit/)
- [Haystack](https://qdrant.tech/documentation/frameworks/haystack/)
- [HoneyHive](https://qdrant.tech/documentation/frameworks/honeyhive/)
- [Langchain](https://qdrant.tech/documentation/frameworks/langchain/)
- [Langchain4J](https://qdrant.tech/documentation/frameworks/langchain4j/)
- [LangGraph](https://qdrant.tech/documentation/frameworks/langgraph/)
- [LlamaIndex](https://qdrant.tech/documentation/frameworks/llama-index/)
- [Mastra](https://qdrant.tech/documentation/frameworks/mastra/)
- [Mem0](https://qdrant.tech/documentation/frameworks/mem0/)
- [Microsoft NLWeb](https://qdrant.tech/documentation/frameworks/nlweb/)
- [Neo4j GraphRAG](https://qdrant.tech/documentation/frameworks/neo4j-graphrag/)
- [Rig-rs](https://qdrant.tech/documentation/frameworks/rig-rs/)
- [Semantic-Router](https://qdrant.tech/documentation/frameworks/semantic-router/)
- [SmolAgents](https://qdrant.tech/documentation/frameworks/smolagents/)
- [Spring AI](https://qdrant.tech/documentation/frameworks/spring-ai/)
- [Stanford DSPy](https://qdrant.tech/documentation/frameworks/dspy/)
- [Swiftide](https://qdrant.tech/documentation/frameworks/swiftide/)
- [Sycamore](https://qdrant.tech/documentation/frameworks/sycamore/)
- [Testcontainers](https://qdrant.tech/documentation/frameworks/testcontainers/)
- [txtai](https://qdrant.tech/documentation/frameworks/txtai/)
- [Vanna.AI](https://qdrant.tech/documentation/frameworks/vanna-ai/)
- [VectaX - Mirror Security](https://qdrant.tech/documentation/frameworks/mirror-security/)
- [VoltAgent](https://qdrant.tech/documentation/frameworks/voltagent/)

[Observability](https://qdrant.tech/documentation/observability/)

- [OpenLLMetry](https://qdrant.tech/documentation/observability/openllmetry/)
- [OpenLIT](https://qdrant.tech/documentation/observability/openlit/)
- [Datadog](https://qdrant.tech/documentation/observability/datadog/)

[Platforms](https://qdrant.tech/documentation/platforms/)

- [Apify](https://qdrant.tech/documentation/platforms/apify/)
- [BuildShip](https://qdrant.tech/documentation/platforms/buildship/)
- [Keboola](https://qdrant.tech/documentation/platforms/keboola/)
- [Kotaemon](https://qdrant.tech/documentation/platforms/kotaemon/)
- [Make.com](https://qdrant.tech/documentation/platforms/make/)
- [N8N](https://qdrant.tech/documentation/platforms/n8n/)
- [Pipedream](https://qdrant.tech/documentation/platforms/pipedream/)
- [Power Apps](https://qdrant.tech/documentation/platforms/powerapps/)
- [PrivateGPT](https://qdrant.tech/documentation/platforms/privategpt/)
- [Salesforce Mulesoft](https://qdrant.tech/documentation/platforms/mulesoft/)
- [ToolJet](https://qdrant.tech/documentation/platforms/tooljet/)
- [Vectorize.io](https://qdrant.tech/documentation/platforms/vectorize/)

### Examples

[Search Enhancement](https://qdrant.tech/documentation/search-precision/reranking-semantic-search/)

- [Reranking in Semantic Search](https://qdrant.tech/documentation/search-precision/reranking-semantic-search/)
- [Automate filtering with LLMs](https://qdrant.tech/documentation/search-precision/automate-filtering-with-llms/)

[Send Data to Qdrant](https://qdrant.tech/documentation/send-data/)

- [Qdrant on Databricks](https://qdrant.tech/documentation/send-data/databricks/)
- [Semantic Querying with Airflow and Astronomer](https://qdrant.tech/documentation/send-data/qdrant-airflow-astronomer/)
- [How to Setup Seamless Data Streaming with Kafka and Qdrant](https://qdrant.tech/documentation/send-data/data-streaming-kafka-qdrant/)

[Build Prototypes](https://qdrant.tech/documentation/examples/)

- [GraphRAG with Qdrant and Neo4j](https://qdrant.tech/documentation/examples/graphrag-qdrant-neo4j/)
- [Building a Chain-of-Thought Medical Chatbot with Qdrant and DSPy](https://qdrant.tech/documentation/examples/qdrant-dspy-medicalbot/)
- [Multitenancy with LlamaIndex](https://qdrant.tech/documentation/examples/llama-index-multitenancy/)
- [Private Chatbot for Interactive Learning](https://qdrant.tech/documentation/examples/rag-chatbot-red-hat-openshift-haystack/)
- [Implement Cohere RAG connector](https://qdrant.tech/documentation/examples/cohere-rag-connector/)
- [Question-Answering System for AI Customer Support](https://qdrant.tech/documentation/examples/rag-customer-support-cohere-airbyte-aws/)
- [Chat With Product PDF Manuals Using Hybrid Search](https://qdrant.tech/documentation/examples/hybrid-search-llamaindex-jinaai/)
- [Region-Specific Contract Management System](https://qdrant.tech/documentation/examples/rag-contract-management-stackit-aleph-alpha/)
- [RAG System for Employee Onboarding](https://qdrant.tech/documentation/examples/natural-language-search-oracle-cloud-infrastructure-cohere-langchain/)
- [Private RAG Information Extraction Engine](https://qdrant.tech/documentation/examples/rag-chatbot-vultr-dspy-ollama/)
- [Movie Recommendation System](https://qdrant.tech/documentation/examples/recommendation-system-ovhcloud/)
- [Blog-Reading Chatbot with GPT-4o](https://qdrant.tech/documentation/examples/rag-chatbot-scaleway/)

[Practice Datasets](https://qdrant.tech/documentation/datasets/)

- [Documentation](https://qdrant.tech/documentation/)
-
- [Search precision](https://qdrant.tech/documentation/search-precision/)
-
- Automate filtering with LLMs

# Automate filtering with LLMs

Our [complete guide to filtering in vector search](https://qdrant.tech/articles/vector-search-filtering/) describes why filtering is important, and how to implement it with Qdrant. However, applying filters is easier when you build an application with a traditional interface. Your UI may contain a form with checkboxes, sliders, and other elements that users can use to set their criteria. But what if you want to build a RAG-powered application with just the conversational interface, or even voice commands? In this case, you need to automate the filtering process!

LLMs seem to be particularly good at this task. They can understand natural language and generate structured output based on it. In this tutorial, we’ll show you how to use LLMs to automate filtering in your vector search application.

## Few notes on Qdrant filters

Qdrant Python SDK defines the models using [Pydantic](https://docs.pydantic.dev/latest/). This library is de facto standard for data validation and serialization in Python. It allows you to define the structure of your data using Python type hints. For example, our `Filter` model is defined as follows:

```python
class Filter(BaseModel, extra="forbid"):
    should: Optional[Union[List["Condition"], "Condition"]] = Field(
        default=None, description="At least one of those conditions should match"
    )
    min_should: Optional["MinShould"] = Field(
        default=None, description="At least minimum amount of given conditions should match"
    )
    must: Optional[Union[List["Condition"], "Condition"]] = Field(default=None, description="All conditions must match")
    must_not: Optional[Union[List["Condition"], "Condition"]] = Field(
        default=None, description="All conditions must NOT match"
    )
```

Qdrant filters may be nested, and you can express even the most complex conditions using the `must`, `should`, and `must_not` notation.

## Structured output from LLMs

It isn’t an uncommon practice to use LLMs to generate structured output. It is primarily useful if their output is intended for further processing by a different application. For example, you can use LLMs to generate SQL queries, JSON objects, and most importantly, Qdrant filters. Pydantic got adopted by the LLM ecosystem quite well, so there is plenty of libraries which uses Pydantic models to define the structure of the output for the Language Models.

One of the interesting projects in this area is [Instructor](https://python.useinstructor.com/) that allows you to play with different LLM providers and restrict their output to a specific structure. Let’s install the library and already choose a provider we’ll use in this tutorial:

```shell
pip install "instructor[anthropic]"
```

Anthropic is not the only option out there, as Instructor supports many other providers including OpenAI, Ollama, Llama, Gemini, Vertex AI, Groq, Litellm and others. You can choose the one that fits your needs the best, or the one you already use in your RAG.

## Using Instructor to generate Qdrant filters

Instructor has some helper methods to decorate the LLM APIs, so you can interact with them as if you were using their normal SDKs. In case of Anthropic, you just pass an instance of `Anthropic` class to the `from_anthropic` function:

```python
import instructor
from anthropic import Anthropic

anthropic_client = instructor.from_anthropic(
    client=Anthropic(
        api_key="YOUR_API_KEY",
    )
)
```

A decorated client slightly modifies the original API, so you can pass the `response_model` parameter to the `.messages.create` method. This parameter should be a Pydantic model that defines the structure of the output. In case of Qdrant filters, it should be a `Filter` model:

```python
from qdrant_client import models

qdrant_filter = anthropic_client.messages.create(
    model="claude-3-5-sonnet-latest",
    response_model=models.Filter,
    max_tokens=1024,
    messages=[
        {
            "role": "user",
            "content": "red T-shirt"
        }
    ],
)
```

The output of this code will be a Pydantic model that represents a Qdrant filter. Surprisingly, there is no need to pass additional instructions to already figure out that the user wants to filter by the color and the type of the product. Here is how the output looks like:

```python
Filter(
    should=None, 
    min_should=None, 
    must=[
        FieldCondition(
            key="color", 
            match=MatchValue(value="red"), 
            range=None, 
            geo_bounding_box=None, 
            geo_radius=None, 
            geo_polygon=None, 
            values_count=None
        ), 
        FieldCondition(
            key="type", 
            match=MatchValue(value="t-shirt"), 
            range=None, 
            geo_bounding_box=None, 
            geo_radius=None, 
            geo_polygon=None, 
            values_count=None
        )
    ], 
    must_not=None
)
```

Obviously, giving the model complete freedom to generate the filter may lead to unexpected results, or no results at all. Your collection probably has payloads with a specific structure, so it doesn’t make sense to use anything else. Moreover, **it’s considered a good practice to filter by the fields that have been indexed**. That’s why it makes sense to automatically determine the indexed fields and restrict the output to them.

### Restricting the available fields

Qdrant collection info contains a list of the indexes created on a particular collection. You can use this information to automatically determine the fields that can be used for filtering. Here is how you can do it:

```python
from qdrant_client import QdrantClient

client = QdrantClient("http://localhost:6333")
collection_info = client.get_collection(collection_name="test_filter")
indexes = collection_info.payload_schema
print(indexes)
```

Output:

```python
{
    "city.location": PayloadIndexInfo(
        data_type=PayloadSchemaType.GEO,
        ...
    ),
    "city.name": PayloadIndexInfo(
        data_type=PayloadSchemaType.KEYWORD,
        ...
    ),
    "color": PayloadIndexInfo(
        data_type=PayloadSchemaType.KEYWORD,
        ...
    ),
    "fabric": PayloadIndexInfo(
        data_type=PayloadSchemaType.KEYWORD,
        ...
    ),
    "price": PayloadIndexInfo(
        data_type=PayloadSchemaType.FLOAT,
        ...
    ),
}
```

Our LLM should know the names of the fields it can use, but also their type, as e.g., range filtering only makes sense for numerical fields, and geo filtering on non-geo fields won’t yield anything meaningful. You can pass this information as a part of the prompt to the LLM, so let’s encode it as a string:

```python
formatted_indexes = "\n".join([
    f"- {index_name} - {index.data_type.name}"
    for index_name, index in indexes.items()
])
print(formatted_indexes)
```

Output:

```text
- fabric - KEYWORD
- city.name - KEYWORD
- color - KEYWORD
- price - FLOAT
- city.location - GEO
```

**It’s a good idea to cache the list of the available fields and their types**, as they are not supposed to change often. Our interactions with the LLM should be slightly different now:

```python
qdrant_filter = anthropic_client.messages.create(
    model="claude-3-5-sonnet-latest",
    response_model=models.Filter,
    max_tokens=1024,
    messages=[
        {
            "role": "user",
            "content": (
                "<query>color is red</query>"
                f"<indexes>\n{formatted_indexes}\n</indexes>"
            )
        }
    ],
)
```

Output:

```python
Filter(
    should=None, 
    min_should=None, 
    must=FieldCondition(
        key="color", 
        match=MatchValue(value="red"), 
        range=None, 
        geo_bounding_box=None, 
        geo_radius=None, 
        geo_polygon=None, 
        values_count=None
    ), 
    must_not=None
)
```

The same query, restricted to the available fields, now generates better criteria, as it doesn’t try to filter by the fields that don’t exist in the collection.

### Testing the LLM output

Although the LLMs are quite powerful, they are not perfect. If you plan to automate filtering, it makes sense to run some tests to see how well they perform. Especially edge cases, like queries that cannot be expressed as filters. Let’s see how the LLM will handle the following query:

```python
qdrant_filter = anthropic_client.messages.create(
    model="claude-3-5-sonnet-latest",
    response_model=models.Filter,
    max_tokens=1024,
    messages=[
        {
            "role": "user",
            "content": (
                "<query>fruit salad with no more than 100 calories</query>"
                f"<indexes>\n{formatted_indexes}\n</indexes>"
            )
        }
    ],
)
```

Output:

```python
Filter(
    should=None, 
    min_should=None, 
    must=FieldCondition(
        key="price", 
        match=None, 
        range=Range(lt=None, gt=None, gte=None, lte=100.0), 
        geo_bounding_box=None, 
        geo_radius=None, 
        geo_polygon=None, 
        values_count=None
    ), 
    must_not=None
)
```

Surprisingly, the LLM extracted the calorie information from the query and generated a filter based on the price field. It somehow extracts any numerical information from the query and tries to match it with the available fields.

Generally, giving model some more guidance on how to interpret the query may lead to better results. Adding a system prompt that defines the rules for the query interpretation may help the model to do a better job. Here is how you can do it:

```python
SYSTEM_PROMPT = """
You are extracting filters from a text query. Please follow the following rules:
1. Query is provided in the form of a text enclosed in <query> tags.
2. Available indexes are put at the end of the text in the form of a list enclosed in <indexes> tags.
3. You cannot use any field that is not available in the indexes.
4. Generate a filter only if you are certain that user's intent matches the field name.
5. Prices are always in USD.
6. It's better not to generate a filter than to generate an incorrect one.
"""

qdrant_filter = anthropic_client.messages.create(
    model="claude-3-5-sonnet-latest",
    response_model=models.Filter,
    max_tokens=1024,
    messages=[
        {
            "role": "user",
            "content": SYSTEM_PROMPT.strip(),
        },
        {
            "role": "assistant",
            "content": "Okay, I will follow all the rules."
        },
        {
            "role": "user",
            "content": (
                "<query>fruit salad with no more than 100 calories</query>"
                f"<indexes>\n{formatted_indexes}\n</indexes>"
            )
        }
    ],
)
```

Current output:

```python
Filter(
    should=None, 
    min_should=None, 
    must=None, 
    must_not=None
)
```

### Handling complex queries

We have a bunch of indexes created on the collection, and it is quite interesting to see how the LLM will handle more complex queries. For example, let’s see how it will handle the following query:

```python
qdrant_filter = anthropic_client.messages.create(
    model="claude-3-5-sonnet-latest",
    response_model=models.Filter,
    max_tokens=1024,
    messages=[
        {
            "role": "user",
            "content": SYSTEM_PROMPT.strip(),
        },
        {
            "role": "assistant",
            "content": "Okay, I will follow all the rules."
        },
        {
            "role": "user",
            "content": (
                "<query>"
                "white T-shirt available no more than 30 miles from London, "
                "but not in the city itself, below $15.70, not made from polyester"
                "</query>\n"
                "<indexes>\n"
                f"{formatted_indexes}\n"
                "</indexes>"
            )
        },
    ],
)
```

It might be surprising, but Anthropic Claude is able to generate even such complex filters. Here is the output:

```python
Filter(
    should=None, 
    min_should=None, 
    must=[
        FieldCondition(
            key="color", 
            match=MatchValue(value="white"), 
            range=None, 
            geo_bounding_box=None, 
            geo_radius=None, 
            geo_polygon=None, 
            values_count=None
        ), 
        FieldCondition(
            key="city.location", 
            match=None, 
            range=None, 
            geo_bounding_box=None, 
            geo_radius=GeoRadius(
                center=GeoPoint(lon=-0.1276, lat=51.5074), 
                radius=48280.0
            ), 
            geo_polygon=None, 
            values_count=None
        ), 
        FieldCondition(
            key="price", 
            match=None, 
            range=Range(lt=15.7, gt=None, gte=None, lte=None), 
            geo_bounding_box=None,
            geo_radius=None, 
            geo_polygon=None, 
            values_count=None
        )
    ], must_not=[
        FieldCondition(
            key="city.name", 
            match=MatchValue(value="London"), 
            range=None, 
            geo_bounding_box=None, 
            geo_radius=None, 
            geo_polygon=None, 
            values_count=None
        ), 
        FieldCondition(
            key="fabric", 
            match=MatchValue(value="polyester"),
            range=None, 
            geo_bounding_box=None, 
            geo_radius=None,
            geo_polygon=None, 
            values_count=None
        )
    ]
)
```

The model even knows the coordinates of London and uses them to generate the geo filter. It isn’t the best idea to rely on the model to generate such complex filters, but it’s quite impressive that it can do it.

## Further steps

Real production systems would rather require more testing and validation of the LLM output. Building a ground truth dataset with the queries and the expected filters would be a good idea. You can use this dataset to evaluate the model performance and to see how it behaves in different scenarios.

##### Was this page useful?

Yes No

Thank you for your feedback! 🙏

We are sorry to hear that. 😔 You can [edit](https:/github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/search-precision/automate-filtering-with-llms.md) this page on GitHub, or [create](https://github.com/qdrant/landing_page/issues/new/choose) a GitHub issue.

On this page:

- [Automate filtering with LLMs](#automate-filtering-with-llms.md)

  - [Few notes on Qdrant filters](#few-notes-on-qdrant-filters.md)

  - [Structured output from LLMs](#structured-output-from-llms.md)

  - [Using Instructor to generate Qdrant filters](#using-instructor-to-generate-qdrant-filters.md)

    - [Restricting the available fields](#restricting-the-available-fields.md)
    - [Testing the LLM output](#testing-the-llm-output.md)
    - [Handling complex queries](#handling-complex-queries.md)

  - [Further steps](#further-steps.md)

* [Edit on Github](https://github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/search-precision/automate-filtering-with-llms.md)
* [Create an issue](https://github.com/qdrant/landing_page/issues/new/choose)

#### Ready to get started with Qdrant?

[Start Free](https://qdrant.to/cloud/)

© 2025 Qdrant.

[Terms](https://qdrant.tech/legal/terms_and_conditions/) [Privacy Policy](https://qdrant.tech/legal/privacy-policy/) [Impressum](https://qdrant.tech/legal/impressum/)
