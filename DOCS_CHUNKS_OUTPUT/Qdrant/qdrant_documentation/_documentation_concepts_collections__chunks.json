[
  {
    "text": "Collections - Qdrant\n\n[](https://qdrant.tech/)\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\nSearch\n\n[Log in](https://cloud.qdrant.io/login) [Start Free](https://cloud.qdrant.io/signup)\n\nSearch\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)",
    "metadata": {
      "chunk_id": 0,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 964,
      "character_count": 3779,
      "created_at": "2025-10-16T17:42:22.357596",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 0,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)",
    "metadata": {
      "chunk_id": 1,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 852,
      "character_count": 3535,
      "created_at": "2025-10-16T17:42:22.361804",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 1,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n- [Documentation](https://qdrant.tech/documentation/)\n-\n- [Concepts](https://qdrant.tech/documentation/concepts/)\n-\n- Collections\n\n# Collections",
    "metadata": {
      "chunk_id": 2,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1003,
      "character_count": 4144,
      "created_at": "2025-10-16T17:42:22.367564",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 2,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "A collection is a named set of points (vectors with a payload) among which you can search. The vector of each point within the same collection must have the same dimensionality and be compared by a single metric. [Named vectors](#collection-with-multiple-vectors.md) can be used to have multiple vectors in a single point, each of which can have their own dimensionality and metric requirements.\n\nDistance metrics are used to measure similarities among vectors. The choice of metric depends on the way vectors obtaining and, in particular, on the method of neural network encoder training.\n\nQdrant supports these most popular types of metrics:\n\n- Dot product: `Dot` - [\\[wiki\\]](https://en.wikipedia.org/wiki/Dot_product)\n- Cosine similarity: `Cosine` - [\\[wiki\\]](https://en.wikipedia.org/wiki/Cosine_similarity)\n- Euclidean distance: `Euclid` - [\\[wiki\\]](https://en.wikipedia.org/wiki/Euclidean_distance)\n- Manhattan distance: `Manhattan` - [\\[wiki\\]](https://en.wikipedia.org/wiki/Taxicab_geometry)\n\nFor search efficiency, Cosine similarity is implemented as dot-product over normalized vectors. Vectors are automatically normalized during upload\n\nIn addition to metrics and vector size, each collection uses its own set of parameters that controls collection optimization, index construction, and vacuum. These settings can be changed at any time by a corresponding request.\n\n## Setting up multitenancy\n\n**How many collections should you create?** In most cases, you should only use a single collection with payload-based partitioning. This approach is called [multitenancy](https://en.wikipedia.org/wiki/Multitenancy). It is efficient for most of users, but it requires additional configuration. [Learn how to set it up](https://qdrant.tech/documentation/tutorials/multiple-partitions/)\n\n**When should you create multiple collections?** When you have a limited number of users and you need isolation. This approach is flexible, but it may be more costly, since creating numerous collections may result in resource overhead. Also, you need to ensure that they do not affect each other in any way, including performance-wise.\n\n## Create a collection\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 300,\n      \"distance\": \"Cosine\"\n    }\n}\n```\n\n```bash\ncurl -X PUT http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vectors\": {\n      \"size\": 300,\n      \"distance\": \"Cosine\"\n    } \n  }'\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=100, distance=models.Distance.COSINE),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: { size: 100, distance: \"Cosine\" },\n});\n```\n\n```rust\nuse qdrant_client::Qdrant;\nuse qdrant_client::qdrant::{CreateCollectionBuilder, VectorParamsBuilder};\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(100, Distance::Cosine)),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\n\nQdrantClient client = new QdrantClient(\n    QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient.createCollectionAsync(\"{collection_name}\",\n        VectorParams.newBuilder().setDistance(Distance.Cosine).setSize(100).build()).get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\tvectorsConfig: new VectorParams { Size = 100, Distance = Distance.Cosine }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})",
    "metadata": {
      "chunk_id": 3,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1008,
      "character_count": 4230,
      "created_at": "2025-10-16T17:42:22.377363",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 3,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     100,\n\t\tDistance: qdrant.Distance_Cosine,\n\t}),\n})\n```\n\nIn addition to the required options, you can also specify custom values for the following collection options:\n\n- `hnsw_config` - see [indexing](https://qdrant.tech/documentation/concepts/indexing/#vector-index) for details.\n- `wal_config` - Write-Ahead-Log related configuration. See more details about [WAL](https://qdrant.tech/documentation/concepts/storage/#versioning)\n- `optimizers_config` - see [optimizer](https://qdrant.tech/documentation/concepts/optimizer/) for details.\n- `shard_number` - which defines how many shards the collection should have. See [distributed deployment](https://qdrant.tech/documentation/guides/distributed_deployment/#sharding) section for details.\n- `on_disk_payload` - defines where to store payload data. If `true` - payload will be stored on disk only. Might be useful for limiting the RAM usage in case of large payload.\n- `quantization_config` - see [quantization](https://qdrant.tech/documentation/guides/quantization/#setting-up-quantization-in-qdrant) for details.\n- `strict_mode_config` - see [strict mode](https://qdrant.tech/documentation/guides/administration/#strict-mode) for details.\n\nDefault parameters for the optional collection parameters are defined in [configuration file](https://github.com/qdrant/qdrant/blob/master/config/config.yaml).\n\nSee [schema definitions](https://api.qdrant.tech/api-reference/collections/create-collection) and a [configuration file](https://github.com/qdrant/qdrant/blob/master/config/config.yaml) for more information about collection and vector parameters.\n\n*Available as of v1.2.0*\n\nVectors all live in RAM for very quick access. The `on_disk` parameter can be set in the vector configuration. If true, all vectors will live on disk. This will enable the use of [memmaps](https://qdrant.tech/documentation/concepts/storage/#configuring-memmap-storage), which is suitable for ingesting a large amount of data.\n\n### Create collection from another collection\n\n*Available as of v1.0.0*\n\nIt is possible to initialize a collection from another existing collection.\n\nThis might be useful for experimenting quickly with different configurations for the same data set.\n\nUsage of the `init_from` can create unpredictable load on the qdrant cluster. It is not recommended to use `init_from` in performance-sensitive environments.\n\nMake sure the vectors have the same `size` and `distance` function when setting up the vectors configuration in the new collection. If you used the previous sample code, `\"size\": 300` and `\"distance\": \"Cosine\"`.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 100,\n      \"distance\": \"Cosine\"\n    },\n    \"init_from\": {\n       \"collection\": \"{from_collection_name}\"\n    }\n}\n```\n\n```bash\ncurl -X PUT http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vectors\": {\n      \"size\": 300,\n      \"distance\": \"Cosine\"\n    },\n    \"init_from\": {\n       \"collection\": {from_collection_name}\n    }\n  }'\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=100, distance=models.Distance.COSINE),\n    init_from=models.InitFrom(collection=\"{from_collection_name}\"),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: { size: 100, distance: \"Cosine\" },\n  init_from: { collection: \"{from_collection_name}\" },\n});\n```\n\n```rust\nuse qdrant_client::Qdrant;\nuse qdrant_client::qdrant::{CreateCollectionBuilder, Distance, VectorParamsBuilder};\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(100, Distance::Cosine))\n            .init_from_collection(\"{from_collection_name}\"),\n    )\n    .await?;\n```",
    "metadata": {
      "chunk_id": 4,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1017,
      "character_count": 4297,
      "created_at": "2025-10-16T17:42:22.385793",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 4,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(100)\n                            .setDistance(Distance.Cosine)\n                            .build()))\n            .setInitFromCollection(\"{from_collection_name}\")\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\tvectorsConfig: new VectorParams { Size = 100, Distance = Distance.Cosine },\n\tinitFromCollection: \"{from_collection_name}\"\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     100,\n\t\tDistance: qdrant.Distance_Cosine,\n\t}),\n\tInitFromCollection: qdrant.PtrOf(\"{from_collection_name}\"),\n})\n```\n\n### Collection with multiple vectors\n\n*Available as of v0.10.0*\n\nIt is possible to have multiple vectors per record. This feature allows for multiple vector storages per collection. To distinguish vectors in one record, they should have a unique name defined when creating the collection. Each named vector in this mode has its distance and size:\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n        \"image\": {\n            \"size\": 4,\n            \"distance\": \"Dot\"\n        },\n        \"text\": {\n            \"size\": 8,\n            \"distance\": \"Cosine\"\n        }\n    }\n}\n```\n\n```bash\ncurl -X PUT http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vectors\": {\n        \"image\": {\n            \"size\": 4,\n            \"distance\": \"Dot\"\n        },\n        \"text\": {\n            \"size\": 8,\n            \"distance\": \"Cosine\"\n        }\n      }\n    }'\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config={\n        \"image\": models.VectorParams(size=4, distance=models.Distance.DOT),\n        \"text\": models.VectorParams(size=8, distance=models.Distance.COSINE),\n    },\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: {\n    image: { size: 4, distance: \"Dot\" },\n    text: { size: 8, distance: \"Cosine\" },\n  },\n});\n```\n\n```rust\nuse qdrant_client::Qdrant;\nuse qdrant_client::qdrant::{\n    CreateCollectionBuilder, Distance, VectorParamsBuilder, VectorsConfigBuilder,\n};\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nlet mut vectors_config = VectorsConfigBuilder::default();\nvectors_config\n    .add_named_vector_params(\"image\", VectorParamsBuilder::new(4, Distance::Dot).build());\nvectors_config.add_named_vector_params(\n    \"text\",\n    VectorParamsBuilder::new(8, Distance::Cosine).build(),\n);\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\").vectors_config(vectors_config),\n    )\n    .await?;\n```\n\n```java\nimport java.util.Map;\n\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.VectorParams;",
    "metadata": {
      "chunk_id": 5,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1002,
      "character_count": 4146,
      "created_at": "2025-10-16T17:42:22.395803",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 5,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "QdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        \"{collection_name}\",\n        Map.of(\n            \"image\", VectorParams.newBuilder().setSize(4).setDistance(Distance.Dot).build(),\n            \"text\",\n                VectorParams.newBuilder().setSize(8).setDistance(Distance.Cosine).build()))\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\tvectorsConfig: new VectorParamsMap\n\t{\n\t\tMap =\n\t\t{\n\t\t\t[\"image\"] = new VectorParams { Size = 4, Distance = Distance.Dot },\n\t\t\t[\"text\"] = new VectorParams { Size = 8, Distance = Distance.Cosine },\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfigMap(\n\t\tmap[string]*qdrant.VectorParams{\n\t\t\t\"image\": {\n\t\t\t\tSize:     4,\n\t\t\t\tDistance: qdrant.Distance_Dot,\n\t\t\t},\n\t\t\t\"text\": {\n\t\t\t\tSize:     8,\n\t\t\t\tDistance: qdrant.Distance_Cosine,\n\t\t\t},\n\t\t}),\n})\n```\n\nFor rare use cases, it is possible to create a collection without any vector storage.\n\n*Available as of v1.1.1*\n\nFor each named vector you can optionally specify [`hnsw_config`](https://qdrant.tech/documentation/concepts/indexing/#vector-index) or [`quantization_config`](https://qdrant.tech/documentation/guides/quantization/#setting-up-quantization-in-qdrant) to deviate from the collection configuration. This can be useful to fine-tune search performance on a vector level.\n\n*Available as of v1.2.0*\n\nVectors all live in RAM for very quick access. On a per-vector basis you can set `on_disk` to true to store all vectors on disk at all times. This will enable the use of [memmaps](https://qdrant.tech/documentation/concepts/storage/#configuring-memmap-storage), which is suitable for ingesting a large amount of data.\n\n### Vector datatypes\n\n*Available as of v1.9.0*\n\nSome embedding providers may provide embeddings in a pre-quantized format. One of the most notable examples is the [Cohere int8 & binary embeddings](https://cohere.com/blog/int8-binary-embeddings). Qdrant has direct support for uint8 embeddings, which you can also use in combination with binary quantization.\n\nTo create a collection with uint8 embeddings, you can use the following configuration:\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 1024,\n      \"distance\": \"Cosine\",\n      \"datatype\": \"uint8\"\n    }\n}\n```\n\n```bash\ncurl -X PUT http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vectors\": {\n      \"size\": 1024,\n      \"distance\": \"Cosine\",\n      \"datatype\": \"uint8\"\n    }\n  }'\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(\n        size=1024,\n        distance=models.Distance.COSINE,\n        datatype=models.Datatype.UINT8,\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: {\n    image: { size: 1024, distance: \"Cosine\", datatype: \"uint8\" },\n  },\n});\n```\n\n```rust\nuse qdrant_client::Qdrant;\nuse qdrant_client::qdrant::{\n    CreateCollectionBuilder, Datatype, Distance, VectorParamsBuilder,\n};\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;",
    "metadata": {
      "chunk_id": 6,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 987,
      "character_count": 3772,
      "created_at": "2025-10-16T17:42:22.405261",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 6,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\").vectors_config(\n            VectorParamsBuilder::new(1024, Distance::Cosine).datatype(Datatype::Uint8),\n        ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.grpc.Collections.Datatype;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.VectorParams;\n\nQdrantClient client = new QdrantClient(\n    QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\"{collection_name}\",\n        VectorParams.newBuilder()\n            .setSize(1024)\n            .setDistance(Distance.Cosine)\n            .setDatatype(Datatype.Uint8)\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n  collectionName: \"{collection_name}\",\n  vectorsConfig: new VectorParams {\n    Size = 1024, Distance = Distance.Cosine, Datatype = Datatype.Uint8\n  }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     1024,\n\t\tDistance: qdrant.Distance_Cosine,\n\t\tDatatype: qdrant.Datatype_Uint8.Enum(),\n\t}),\n})\n```\n\nVectors with `uint8` datatype are stored in a more compact format, which can save memory and improve search speed at the cost of some precision. If you choose to use the `uint8` datatype, elements of the vector will be stored as unsigned 8-bit integers, which can take values **from 0 to 255**.\n\n### Collection with sparse vectors\n\n*Available as of v1.7.0*\n\nQdrant supports sparse vectors as a first-class citizen.\n\nSparse vectors are useful for text search, where each word is represented as a separate dimension.\n\nCollections can contain sparse vectors as additional [named vectors](#collection-with-multiple-vectors.md) along side regular dense vectors in a single point.\n\nUnlike dense vectors, sparse vectors must be named. And additionally, sparse vectors and dense vectors must have different names within a collection.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"sparse_vectors\": {\n        \"text\": { }\n    }\n}\n```\n\n```bash\ncurl -X PUT http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"sparse_vectors\": {\n        \"text\": { }\n    }\n  }'\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config={},\n    sparse_vectors_config={\n        \"text\": models.SparseVectorParams(),\n    },\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  sparse_vectors: {\n    text: { },\n  },\n});\n```\n\n```rust\nuse qdrant_client::Qdrant;\nuse qdrant_client::qdrant::{\n    CreateCollectionBuilder, SparseVectorParamsBuilder, SparseVectorsConfigBuilder,\n};\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nlet mut sparse_vector_config = SparseVectorsConfigBuilder::default();\n\nsparse_vector_config.add_named_vector_params(\"text\", SparseVectorParamsBuilder::default());\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .sparse_vectors_config(sparse_vector_config),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.SparseVectorConfig;\nimport io.qdrant.client.grpc.Collections.SparseVectorParams;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());",
    "metadata": {
      "chunk_id": 7,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 992,
      "character_count": 4085,
      "created_at": "2025-10-16T17:42:22.416386",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 7,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setSparseVectorsConfig(\n                SparseVectorConfig.newBuilder()\n                    .putMap(\"text\", SparseVectorParams.getDefaultInstance()))\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\tsparseVectorsConfig: (\"text\", new SparseVectorParams())\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tSparseVectorsConfig: qdrant.NewSparseVectorsConfig(\n\t\tmap[string]*qdrant.SparseVectorParams{\n\t\t\t\"text\": {},\n\t\t}),\n})\n```\n\nOutside of a unique name, there are no required configuration parameters for sparse vectors.\n\nThe distance function for sparse vectors is always `Dot` and does not need to be specified.\n\nHowever, there are optional parameters to tune the underlying [sparse vector index](https://qdrant.tech/documentation/concepts/indexing/#sparse-vector-index).\n\n### Check collection existence\n\n*Available as of v1.8.0*\n\n```http\nGET http://localhost:6333/collections/{collection_name}/exists\n```\n\n```bash\ncurl -X GET http://localhost:6333/collections/{collection_name}/exists\n```\n\n```python\nclient.collection_exists(collection_name=\"{collection_name}\")\n```\n\n```typescript\nclient.collectionExists(\"{collection_name}\");\n```\n\n```rust\nclient.collection_exists(\"{collection_name}\").await?;\n```\n\n```java\nclient.collectionExistsAsync(\"{collection_name}\").get();\n```\n\n```csharp\nawait client.CollectionExistsAsync(\"{collection_name}\");\n```\n\n```go\nimport \"context\"\n\nclient.CollectionExists(context.Background(), \"my_collection\")\n```\n\n### Delete collection\n\n```http\nDELETE http://localhost:6333/collections/{collection_name}\n```\n\n```bash\ncurl -X DELETE http://localhost:6333/collections/{collection_name}\n```\n\n```python\nclient.delete_collection(collection_name=\"{collection_name}\")\n```\n\n```typescript\nclient.deleteCollection(\"{collection_name}\");\n```\n\n```rust\nclient.delete_collection(\"{collection_name}\").await?;\n```\n\n```java\nclient.deleteCollectionAsync(\"{collection_name}\").get();\n```\n\n```csharp\nawait client.DeleteCollectionAsync(\"{collection_name}\");\n```\n\n```go\nimport \"context\"\n\nclient.DeleteCollection(context.Background(), \"{collection_name}\")\n```\n\n### Update collection parameters\n\nDynamic parameter updates may be helpful, for example, for more efficient initial loading of vectors. For example, you can disable indexing during the upload process, and enable it immediately after the upload is finished. As a result, you will not waste extra computation resources on rebuilding the index.\n\nThe following command enables indexing for segments that have more than 10000 kB of vectors stored:\n\n```http\nPATCH /collections/{collection_name}\n{\n    \"optimizers_config\": {\n        \"indexing_threshold\": 10000\n    }\n}\n```\n\n```bash\ncurl -X PATCH http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"optimizers_config\": {\n        \"indexing_threshold\": 10000\n    }\n  }'\n```\n\n```python\nclient.update_collection(\n    collection_name=\"{collection_name}\",\n    optimizers_config=models.OptimizersConfigDiff(indexing_threshold=10000),\n)\n```\n\n```typescript\nclient.updateCollection(\"{collection_name}\", {\n  optimizers_config: {\n    indexing_threshold: 10000,\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{OptimizersConfigDiffBuilder, UpdateCollectionBuilder};\n\nclient\n    .update_collection(\n        UpdateCollectionBuilder::new(\"{collection_name}\").optimizers_config(\n            OptimizersConfigDiffBuilder::default().indexing_threshold(10000),\n        ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.grpc.Collections.OptimizersConfigDiff;\nimport io.qdrant.client.grpc.Collections.UpdateCollection;\n\nclient.updateCollectionAsync(\n    UpdateCollection.newBuilder()\n        .setCollectionName(\"{collection_name}\")\n        .setOptimizersConfig(\n            OptimizersConfigDiff.newBuilder().setIndexingThreshold(10000).build())\n        .build());\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);",
    "metadata": {
      "chunk_id": 8,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 999,
      "character_count": 4458,
      "created_at": "2025-10-16T17:42:22.429579",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 8,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "await client.UpdateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\toptimizersConfig: new OptimizersConfigDiff { IndexingThreshold = 10000 }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.UpdateCollection(context.Background(), &qdrant.UpdateCollection{\n\tCollectionName: \"{collection_name}\",\n\tOptimizersConfig: &qdrant.OptimizersConfigDiff{\n\t\tIndexingThreshold: qdrant.PtrOf(uint64(10000)),\n\t},\n})\n```\n\nThe following parameters can be updated:\n\n- `optimizers_config` - see [optimizer](https://qdrant.tech/documentation/concepts/optimizer/) for details.\n- `hnsw_config` - see [indexing](https://qdrant.tech/documentation/concepts/indexing/#vector-index) for details.\n- `quantization_config` - see [quantization](https://qdrant.tech/documentation/guides/quantization/#setting-up-quantization-in-qdrant) for details.\n- `vectors_config` - vector-specific configuration, including individual `hnsw_config`, `quantization_config` and `on_disk` settings.\n- `params` - other collection parameters, including `write_consistency_factor` and `on_disk_payload`.\n- `strict_mode_config` - see [strict mode](https://qdrant.tech/documentation/guides/administration/#strict-mode) for details.\n\nFull API specification is available in [schema definitions](https://api.qdrant.tech/api-reference/collections/update-collection).\n\nCalls to this endpoint may be blocking as it waits for existing optimizers to finish. We recommended against using this in a production database as it may introduce huge overhead due to the rebuilding of the index.\n\n#### Update vector parameters\n\n*Available as of v1.4.0*\n\nTo update vector parameters using the collection update API, you must always specify a vector name. If your collection does not have named vectors, use an empty (`\"\"`) name.\n\nQdrant 1.4 adds support for updating more collection parameters at runtime. HNSW index, quantization and disk configurations can now be changed without recreating a collection. Segments (with index and quantized data) will automatically be rebuilt in the background to match updated parameters.\n\nTo put vector data on disk for a collection that **does not have** named vectors, use `\"\"` as name:\n\n```http\nPATCH /collections/{collection_name}\n{\n    \"vectors\": {\n        \"\": {\n            \"on_disk\": true\n        }\n    }\n}\n```\n\n```bash\ncurl -X PATCH http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vectors\": {\n        \"\": { \n            \"on_disk\": true \n      }\n    }\n  }'\n```\n\nTo put vector data on disk for a collection that **does have** named vectors:\n\nNote: To create a vector name, follow the procedure from our [Points](https://qdrant.tech/documentation/concepts/points/#create-vector-name).\n\n```http\nPATCH /collections/{collection_name}\n{\n    \"vectors\": {\n        \"my_vector\": {\n            \"on_disk\": true\n        }\n    }\n}\n```\n\n```bash\ncurl -X PATCH http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vectors\": {\n        \"my_vector\": { \n           \"on_disk\": true \n      }\n    }\n  }'\n```\n\nIn the following example the HNSW index and quantization parameters are updated, both for the whole collection, and for `my_vector` specifically:\n\n```http\nPATCH /collections/{collection_name}\n{\n    \"vectors\": {\n        \"my_vector\": {\n            \"hnsw_config\": {\n                \"m\": 32,\n                \"ef_construct\": 123\n            },\n            \"quantization_config\": {\n                \"product\": {\n                    \"compression\": \"x32\",\n                    \"always_ram\": true\n                }\n            },\n            \"on_disk\": true\n        }\n    },\n    \"hnsw_config\": {\n        \"ef_construct\": 123\n    },\n    \"quantization_config\": {\n        \"scalar\": {\n            \"type\": \"int8\",\n            \"quantile\": 0.8,\n            \"always_ram\": false\n        }\n    }\n}\n```",
    "metadata": {
      "chunk_id": 9,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 959,
      "character_count": 3989,
      "created_at": "2025-10-16T17:42:22.435818",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 9,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```bash\ncurl -X PATCH http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"vectors\": {\n        \"my_vector\": {\n            \"hnsw_config\": {\n                \"m\": 32,\n                \"ef_construct\": 123\n            },\n            \"quantization_config\": {\n                \"product\": {\n                    \"compression\": \"x32\",\n                    \"always_ram\": true\n                }\n            },\n            \"on_disk\": true\n        }\n    },\n    \"hnsw_config\": {\n        \"ef_construct\": 123\n    },\n    \"quantization_config\": {\n        \"scalar\": {\n            \"type\": \"int8\",\n            \"quantile\": 0.8,\n            \"always_ram\": false\n        }\n    }\n}'\n```\n\n```python\nclient.update_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config={\n        \"my_vector\": models.VectorParamsDiff(\n            hnsw_config=models.HnswConfigDiff(\n                m=32,\n                ef_construct=123,\n            ),\n            quantization_config=models.ProductQuantization(\n                product=models.ProductQuantizationConfig(\n                    compression=models.CompressionRatio.X32,\n                    always_ram=True,\n                ),\n            ),\n            on_disk=True,\n        ),\n    },\n    hnsw_config=models.HnswConfigDiff(\n        ef_construct=123,\n    ),\n    quantization_config=models.ScalarQuantization(\n        scalar=models.ScalarQuantizationConfig(\n            type=models.ScalarType.INT8,\n            quantile=0.8,\n            always_ram=False,\n        ),\n    ),\n)\n```\n\n```typescript\nclient.updateCollection(\"{collection_name}\", {\n  vectors: {\n    my_vector: {\n      hnsw_config: {\n        m: 32,\n        ef_construct: 123,\n      },\n      quantization_config: {\n        product: {\n          compression: \"x32\",\n          always_ram: true,\n        },\n      },\n      on_disk: true,\n    },\n  },\n  hnsw_config: {\n    ef_construct: 123,\n  },\n  quantization_config: {\n    scalar: {\n      type: \"int8\",\n      quantile: 0.8,\n      always_ram: true,\n    },\n  },\n});\n```\n\n```rust\nuse std::collections::HashMap;\n\nuse qdrant_client::qdrant::{\n    quantization_config_diff::Quantization, vectors_config_diff::Config, HnswConfigDiffBuilder,\n    QuantizationType, ScalarQuantizationBuilder, UpdateCollectionBuilder, VectorParamsDiffBuilder,\n    VectorParamsDiffMap,\n};\n\nclient\n    .update_collection(\n        UpdateCollectionBuilder::new(\"{collection_name}\")\n            .hnsw_config(HnswConfigDiffBuilder::default().ef_construct(123))\n            .vectors_config(Config::ParamsMap(VectorParamsDiffMap {\n                map: HashMap::from([(\n                    (\"my_vector\".into()),\n                    VectorParamsDiffBuilder::default()\n                        .hnsw_config(HnswConfigDiffBuilder::default().m(32).ef_construct(123))\n                        .build(),\n                )]),\n            }))\n            .quantization_config(Quantization::Scalar(\n                ScalarQuantizationBuilder::default()\n                    .r#type(QuantizationType::Int8.into())\n                    .quantile(0.8)\n                    .always_ram(true)\n                    .build(),\n            )),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.grpc.Collections.HnswConfigDiff;\nimport io.qdrant.client.grpc.Collections.QuantizationConfigDiff;\nimport io.qdrant.client.grpc.Collections.QuantizationType;\nimport io.qdrant.client.grpc.Collections.ScalarQuantization;\nimport io.qdrant.client.grpc.Collections.UpdateCollection;\nimport io.qdrant.client.grpc.Collections.VectorParamsDiff;\nimport io.qdrant.client.grpc.Collections.VectorParamsDiffMap;\nimport io.qdrant.client.grpc.Collections.VectorsConfigDiff;\n\nclient\n    .updateCollectionAsync(\n        UpdateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setHnswConfig(HnswConfigDiff.newBuilder().setEfConstruct(123).build())\n            .setVectorsConfig(\n                VectorsConfigDiff.newBuilder()\n                    .setParamsMap(\n                        VectorParamsDiffMap.newBuilder()\n                            .putMap(\n                                \"my_vector\",\n                                VectorParamsDiff.newBuilder()\n                                    .setHnswConfig(\n                                        HnswConfigDiff.newBuilder()\n                                            .setM(3)\n                                            .setEfConstruct(123)\n                                            .build())\n                                    .build())))\n            .setQuantizationConfig(\n                QuantizationConfigDiff.newBuilder()\n                    .setScalar(\n                        ScalarQuantization.newBuilder()\n                            .setType(QuantizationType.Int8)\n                            .setQuantile(0.8f)\n                            .setAlwaysRam(true)\n                            .build()))\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;",
    "metadata": {
      "chunk_id": 10,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1023,
      "character_count": 5018,
      "created_at": "2025-10-16T17:42:22.440955",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 10,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "var client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpdateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\thnswConfig: new HnswConfigDiff { EfConstruct = 123 },\n\tvectorsConfig: new VectorParamsDiffMap\n\t{\n\t\tMap =\n\t\t{\n\t\t\t{\n\t\t\t\t\"my_vector\",\n\t\t\t\tnew VectorParamsDiff\n\t\t\t\t{\n\t\t\t\t\tHnswConfig = new HnswConfigDiff { M = 3, EfConstruct = 123 }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tquantizationConfig: new QuantizationConfigDiff\n\t{\n\t\tScalar = new ScalarQuantization\n\t\t{\n\t\t\tType = QuantizationType.Int8,\n\t\t\tQuantile = 0.8f,\n\t\t\tAlwaysRam = true\n\t\t}\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.UpdateCollection(context.Background(), &qdrant.UpdateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfigDiffMap(\n\t\tmap[string]*qdrant.VectorParamsDiff{\n\t\t\t\"my_vector\": {\n\t\t\t\tHnswConfig: &qdrant.HnswConfigDiff{\n\t\t\t\t\tM:           qdrant.PtrOf(uint64(3)),\n\t\t\t\t\tEfConstruct: qdrant.PtrOf(uint64(123)),\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\tQuantizationConfig: qdrant.NewQuantizationDiffScalar(\n\t\t&qdrant.ScalarQuantization{\n\t\t\tType:      qdrant.QuantizationType_Int8,\n\t\t\tQuantile:  qdrant.PtrOf(float32(0.8)),\n\t\t\tAlwaysRam: qdrant.PtrOf(true),\n\t\t}),\n})\n```\n\n## Collection info\n\nQdrant allows determining the configuration parameters of an existing collection to better understand how the points are distributed and indexed.\n\n```http\nGET /collections/{collection_name}\n```\n\n```bash\ncurl -X GET http://localhost:6333/collections/{collection_name}\n```\n\n```python\nclient.get_collection(collection_name=\"{collection_name}\")\n```\n\n```typescript\nclient.getCollection(\"{collection_name}\");\n```\n\n```rust\nclient.collection_info(\"{collection_name}\").await?;\n```\n\n```java\nclient.getCollectionInfoAsync(\"{collection_name}\").get();\n```\n\n```csharp\nawait client.GetCollectionInfoAsync(\"{collection_name}\");\n```\n\n```go\nimport \"context\"\n\nclient.GetCollectionInfo(context.Background(), \"{collection_name}\")\n```\n\nExpected result\n\n```json\n{\n    \"result\": {\n        \"status\": \"green\",\n        \"optimizer_status\": \"ok\",\n        \"indexed_vectors_count\": 1024232,\n        \"points_count\": 1068786,\n        \"segments_count\": 31,\n        \"config\": {\n            \"params\": {\n                \"vectors\": {\n                    \"size\": 384,\n                    \"distance\": \"Cosine\"\n                },\n                \"shard_number\": 1,\n                \"replication_factor\": 1,\n                \"write_consistency_factor\": 1,\n                \"on_disk_payload\": false\n            },\n            \"hnsw_config\": {\n                \"m\": 16,\n                \"ef_construct\": 100,\n                \"full_scan_threshold\": 10000,\n                \"max_indexing_threads\": 0\n            },\n            \"optimizer_config\": {\n                \"deleted_threshold\": 0.2,\n                \"vacuum_min_vector_number\": 1000,\n                \"default_segment_number\": 0,\n                \"max_segment_size\": null,\n                \"memmap_threshold\": null,\n                \"indexing_threshold\": 20000,\n                \"flush_interval_sec\": 5,\n                \"max_optimization_threads\": 1\n            },\n            \"wal_config\": {\n                \"wal_capacity_mb\": 32,\n                \"wal_segments_ahead\": 0\n            }\n        },\n        \"payload_schema\": {}\n    },\n    \"status\": \"ok\",\n    \"time\": 0.00010143\n}\n```\n\nIf you insert the vectors into the collection, the `status` field may become `yellow` whilst it is optimizing. It will become `green` once all the points are successfully processed.\n\nThe following color statuses are possible:\n\n-  `green`: collection is ready\n-  `yellow`: collection is optimizing\n-  `grey`: collection is pending optimization ([help](#grey-collection-status.md))\n-  `red`: an error occurred which the engine could not recover from\n\n### Grey collection status\n\n*Available as of v1.9.0*",
    "metadata": {
      "chunk_id": 11,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 992,
      "character_count": 3890,
      "created_at": "2025-10-16T17:42:22.449403",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 11,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "A collection may have the grey  status or show optimizations pending, awaiting update operation as optimization status. This state is normally caused by restarting a Qdrant instance while optimizations were ongoing.\n\nIt means the collection has optimizations pending, but they are paused. You must send any update operation to trigger and start the optimizations again.\n\nFor example:\n\n```http\nPATCH /collections/{collection_name}\n{\n    \"optimizers_config\": {}\n}\n```\n\n```bash\ncurl -X PATCH http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"optimizers_config\": {}\n  }'\n```\n\n```python\nclient.update_collection(\n    collection_name=\"{collection_name}\",\n    optimizer_config=models.OptimizersConfigDiff(),\n)\n```\n\n```typescript\nclient.updateCollection(\"{collection_name}\", {\n  optimizers_config: {},\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{OptimizersConfigDiffBuilder, UpdateCollectionBuilder};\n\nclient\n    .update_collection(\n        UpdateCollectionBuilder::new(\"{collection_name}\")\n            .optimizers_config(OptimizersConfigDiffBuilder::default()),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.grpc.Collections.OptimizersConfigDiff;\nimport io.qdrant.client.grpc.Collections.UpdateCollection;\n\nclient.updateCollectionAsync(\n    UpdateCollection.newBuilder()\n        .setCollectionName(\"{collection_name}\")\n        .setOptimizersConfig(\n            OptimizersConfigDiff.getDefaultInstance())\n        .build());\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpdateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\toptimizersConfig: new OptimizersConfigDiff { }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.UpdateCollection(context.Background(), &qdrant.UpdateCollection{\n\tCollectionName:   \"{collection_name}\",\n\tOptimizersConfig: &qdrant.OptimizersConfigDiff{},\n})\n```\n\nAlternatively you may use the `Trigger Optimizers` button in the [Qdrant Web UI](https://qdrant.tech/documentation/web-ui/). It is shown next to the grey collection status on the collection info page.\n\n### Approximate point and vector counts\n\nYou may be interested in the count attributes:\n\n- `points_count` - total number of objects (vectors and their payloads) stored in the collection\n- `indexed_vectors_count` - total number of vectors stored in the HNSW or sparse index. Qdrant does not store all the vectors in the index, but only if an index segment might be created for a given configuration.\n\nThe above counts are not exact, but should be considered approximate. Depending on how you use Qdrant these may give very different numbers than what you may expect. Its therefore important **not** to rely on them.\n\nMore specifically, these numbers represent the count of points and vectors in Qdrants internal storage. Internally, Qdrant may temporarily duplicate points as part of automatic optimizations. It may keep changed or deleted points for a bit. And it may delay indexing of new points. All of that is for optimization reasons.\n\nUpdates you do are therefore not directly reflected in these numbers. If you see a wildly different count of points, it will likely resolve itself once a new round of automatic optimizations is completed.\n\nTo clarify: these numbers dont represent the exact amount of points or vectors you have inserted, nor does it represent the exact number of distinguishable points or vectors you can query. If you want to know exact counts, refer to the [count API](https://qdrant.tech/documentation/concepts/points/#counting-points).\n\n*Note: these numbers may be removed in a future version of Qdrant.*\n\n### Indexing vectors in HNSW\n\nIn some cases, you might be surprised the value of `indexed_vectors_count` is lower than you expected. This is an intended behaviour and depends on the [optimizer configuration](https://qdrant.tech/documentation/concepts/optimizer/). A new index segment is built if the size of non-indexed vectors is higher than the value of `indexing_threshold`(in kB). If your collection is very small or the dimensionality of the vectors is low, there might be no HNSW segment created and `indexed_vectors_count` might be equal to `0`.\n\nIt is possible to reduce the `indexing_threshold` for an existing collection by [updating collection parameters](#update-collection-parameters.md).\n\n## Collection aliases",
    "metadata": {
      "chunk_id": 12,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 993,
      "character_count": 4524,
      "created_at": "2025-10-16T17:42:22.457697",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 12,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "In a production environment, it is sometimes necessary to switch different versions of vectors seamlessly. For example, when upgrading to a new version of the neural network.\n\nThere is no way to stop the service and rebuild the collection with new vectors in these situations. Aliases are additional names for existing collections. All queries to the collection can also be done identically, using an alias instead of the collection name.\n\nThus, it is possible to build a second collection in the background and then switch alias from the old to the new collection. Since all changes of aliases happen atomically, no concurrent requests will be affected during the switch.\n\n### Create alias\n\n```http\nPOST /collections/aliases\n{\n    \"actions\": [\n        {\n            \"create_alias\": {\n                \"collection_name\": \"example_collection\",\n                \"alias_name\": \"production_collection\"\n            }\n        }\n    ]\n}\n```\n\n```bash\ncurl -X POST http://localhost:6333/collections/aliases \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"actions\": [\n        {\n            \"create_alias\": {\n                \"collection_name\": \"example_collection\",\n                \"alias_name\": \"production_collection\"\n            }\n        }\n    ]\n}'\n```\n\n```python\nclient.update_collection_aliases(\n    change_aliases_operations=[\n        models.CreateAliasOperation(\n            create_alias=models.CreateAlias(\n                collection_name=\"example_collection\", alias_name=\"production_collection\"\n            )\n        )\n    ]\n)\n```\n\n```typescript\nclient.updateCollectionAliases({\n  actions: [\n    {\n      create_alias: {\n        collection_name: \"example_collection\",\n        alias_name: \"production_collection\",\n      },\n    },\n  ],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::CreateAliasBuilder;\n\nclient\n    .create_alias(CreateAliasBuilder::new(\n        \"example_collection\",\n        \"production_collection\",\n    ))\n    .await?;\n```\n\n```java\nclient.createAliasAsync(\"production_collection\", \"example_collection\").get();\n```\n\n```csharp\nawait client.CreateAliasAsync(aliasName: \"production_collection\", collectionName: \"example_collection\");\n```\n\n```go\nimport \"context\"\n\nclient.CreateAlias(context.Background(), \"production_collection\", \"example_collection\")\n```\n\n### Remove alias\n\n```http\nPOST /collections/aliases\n{\n    \"actions\": [\n        {\n            \"delete_alias\": {\n                \"alias_name\": \"production_collection\"\n            }\n        }\n    ]\n}\n```\n\n```bash\ncurl -X POST http://localhost:6333/collections/aliases \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"actions\": [\n        {\n            \"delete_alias\": {\n                \"alias_name\": \"production_collection\"\n            }\n        }\n    ]\n}'\n```\n\n```python\nclient.update_collection_aliases(\n    change_aliases_operations=[\n        models.DeleteAliasOperation(\n            delete_alias=models.DeleteAlias(alias_name=\"production_collection\")\n        ),\n    ]\n)\n```\n\n```typescript\nclient.updateCollectionAliases({\n  actions: [\n    {\n      delete_alias: {\n        alias_name: \"production_collection\",\n      },\n    },\n  ],\n});\n```\n\n```rust\nclient.delete_alias(\"production_collection\").await?;\n```\n\n```java\nclient.deleteAliasAsync(\"production_collection\").get();\n```\n\n```csharp\nawait client.DeleteAliasAsync(\"production_collection\");\n```\n\n```go\nimport \"context\"\n\nclient.DeleteAlias(context.Background(), \"production_collection\")\n```\n\n### Switch collection\n\nMultiple alias actions are performed atomically. For example, you can switch underlying collection with the following command:\n\n```http\nPOST /collections/aliases\n{\n    \"actions\": [\n        {\n            \"delete_alias\": {\n                \"alias_name\": \"production_collection\"\n            }\n        },\n        {\n            \"create_alias\": {\n                \"collection_name\": \"example_collection\",\n                \"alias_name\": \"production_collection\"\n            }\n        }\n    ]\n}\n```\n\n```bash\ncurl -X POST http://localhost:6333/collections/aliases \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"actions\": [\n        {\n            \"delete_alias\": {\n                \"alias_name\": \"production_collection\"\n            }\n        },\n        {\n            \"create_alias\": {\n                \"collection_name\": \"example_collection\",\n                \"alias_name\": \"production_collection\"\n            }\n        }\n    ]\n}'\n```\n\n```python\nclient.update_collection_aliases(\n    change_aliases_operations=[\n        models.DeleteAliasOperation(\n            delete_alias=models.DeleteAlias(alias_name=\"production_collection\")\n        ),\n        models.CreateAliasOperation(\n            create_alias=models.CreateAlias(\n                collection_name=\"example_collection\", alias_name=\"production_collection\"\n            )\n        ),\n    ]\n)\n```",
    "metadata": {
      "chunk_id": 13,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 969,
      "character_count": 4797,
      "created_at": "2025-10-16T17:42:22.467575",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 13,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```typescript\nclient.updateCollectionAliases({\n  actions: [\n    {\n      delete_alias: {\n        alias_name: \"production_collection\",\n      },\n    },\n    {\n      create_alias: {\n        collection_name: \"example_collection\",\n        alias_name: \"production_collection\",\n      },\n    },\n  ],\n});\n```\n\n```rust\nuse qdrant_client::qdrant::CreateAliasBuilder;\n\nclient.delete_alias(\"production_collection\").await?;\nclient\n    .create_alias(CreateAliasBuilder::new(\n        \"example_collection\",\n        \"production_collection\",\n    ))\n    .await?;\n```\n\n```java\nclient.deleteAliasAsync(\"production_collection\").get();\nclient.createAliasAsync(\"production_collection\", \"example_collection\").get();\n```\n\n```csharp\nawait client.DeleteAliasAsync(\"production_collection\");\nawait client.CreateAliasAsync(aliasName: \"production_collection\", collectionName: \"example_collection\");\n```\n\n```go\nimport \"context\"\n\nclient.DeleteAlias(context.Background(), \"production_collection\")\nclient.CreateAlias(context.Background(), \"production_collection\", \"example_collection\")\n```\n\n### List collection aliases\n\n```http\nGET /collections/{collection_name}/aliases\n```\n\n```bash\ncurl -X GET http://localhost:6333/collections/{collection_name}/aliases\n```\n\n```python\nfrom qdrant_client import QdrantClient\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.get_collection_aliases(collection_name=\"{collection_name}\")\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.getCollectionAliases(\"{collection_name}\");\n```\n\n```rust\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient.list_collection_aliases(\"{collection_name}\").await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient.listCollectionAliasesAsync(\"{collection_name}\").get();\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ListCollectionAliasesAsync(\"{collection_name}\");\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.ListCollectionAliases(context.Background(), \"{collection_name}\")\n```\n\n### List all aliases\n\n```http\nGET /aliases\n```\n\n```bash\ncurl -X GET http://localhost:6333/aliases\n```\n\n```python\nfrom qdrant_client import QdrantClient\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.get_aliases()\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.getAliases();\n```\n\n```rust\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient.list_aliases().await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient.listAliasesAsync().get();\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ListAliasesAsync();\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.ListAliases(context.Background())\n```\n\n### List all collections\n\n```http\nGET /collections\n```\n\n```bash\ncurl -X GET http://localhost:6333/collections\n```\n\n```python\nfrom qdrant_client import QdrantClient\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.get_collections()\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.getCollections();\n```\n\n```rust\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient.list_collections().await?;\n```",
    "metadata": {
      "chunk_id": 14,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1022,
      "character_count": 4042,
      "created_at": "2025-10-16T17:42:22.488122",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 14,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient.listCollectionsAsync().get();\n```\n\n```csharp\nusing Qdrant.Client;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.ListCollectionsAsync();\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.ListCollections(context.Background())\n```\n\n##### Was this page useful?\n\nYes No\n\nThank you for your feedback! \n\nWe are sorry to hear that.  You can [edit](https:/github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/collections.md) this page on GitHub, or [create](https://github.com/qdrant/landing_page/issues/new/choose) a GitHub issue.\n\nOn this page:\n\n- [Collections](#collections.md)\n\n- [Setting up multitenancy](#setting-up-multitenancy.md)\n\n- [Create a collection](#create-a-collection.md)\n\n- [Create collection from another collection](#create-collection-from-another-collection.md)\n    - [Collection with multiple vectors](#collection-with-multiple-vectors.md)\n    - [Vector datatypes](#vector-datatypes.md)\n    - [Collection with sparse vectors](#collection-with-sparse-vectors.md)\n    - [Check collection existence](#check-collection-existence.md)\n    - [Delete collection](#delete-collection.md)\n    - [Update collection parameters](#update-collection-parameters.md)\n\n- [Collection info](#collection-info.md)\n\n- [Grey collection status](#grey-collection-status.md)\n    - [Approximate point and vector counts](#approximate-point-and-vector-counts.md)\n    - [Indexing vectors in HNSW](#indexing-vectors-in-hnsw.md)\n\n- [Collection aliases](#collection-aliases.md)\n\n- [Create alias](#create-alias.md)\n    - [Remove alias](#remove-alias.md)\n    - [Switch collection](#switch-collection.md)\n    - [List collection aliases](#list-collection-aliases.md)\n    - [List all aliases](#list-all-aliases.md)\n    - [List all collections](#list-all-collections.md)\n\n* [Edit on Github](https://github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/concepts/collections.md)\n* [Create an issue](https://github.com/qdrant/landing_page/issues/new/choose)\n\n#### Ready to get started with Qdrant?\n\n[Start Free](https://qdrant.to/cloud/)\n\n 2025 Qdrant.\n\n[Terms](https://qdrant.tech/legal/terms_and_conditions/) [Privacy Policy](https://qdrant.tech/legal/privacy-policy/) [Impressum](https://qdrant.tech/legal/impressum/)",
    "metadata": {
      "chunk_id": 15,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 664,
      "character_count": 2592,
      "created_at": "2025-10-16T17:42:22.492464",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 15,
      "file_relative_path": "qdrant_documentation\\documentation_concepts_collections\\_documentation_concepts_collections_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  }
]