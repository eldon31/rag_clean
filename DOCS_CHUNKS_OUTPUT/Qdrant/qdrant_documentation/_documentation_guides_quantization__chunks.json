[
  {
    "text": "Quantization - Qdrant\n\n[](https://qdrant.tech/)\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\nSearch\n\n[Log in](https://cloud.qdrant.io/login) [Start Free](https://cloud.qdrant.io/signup)\n\nSearch\n\n- [Qdrant](https://qdrant.tech/documentation/)\n- [Cloud](https://qdrant.tech/documentation/cloud-intro/)\n- [Build](https://qdrant.tech/documentation/build/)\n- [Learn](https://qdrant.tech/articles/)\n- [API Reference](https://api.qdrant.tech/api-reference)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)\n\n- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)",
    "metadata": {
      "chunk_id": 0,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 965,
      "character_count": 3780,
      "created_at": "2025-10-16T17:42:27.270076",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 0,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n### Getting Started\n\n[What is Qdrant?](https://qdrant.tech/documentation/overview/)\n\n- [Understanding Vector Search in Qdrant](https://qdrant.tech/documentation/overview/vector-search/)\n\n[Local Quickstart](https://qdrant.tech/documentation/quickstart/)\n\n[API & SDKs](https://qdrant.tech/documentation/interfaces/)\n\n[Qdrant Web UI](https://qdrant.tech/documentation/web-ui/)\n\n### User Manual\n\n[Concepts](https://qdrant.tech/documentation/concepts/)\n\n- [Collections](https://qdrant.tech/documentation/concepts/collections/)\n- [Points](https://qdrant.tech/documentation/concepts/points/)\n- [Vectors](https://qdrant.tech/documentation/concepts/vectors/)\n- [Payload](https://qdrant.tech/documentation/concepts/payload/)\n- [Search](https://qdrant.tech/documentation/concepts/search/)\n- [Explore](https://qdrant.tech/documentation/concepts/explore/)\n- [Hybrid Queries](https://qdrant.tech/documentation/concepts/hybrid-queries/)\n- [Filtering](https://qdrant.tech/documentation/concepts/filtering/)\n- [Optimizer](https://qdrant.tech/documentation/concepts/optimizer/)\n- [Storage](https://qdrant.tech/documentation/concepts/storage/)\n- [Indexing](https://qdrant.tech/documentation/concepts/indexing/)\n- [Snapshots](https://qdrant.tech/documentation/concepts/snapshots/)\n\n[Guides](https://qdrant.tech/documentation/guides/installation/)",
    "metadata": {
      "chunk_id": 1,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 852,
      "character_count": 3535,
      "created_at": "2025-10-16T17:42:27.275325",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 1,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "- [Installation](https://qdrant.tech/documentation/guides/installation/)\n- [Administration](https://qdrant.tech/documentation/guides/administration/)\n- [Running with GPU](https://qdrant.tech/documentation/guides/running-with-gpu/)\n- [Capacity Planning](https://qdrant.tech/documentation/guides/capacity-planning/)\n- [Optimize Performance](https://qdrant.tech/documentation/guides/optimize/)\n- [Multitenancy](https://qdrant.tech/documentation/guides/multiple-partitions/)\n- [Distributed Deployment](https://qdrant.tech/documentation/guides/distributed_deployment/)\n- [Quantization](https://qdrant.tech/documentation/guides/quantization/)\n- [Monitoring & Telemetry](https://qdrant.tech/documentation/guides/monitoring/)\n- [Configuration](https://qdrant.tech/documentation/guides/configuration/)\n- [Security](https://qdrant.tech/documentation/guides/security/)\n- [Usage Statistics](https://qdrant.tech/documentation/guides/usage-statistics/)\n- [Troubleshooting](https://qdrant.tech/documentation/guides/common-errors/)\n\n### Ecosystem\n\n[FastEmbed](https://qdrant.tech/documentation/fastembed/)\n\n- [Quickstart](https://qdrant.tech/documentation/fastembed/fastembed-quickstart/)\n- [FastEmbed & Qdrant](https://qdrant.tech/documentation/fastembed/fastembed-semantic-search/)\n- [Working with miniCOIL](https://qdrant.tech/documentation/fastembed/fastembed-minicoil/)\n- [Working with SPLADE](https://qdrant.tech/documentation/fastembed/fastembed-splade/)\n- [Working with ColBERT](https://qdrant.tech/documentation/fastembed/fastembed-colbert/)\n- [Reranking with FastEmbed](https://qdrant.tech/documentation/fastembed/fastembed-rerankers/)\n\n[Qdrant MCP Server](https://github.com/qdrant/mcp-server-qdrant)\n\n### Tutorials\n\n[Vector Search Basics](https://qdrant.tech/documentation/beginner-tutorials/)\n\n- [Semantic Search 101](https://qdrant.tech/documentation/beginner-tutorials/search-beginners/)\n- [Build a Neural Search Service](https://qdrant.tech/documentation/beginner-tutorials/neural-search/)\n- [Setup Hybrid Search with FastEmbed](https://qdrant.tech/documentation/beginner-tutorials/hybrid-search-fastembed/)\n- [Measure Search Quality](https://qdrant.tech/documentation/beginner-tutorials/retrieval-quality/)\n\n[Advanced Retrieval](https://qdrant.tech/documentation/advanced-tutorials/)\n\n- [How to Use Multivector Representations with Qdrant Effectively](https://qdrant.tech/documentation/advanced-tutorials/using-multivector-representations/)\n- [Reranking in Hybrid Search](https://qdrant.tech/documentation/advanced-tutorials/reranking-hybrid-search/)\n- [Search Through Your Codebase](https://qdrant.tech/documentation/advanced-tutorials/code-search/)\n- [Build a Recommendation System with Collaborative Filtering](https://qdrant.tech/documentation/advanced-tutorials/collaborative-filtering/)\n- [Scaling PDF Retrieval with Qdrant](https://qdrant.tech/documentation/advanced-tutorials/pdf-retrieval-at-scale/)\n\n[Using the Database](https://qdrant.tech/documentation/database-tutorials/)\n\n- [Bulk Upload Vectors](https://qdrant.tech/documentation/database-tutorials/bulk-upload/)\n- [Create & Restore Snapshots](https://qdrant.tech/documentation/database-tutorials/create-snapshot/)\n- [Large Scale Search](https://qdrant.tech/documentation/database-tutorials/large-scale-search/)\n- [Load a HuggingFace Dataset](https://qdrant.tech/documentation/database-tutorials/huggingface-datasets/)\n- [Build With Async API](https://qdrant.tech/documentation/database-tutorials/async-api/)\n- [Migration to Qdrant](https://qdrant.tech/documentation/database-tutorials/migration/)\n- [Static Embeddings. Should you pay attention?](https://qdrant.tech/documentation/database-tutorials/static-embeddings/)\n\n### Support\n\n[FAQ](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n\n- [Qdrant Fundamentals](https://qdrant.tech/documentation/faq/qdrant-fundamentals/)\n- [Database Optimization](https://qdrant.tech/documentation/faq/database-optimization/)\n\n[Release Notes](https://github.com/qdrant/qdrant/releases)\n\n- [Documentation](https://qdrant.tech/documentation/)\n-\n- [Guides](https://qdrant.tech/documentation/guides/)\n-\n- Quantization\n\n# Quantization",
    "metadata": {
      "chunk_id": 2,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1006,
      "character_count": 4142,
      "created_at": "2025-10-16T17:42:27.280988",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 2,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "Quantization is an optional feature in Qdrant that enables efficient storage and search of high-dimensional vectors. By transforming original vectors into a new representations, quantization compresses data while preserving close to original relative distances between vectors. Different quantization methods have different mechanics and tradeoffs. We will cover them in this section.\n\nQuantization is primarily used to reduce the memory footprint and accelerate the search process in high-dimensional vector spaces. In the context of the Qdrant, quantization allows you to optimize the search engine for specific use cases, striking a balance between accuracy, storage efficiency, and search speed.\n\nThere are tradeoffs associated with quantization. On the one hand, quantization allows for significant reductions in storage requirements and faster search times. This can be particularly beneficial in large-scale applications where minimizing the use of resources is a top priority. On the other hand, quantization introduces an approximation error, which can lead to a slight decrease in search quality. The level of this tradeoff depends on the quantization method and its parameters, as well as the characteristics of the data.\n\n## Scalar Quantization\n\n*Available as of v1.1.0*\n\nScalar quantization, in the context of vector search engines, is a compression technique that compresses vectors by reducing the number of bits used to represent each vector component.\n\nFor instance, Qdrant uses 32-bit floating numbers to represent the original vector components. Scalar quantization allows you to reduce the number of bits used to 8. In other words, Qdrant performs `float32 -> uint8` conversion for each vector component. Effectively, this means that the amount of memory required to store a vector is reduced by a factor of 4.\n\nIn addition to reducing the memory footprint, scalar quantization also speeds up the search process. Qdrant uses a special SIMD CPU instruction to perform fast vector comparison. This instruction works with 8-bit integers, so the conversion to `uint8` allows Qdrant to perform the comparison faster.\n\nThe main drawback of scalar quantization is the loss of accuracy. The `float32 -> uint8` conversion introduces an error that can lead to a slight decrease in search quality. However, this error is usually negligible, and tends to be less significant for high-dimensional vectors. In our experiments, we found that the error introduced by scalar quantization is usually less than 1%.\n\nHowever, this value depends on the data and the quantization parameters. Please refer to the [Quantization Tips](#quantization-tips.md) section for more information on how to optimize the quantization parameters for your use case.\n\n## Binary Quantization\n\n*Available as of v1.5.0*\n\nBinary quantization is an extreme case of scalar quantization. This feature lets you represent each vector component as a single bit, effectively reducing the memory footprint by a **factor of 32**.\n\nThis is the fastest quantization method, since it lets you perform a vector comparison with a few CPU instructions.\n\nBinary quantization can achieve up to a **40x** speedup compared to the original vectors.\n\nHowever, binary quantization is only efficient for high-dimensional vectors and require a centered distribution of vector components.\n\nAt the moment, binary quantization shows good accuracy results with the following models:\n\n- OpenAI `text-embedding-ada-002` - 1536d tested with [dbpedia dataset](https://huggingface.co/datasets/KShivendu/dbpedia-entities-openai-1M) achieving 0.98 recall\\@100 with 4x oversampling\n- Cohere AI `embed-english-v2.0` - 4096d tested on Wikipedia embeddings - 0.98 recall\\@50 with 2x oversampling\n\nModels with a lower dimensionality or a different distribution of vector components may require additional experiments to find the optimal quantization parameters.\n\nWe recommend using binary quantization only with rescoring enabled, as it can significantly improve the search quality with just a minor performance impact. Additionally, oversampling can be used to tune the tradeoff between search speed and search quality in the query time.\n\n### Binary Quantization as Hamming Distance\n\nThe additional benefit of this method is that you can efficiently emulate Hamming distance with dot product.\n\nSpecifically, if original vectors contain `{-1, 1}` as possible values, then the dot product of two vectors is equal to the Hamming distance by simply replacing `-1` with `0` and `1` with `1`.\n\n**Sample truth table**\n\n| Vector 1 | Vector 2 | Dot product |\n| -------- | -------- | ----------- |\n| 1        | 1        | 1           |\n| 1        | -1       | -1          |\n| -1       | 1        | -1          |\n| -1       | -1       | 1           |",
    "metadata": {
      "chunk_id": 3,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 993,
      "character_count": 4777,
      "created_at": "2025-10-16T17:42:27.288855",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 3,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "| Vector 1 | Vector 2 | Hamming distance |\n| -------- | -------- | ---------------- |\n| 1        | 1        | 0                |\n| 1        | 0        | 1                |\n| 0        | 1        | 1                |\n| 0        | 0        | 0                |\n\nAs you can see, both functions are equal up to a constant factor, which makes similarity search equivalent. Binary quantization makes it efficient to compare vectors using this representation.\n\n### 1.5-Bit and 2-Bit Quantization\n\n*Available as of v1.15.0*\n\n**Binary quantization** storage can use **2 and 1.5 bits** per dimension, improving precision for smaller vectors. One-bit compression resulted in significant data loss and precision drops for vectors smaller than a thousand dimensions, often requiring expensive rescoring. 2-bit quantization offers 16X compression compared to 32X with one bit, improving performance for smaller vector dimensions. The 1.5-bit quantization compression offers 24X compression and intermediate accuracy.\n\nA major limitation of binary quantization is poor handling of values close to zero. 2-bit quantization addresses this by explicitly representing zeros using an efficient scoring mechanism. In the case of 1.5-bit quantization, the zero-bit is shared between two values, balancing the efficiency of binary quantization with the accuracy improvements of 2-bit quantization, especially when 2-bit BQ requires too much memory.\n\nIn order to build 2-bit representation, Qdrant computes values distribution and then assigns bit values to 3 possible buckets:\n\n- `-1` - 00\n- `0` - 01\n- `1` - 11\n\n1.5-bit quantization is similar, but merges buckets of pairs of elements into a binary triptets\n\n2-bit quantization\n\nSee how to set up 1.5-bit and 2-bit quantization in the [following section](#set-up-bit-depth.md).\n\n### Asymmetric Quantization\n\n*Available as of v1.15.0*\n\nThe **Asymmetric Quantization** technique allows qdrant to use different vector encoding algorithm for stored vectors and for queries. Particularly interesting combination is a Binary stored vectors and Scalar quantized queries.\n\nAsymmetric quantization\n\nThis approach maintains storage size and RAM usage similar to binary quantization while offering improved precision. It is beneficial for memory-constrained deployments, or where the bottleneck is disk I/O rather than CPU. This is particularly useful for indexing millions of vectors as it improves precision without sacrificing much because the limitation in such scenarios is disk speed, not CPU. This approach requires less rescoring for the same quality output.\n\nSee how to set up Asymmetric Quantization quantization in the [following section](#set-up-asymmetric-quantization.md)\n\n## Product Quantization\n\n*Available as of v1.2.0*\n\nProduct quantization is a method of compressing vectors to minimize their memory usage by dividing them into chunks and quantizing each segment individually. Each chunk is approximated by a centroid index that represents the original vector component. The positions of the centroids are determined through the utilization of a clustering algorithm such as k-means. For now, Qdrant uses only 256 centroids, so each centroid index can be represented by a single byte.\n\nProduct quantization can compress by a more prominent factor than a scalar one. But there are some tradeoffs. Product quantization distance calculations are not SIMD-friendly, so it is slower than scalar quantization. Also, product quantization has a loss of accuracy, so it is recommended to use it only for high-dimensional vectors.\n\nPlease refer to the [Quantization Tips](#quantization-tips.md) section for more information on how to optimize the quantization parameters for your use case.\n\n## How to choose the right quantization method\n\nHere is a brief table of the pros and cons of each quantization method:\n\n| Quantization method | Accuracy   | Speed     | Compression |\n| ------------------- | ---------- | --------- | ----------- |\n| Scalar              | 0.99       | up to x2  | 4           |\n| Product             | 0.7        | 0.5       | up to 64    |\n| Binary (1 bit)      | 0.95\\*     | up to x40 | 32          |\n| Binary (1.5 bit)    | 0.95\\*\\*   | up to x30 | 24          |\n| Binary (2 bit)      | 0.95\\*\\*\\* | up to x20 | 16          |\n\n- `*` - for compatible models with high-dimensional vectors (approx. 1536+ dimensions)\n\n- `**` - for compatible models with medium-dimensional vectors (approx. 1024-1536 dimensions)\n\n- `***` - for compatible models with low-dimensional vectors (approx. 768-1024 dimensions)",
    "metadata": {
      "chunk_id": 4,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1023,
      "character_count": 4552,
      "created_at": "2025-10-16T17:42:27.297787",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 4,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "- **Binary Quantization** is the fastest method and the most memory-efficient, but it requires a centered distribution of vector components. It is recommended to use with tested models only.\n\n- If you are planning to use binary quantization with low or medium-dimensional vectors (approx. 512-1024 dimensions), it is recommended to use 1.5-bit or 2-bit quantization as well as asymmetric quantization feature.\n\n- **Scalar Quantization** is the most universal method, as it provides a good balance between accuracy, speed, and compression. It is recommended as default quantization if binary quantization is not applicable.\n\n- **Product Quantization** may provide a better compression ratio, but it has a significant loss of accuracy and is slower than scalar quantization. It is recommended if the memory footprint is the top priority and the search speed is not critical.\n\n## Setting up Quantization in Qdrant\n\nYou can configure quantization for a collection by specifying the quantization parameters in the `quantization_config` section of the collection configuration.\n\nQuantization will be automatically applied to all vectors during the indexation process. Quantized vectors are stored alongside the original vectors in the collection, so you will still have access to the original vectors if you need them.\n\n*Available as of v1.1.1*\n\nThe `quantization_config` can also be set on a per vector basis by specifying it in a named vector.\n\n### Setting up Scalar Quantization\n\nTo enable scalar quantization, you need to specify the quantization parameters in the `quantization_config` section of the collection configuration.\n\nWhen enabling scalar quantization on an existing collection, use a PATCH request or the corresponding `update_collection` method and omit the vector configuration, as it’s already defined.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 768,\n      \"distance\": \"Cosine\"\n    },\n    \"quantization_config\": {\n        \"scalar\": {\n            \"type\": \"int8\",\n            \"quantile\": 0.99,\n            \"always_ram\": true\n        }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=768, distance=models.Distance.COSINE),\n    quantization_config=models.ScalarQuantization(\n        scalar=models.ScalarQuantizationConfig(\n            type=models.ScalarType.INT8,\n            quantile=0.99,\n            always_ram=True,\n        ),\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: {\n    size: 768,\n    distance: \"Cosine\",\n  },\n  quantization_config: {\n    scalar: {\n      type: \"int8\",\n      quantile: 0.99,\n      always_ram: true,\n    },\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    CreateCollectionBuilder, Distance, QuantizationType, ScalarQuantizationBuilder,\n    VectorParamsBuilder,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(768, Distance::Cosine))\n            .quantization_config(\n                ScalarQuantizationBuilder::default()\n                    .r#type(QuantizationType::Int8.into())\n                    .quantile(0.99)\n                    .always_ram(true),\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.QuantizationConfig;\nimport io.qdrant.client.grpc.Collections.QuantizationType;\nimport io.qdrant.client.grpc.Collections.ScalarQuantization;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());",
    "metadata": {
      "chunk_id": 5,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 940,
      "character_count": 4209,
      "created_at": "2025-10-16T17:42:27.304529",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 5,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(768)\n                            .setDistance(Distance.Cosine)\n                            .build())\n                    .build())\n            .setQuantizationConfig(\n                QuantizationConfig.newBuilder()\n                    .setScalar(\n                        ScalarQuantization.newBuilder()\n                            .setType(QuantizationType.Int8)\n                            .setQuantile(0.99f)\n                            .setAlwaysRam(true)\n                            .build())\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n collectionName: \"{collection_name}\",\n vectorsConfig: new VectorParams { Size = 768, Distance = Distance.Cosine },\n quantizationConfig: new QuantizationConfig\n {\n  Scalar = new ScalarQuantization\n  {\n   Type = QuantizationType.Int8,\n   Quantile = 0.99f,\n   AlwaysRam = true\n  }\n }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     768,\n\t\tDistance: qdrant.Distance_Cosine,\n\t}),\n\tQuantizationConfig: qdrant.NewQuantizationScalar(\n\t\t&qdrant.ScalarQuantization{\n            Type:      qdrant.QuantizationType_Int8,\n\t\t\tQuantile:  qdrant.PtrOf(float32(0.99)),\n\t\t\tAlwaysRam: qdrant.PtrOf(true),\n\t\t},\n\t),\n})\n```\n\nThere are 3 parameters that you can specify in the `quantization_config` section:\n\n`type` - the type of the quantized vector components. Currently, Qdrant supports only `int8`.\n\n`quantile` - the quantile of the quantized vector components. The quantile is used to calculate the quantization bounds. For instance, if you specify `0.99` as the quantile, 1% of extreme values will be excluded from the quantization bounds.\n\nUsing quantiles lower than `1.0` might be useful if there are outliers in your vector components. This parameter only affects the resulting precision and not the memory footprint. It might be worth tuning this parameter if you experience a significant decrease in search quality.\n\n`always_ram` - whether to keep quantized vectors always cached in RAM or not. By default, quantized vectors are loaded in the same way as the original vectors. However, in some setups you might want to keep quantized vectors in RAM to speed up the search process.\n\nIn this case, you can set `always_ram` to `true` to store quantized vectors in RAM.\n\n### Setting up Binary Quantization\n\nTo enable binary quantization, you need to specify the quantization parameters in the `quantization_config` section of the collection configuration.\n\nWhen enabling binary quantization on an existing collection, use a PATCH request or the corresponding `update_collection` method and omit the vector configuration, as it’s already defined.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 1536,\n      \"distance\": \"Cosine\"\n    },\n    \"quantization_config\": {\n        \"binary\": {\n            \"always_ram\": true\n        }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=1536, distance=models.Distance.COSINE),\n    quantization_config=models.BinaryQuantization(\n        binary=models.BinaryQuantizationConfig(\n            always_ram=True,\n        ),\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: {\n    size: 1536,\n    distance: \"Cosine\",\n  },\n  quantization_config: {\n    binary: {\n      always_ram: true,\n    },\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    BinaryQuantizationBuilder, CreateCollectionBuilder, Distance, VectorParamsBuilder,\n};\nuse qdrant_client::Qdrant;",
    "metadata": {
      "chunk_id": 6,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1013,
      "character_count": 4470,
      "created_at": "2025-10-16T17:42:27.312527",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 6,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "let client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(1536, Distance::Cosine))\n            .quantization_config(BinaryQuantizationBuilder::new(true)),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.BinaryQuantization;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.QuantizationConfig;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(1536)\n                            .setDistance(Distance.Cosine)\n                            .build())\n                    .build())\n            .setQuantizationConfig(\n                QuantizationConfig.newBuilder()\n                    .setBinary(BinaryQuantization.newBuilder().setAlwaysRam(true).build())\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n collectionName: \"{collection_name}\",\n vectorsConfig: new VectorParams { Size = 1536, Distance = Distance.Cosine },\n quantizationConfig: new QuantizationConfig\n {\n  Binary = new BinaryQuantization { AlwaysRam = true }\n }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     1536,\n\t\tDistance: qdrant.Distance_Cosine,\n\t}),\n\tQuantizationConfig: qdrant.NewQuantizationBinary(\n\t\t&qdrant.BinaryQuantization{\n\t\t\tAlwaysRam: qdrant.PtrOf(true),\n\t\t},\n\t),\n})\n```\n\n`always_ram` - whether to keep quantized vectors always cached in RAM or not. By default, quantized vectors are loaded in the same way as the original vectors. However, in some setups you might want to keep quantized vectors in RAM to speed up the search process.\n\nIn this case, you can set `always_ram` to `true` to store quantized vectors in RAM.\n\n#### Set up bit depth\n\nTo enable 2bit or 1.5bit quantization, you need to specify `encoding` parameter in the `quantization_config` section of the collection configuration. Available values are `two_bits` and `one_and_half_bits`.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 1536,\n      \"distance\": \"Cosine\"\n    },\n    \"quantization_config\": {\n        \"binary\": {\n            \"encoding\": \"two_bits\",\n            \"always_ram\": true\n        }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=1536, distance=models.Distance.COSINE),\n    quantization_config=models.BinaryQuantization(\n        binary=models.BinaryQuantizationConfig(\n            encoding=models.BinaryQuantizationEncoding.TWO_BITS,\n            always_ram=True,\n        ),\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: {\n    size: 1536,\n    distance: \"Cosine\",\n  },\n  quantization_config: {\n    binary: {\n      encoding: \"two_bits\",\n      always_ram: true,\n    },\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    BinaryQuantizationBuilder,\n    CreateCollectionBuilder,\n    Distance,\n    VectorParamsBuilder,\n    BinaryQuantizationEncoding,\n};\nuse qdrant_client::Qdrant;",
    "metadata": {
      "chunk_id": 7,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1005,
      "character_count": 4320,
      "created_at": "2025-10-16T17:42:27.319246",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 7,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "let client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(1536, Distance::Cosine))\n            .quantization_config(BinaryQuantizationBuilder::new(true)\n                .encoding(BinaryQuantizationEncoding::TwoBits)\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.BinaryQuantization;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.QuantizationConfig;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\nimport io.qdrant.client.grpc.Collections.BinaryQuantizationEncoding;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(1536)\n                            .setDistance(Distance.Cosine)\n                            .build())\n                    .build())\n            .setQuantizationConfig(\n                QuantizationConfig.newBuilder()\n                    .setBinary(BinaryQuantization\n                        .newBuilder()\n                        .setEncoding(BinaryQuantizationEncoding.TwoBits)\n                        .setAlwaysRam(true)\n                        .build())\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n  collectionName: \"{collection_name}\",\n  vectorsConfig: new VectorParams { Size = 1536, Distance = Distance.Cosine },\n  quantizationConfig: new QuantizationConfig\n  {\n    Binary = new BinaryQuantization {\n      Encoding = BinaryQuantizationEncoding.TwoBits,\n      AlwaysRam = true\n    }\n  }\n);\n```\n\n```go\nimport (\n    \"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n    CollectionName: \"{collection_name}\",\n    VectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n        Size:     1536,\n        Distance: qdrant.Distance_Cosine,\n    }),\n    QuantizationConfig: qdrant.NewQuantizationBinary(\n        &qdrant.BinaryQuantization{\n            Encoding: qdrant.BinaryQuantizationEncoding_TwoBits.Enum(),\n            AlwaysRam: qdrant.PtrOf(true),\n        },\n    ),\n})\n```\n\n#### Set up asymmetric quantization\n\nTo enable asymmetric quantization, you need to specify `query_encoding` parameter in the `quantization_config` section of the collection configuration. Available values are:\n\n- `default` and `binary` - use regular binary quantization for the query.\n- `scalar8bits` - use 8bit quantization for the query.\n- `scalar4bits` - use 4bit quantization for the query.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 1536,\n      \"distance\": \"Cosine\"\n    },\n    \"quantization_config\": {\n        \"binary\": {\n            \"query_encoding\": \"scalar8bits\",\n            \"always_ram\": true\n        }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=1536, distance=models.Distance.COSINE),\n    quantization_config=models.BinaryQuantization(\n        binary=models.BinaryQuantizationConfig(\n            query_encoding=models.BinaryQuantizationQueryEncoding.SCALAR8BITS,\n            always_ram=True,\n        ),\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: {\n    size: 1536,\n    distance: \"Cosine\",\n  },\n  quantization_config: {\n    binary: {\n      query_encoding: \"scalar8bits\",\n      always_ram: true,\n    },\n  },\n});\n```",
    "metadata": {
      "chunk_id": 8,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 999,
      "character_count": 4461,
      "created_at": "2025-10-16T17:42:27.326708",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 8,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```rust\nuse qdrant_client::qdrant::{\n    BinaryQuantizationBuilder,\n    CreateCollectionBuilder,\n    Distance,\n    VectorParamsBuilder,\n    BinaryQuantizationQueryEncoding,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(1536, Distance::Cosine))\n            .quantization_config(\n                BinaryQuantizationBuilder::new(true)\n                    .query_encoding(BinaryQuantizationQueryEncoding::scalar8bits())\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.BinaryQuantization;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.QuantizationConfig;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\nimport io.qdrant.client.grpc.Collections.BinaryQuantizationQueryEncoding;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(1536)\n                            .setDistance(Distance.Cosine)\n                            .build())\n                    .build())\n            .setQuantizationConfig(\n                QuantizationConfig.newBuilder()\n                    .setBinary(BinaryQuantization.newBuilder()\n                        .setQueryEncoding(BinaryQuantizationQueryEncoding\n                            .newBuilder()\n                            .setSetting(BinaryQuantizationQueryEncoding.Setting.Scalar8Bits)\n                            .build())\n                        .setAlwaysRam(true)\n                        .build())\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n  collectionName: \"{collection_name}\",\n  vectorsConfig: new VectorParams { Size = 1536, Distance = Distance.Cosine },\n  quantizationConfig: new QuantizationConfig\n  {\n    Binary = new BinaryQuantization {\n      QueryEncoding = new BinaryQuantizationQueryEncoding\n      {\n        Setting = BinaryQuantizationQueryEncoding.Types.Setting.Scalar8Bits,\n      },\n      AlwaysRam = true\n    }\n  }\n);\n```\n\n```go\nimport (\n    \"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n    Host: \"localhost\",\n    Port: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n    CollectionName: \"{collection_name}\",\n    VectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n        Size:     1536,\n        Distance: qdrant.Distance_Cosine,\n    }),\n    QuantizationConfig: qdrant.NewQuantizationBinary(\n        &qdrant.BinaryQuantization{\n            QueryEncoding: qdrant.NewBinaryQuantizationQueryEncodingSetting(BinaryQuantizationQueryEncoding_Scalar8Bits),\n            AlwaysRam: qdrant.PtrOf(true),\n        },\n    ),\n})\n```\n\n### Setting up Product Quantization\n\nTo enable product quantization, you need to specify the quantization parameters in the `quantization_config` section of the collection configuration.\n\nWhen enabling product quantization on an existing collection, use a PATCH request or the corresponding `update_collection` method and omit the vector configuration, as it’s already defined.\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 768,\n      \"distance\": \"Cosine\"\n    },\n    \"quantization_config\": {\n        \"product\": {\n            \"compression\": \"x16\",\n            \"always_ram\": true\n        }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=768, distance=models.Distance.COSINE),\n    quantization_config=models.ProductQuantization(\n        product=models.ProductQuantizationConfig(\n            compression=models.CompressionRatio.X16,\n            always_ram=True,\n        ),\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });",
    "metadata": {
      "chunk_id": 9,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1012,
      "character_count": 4727,
      "created_at": "2025-10-16T17:42:27.335609",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 9,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client.createCollection(\"{collection_name}\", {\n  vectors: {\n    size: 768,\n    distance: \"Cosine\",\n  },\n  quantization_config: {\n    product: {\n      compression: \"x16\",\n      always_ram: true,\n    },\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    CompressionRatio, CreateCollectionBuilder, Distance, ProductQuantizationBuilder,\n    VectorParamsBuilder,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(768, Distance::Cosine))\n            .quantization_config(\n                ProductQuantizationBuilder::new(CompressionRatio::X16.into()).always_ram(true),\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.CompressionRatio;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.ProductQuantization;\nimport io.qdrant.client.grpc.Collections.QuantizationConfig;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(768)\n                            .setDistance(Distance.Cosine)\n                            .build())\n                    .build())\n            .setQuantizationConfig(\n                QuantizationConfig.newBuilder()\n                    .setProduct(\n                        ProductQuantization.newBuilder()\n                            .setCompression(CompressionRatio.x16)\n                            .setAlwaysRam(true)\n                            .build())\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n collectionName: \"{collection_name}\",\n vectorsConfig: new VectorParams { Size = 768, Distance = Distance.Cosine },\n quantizationConfig: new QuantizationConfig\n {\n  Product = new ProductQuantization { Compression = CompressionRatio.X16, AlwaysRam = true }\n }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     768,\n\t\tDistance: qdrant.Distance_Cosine,\n\t}),\n\tQuantizationConfig: qdrant.NewQuantizationProduct(\n\t\t&qdrant.ProductQuantization{\n\t\t\tCompression: qdrant.CompressionRatio_x16,\n\t\t\tAlwaysRam:   qdrant.PtrOf(true),\n\t\t},\n\t),\n})\n```\n\nThere are two parameters that you can specify in the `quantization_config` section:\n\n`compression` - compression ratio. Compression ratio represents the size of the quantized vector in bytes divided by the size of the original vector in bytes. In this case, the quantized vector will be 16 times smaller than the original vector.\n\n`always_ram` - whether to keep quantized vectors always cached in RAM or not. By default, quantized vectors are loaded in the same way as the original vectors. However, in some setups you might want to keep quantized vectors in RAM to speed up the search process. Then set `always_ram` to `true`.\n\n### Disabling Quantization\n\nTo disable quantization in an existing collection, you can do the following:\n\n```http\nPATCH /collections/{collection_name}\n{\n    \"quantization_config\": \"Disabled\"\n}\n```\n\n```bash\ncurl -X PATCH http://localhost:6333/collections/{collection_name} \\\n  -H 'Content-Type: application/json' \\\n  --data-raw '{\n    \"quantization_config\": \"Disabled\"\n  }'\n```\n\n```python\nclient.update_collection(\n    collection_name=\"{collection_name}\",\n    quantization_config=models.Disabled.DISABLED,\n)\n```\n\n```typescript\nclient.updateCollection(\"{collection_name}\", {\n    quantization_config: 'Disabled'\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{Disabled, UpdateCollectionBuilder};",
    "metadata": {
      "chunk_id": 10,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1012,
      "character_count": 4530,
      "created_at": "2025-10-16T17:42:27.344366",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 10,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client\n    .update_collection(UpdateCollectionBuilder::new(\"{collection_name}\").quantization_config(Disabled {}))\n    .await?;\n```\n\n```java\nimport io.qdrant.client.grpc.Collections.Disabled;\nimport io.qdrant.client.grpc.Collections.QuantizationConfigDiff;\nimport io.qdrant.client.grpc.Collections.UpdateCollection;\n\nclient.updateCollectionAsync(\n    UpdateCollection.newBuilder()\n        .setCollectionName(\"{collection_name}\")\n        .setQuantizationConfig(\n            QuantizationConfigDiff.newBuilder()\n                .setDisabled(Disabled.getDefaultInstance())\n                .build())\n        .build());\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.UpdateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\tquantizationConfig: new QuantizationConfigDiff { Disabled = new Disabled() }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.UpdateCollection(context.Background(), &qdrant.UpdateCollection{\n\tCollectionName:     \"{collection_name}\",\n\tQuantizationConfig: qdrant.NewQuantizationDiffDisabled(),\n})\n```\n\n### Searching with Quantization\n\nOnce you have configured quantization for a collection, you don’t need to do anything extra to search with quantization. Qdrant will automatically use quantized vectors if they are available.\n\nHowever, there are a few options that you can use to control the search process:\n\n```http\nPOST /collections/{collection_name}/points/query\n{\n    \"query\": [0.2, 0.1, 0.9, 0.7],\n    \"params\": {\n        \"quantization\": {\n            \"ignore\": false,\n            \"rescore\": true,\n            \"oversampling\": 2.0\n        }\n    },\n    \"limit\": 10\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.query_points(\n    collection_name=\"{collection_name}\",\n    query=[0.2, 0.1, 0.9, 0.7],\n    search_params=models.SearchParams(\n        quantization=models.QuantizationSearchParams(\n            ignore=False,\n            rescore=True,\n            oversampling=2.0,\n        )\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.query(\"{collection_name}\", {\n    query: [0.2, 0.1, 0.9, 0.7],\n    params: {\n        quantization: {\n            ignore: false,\n            rescore: true,\n            oversampling: 2.0,\n        },\n    },\n    limit: 10,\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    QuantizationSearchParamsBuilder, QueryPointsBuilder, SearchParamsBuilder,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n    \nclient\n    .query(\n        QueryPointsBuilder::new(\"{collection_name}\")\n            .query(vec![0.2, 0.1, 0.9, 0.7])\n            .limit(10)\n            .params(\n                SearchParamsBuilder::default().quantization(\n                    QuantizationSearchParamsBuilder::default()\n                        .ignore(false)\n                        .rescore(true)\n                        .oversampling(2.0),\n                ),\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.QuantizationSearchParams;\nimport io.qdrant.client.grpc.Points.QueryPoints;\nimport io.qdrant.client.grpc.Points.SearchParams;\n\nimport static io.qdrant.client.QueryFactory.nearest;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient.queryAsync(\n        QueryPoints.newBuilder()\n                .setCollectionName(\"{collection_name}\")\n                .setQuery(nearest(0.2f, 0.1f, 0.9f, 0.7f))\n                .setParams(\n                        SearchParams.newBuilder()\n                                .setQuantization(\n                                        QuantizationSearchParams.newBuilder()\n                                                .setIgnore(false)\n                                                .setRescore(true)\n                                                .setOversampling(2.0)\n                                                .build())\n                                .build())\n                .setLimit(10)\n                .build())\n        .get();\n```",
    "metadata": {
      "chunk_id": 11,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1014,
      "character_count": 4413,
      "created_at": "2025-10-16T17:42:27.351449",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 11,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.QueryAsync(\n\tcollectionName: \"{collection_name}\",\n\tquery: new float[] { 0.2f, 0.1f, 0.9f, 0.7f },\n\tsearchParams: new SearchParams\n\t{\n\t\tQuantization = new QuantizationSearchParams\n\t\t{\n\t\t\tIgnore = false,\n\t\t\tRescore = true,\n\t\t\tOversampling = 2.0\n\t\t}\n\t},\n\tlimit: 10\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Query(context.Background(), &qdrant.QueryPoints{\n\tCollectionName: \"{collection_name}\",\n\tQuery:          qdrant.NewQuery(0.2, 0.1, 0.9, 0.7),\n\tParams: &qdrant.SearchParams{\n\t\tQuantization: &qdrant.QuantizationSearchParams{\n\t\t\tIgnore:       qdrant.PtrOf(false),\n\t\t\tRescore:      qdrant.PtrOf(true),\n\t\t\tOversampling: qdrant.PtrOf(2.0),\n\t\t},\n\t},\n})\n```\n\n`ignore` - Toggle whether to ignore quantized vectors during the search process. By default, Qdrant will use quantized vectors if they are available.\n\n`rescore` - Having the original vectors available, Qdrant can re-evaluate top-k search results using the original vectors. This can improve the search quality, but may slightly decrease the search speed, compared to the search without rescore. It is recommended to disable rescore only if the original vectors are stored on a slow storage (e.g. HDD or network storage). By default, rescore is enabled.\n\n**Available as of v1.3.0**\n\n`oversampling` - Defines how many extra vectors should be pre-selected using quantized index, and then re-scored using original vectors. For example, if oversampling is 2.4 and limit is 100, then 240 vectors will be pre-selected using quantized index, and then top-100 will be returned after re-scoring. Oversampling is useful if you want to tune the tradeoff between search speed and search quality in the query time.\n\n## Quantization tips\n\n#### Accuracy tuning\n\nIn this section, we will discuss how to tune the search precision. The fastest way to understand the impact of quantization on the search quality is to compare the search results with and without quantization.\n\nIn order to disable quantization, you can set `ignore` to `true` in the search request:\n\n```http\nPOST /collections/{collection_name}/points/query\n{\n    \"query\": [0.2, 0.1, 0.9, 0.7],\n    \"params\": {\n        \"quantization\": {\n            \"ignore\": true\n        }\n    },\n    \"limit\": 10\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.query_points(\n    collection_name=\"{collection_name}\",\n    query=[0.2, 0.1, 0.9, 0.7],\n    search_params=models.SearchParams(\n        quantization=models.QuantizationSearchParams(\n            ignore=True,\n        )\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.query(\"{collection_name}\", {\n    query: [0.2, 0.1, 0.9, 0.7],\n    params: {\n        quantization: {\n            ignore: true,\n        },\n    },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    QuantizationSearchParamsBuilder, QueryPointsBuilder, SearchParamsBuilder,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .query(\n        QueryPointsBuilder::new(\"{collection_name}\")\n            .query(vec![0.2, 0.1, 0.9, 0.7])\n            .limit(3)\n            .params(\n                SearchParamsBuilder::default()\n                    .quantization(QuantizationSearchParamsBuilder::default().ignore(true)),\n            ),\n    )\n    .await?;\n```",
    "metadata": {
      "chunk_id": 12,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 984,
      "character_count": 3643,
      "created_at": "2025-10-16T17:42:27.358759",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 12,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.QuantizationSearchParams;\nimport io.qdrant.client.grpc.Points.QueryPoints;\nimport io.qdrant.client.grpc.Points.SearchParams;\n\nimport static io.qdrant.client.QueryFactory.nearest;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient.queryAsync(\n        QueryPoints.newBuilder()\n                .setCollectionName(\"{collection_name}\")\n                .setQuery(nearest(0.2f, 0.1f, 0.9f, 0.7f))\n                .setParams(\n                        SearchParams.newBuilder()\n                                .setQuantization(\n                                        QuantizationSearchParams.newBuilder().setIgnore(true).build())\n                                .build())\n                .setLimit(10)\n                .build())\n        .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.QueryAsync(\n\tcollectionName: \"{collection_name}\",\n\tquery: new float[] { 0.2f, 0.1f, 0.9f, 0.7f },\n\tsearchParams: new SearchParams\n\t{\n\t\tQuantization = new QuantizationSearchParams { Ignore = true }\n\t},\n\tlimit: 10\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Query(context.Background(), &qdrant.QueryPoints{\n\tCollectionName: \"{collection_name}\",\n\tQuery:          qdrant.NewQuery(0.2, 0.1, 0.9, 0.7),\n\tParams: &qdrant.SearchParams{\n\t\tQuantization: &qdrant.QuantizationSearchParams{\n\t\t\tIgnore: qdrant.PtrOf(false),\n\t\t},\n\t},\n})\n```\n\n- **Adjust the quantile parameter**: The quantile parameter in scalar quantization determines the quantization bounds. By setting it to a value lower than 1.0, you can exclude extreme values (outliers) from the quantization bounds. For example, if you set the quantile to 0.99, 1% of the extreme values will be excluded. By adjusting the quantile, you find an optimal value that will provide the best search quality for your collection.\n\n- **Enable rescore**: Having the original vectors available, Qdrant can re-evaluate top-k search results using the original vectors. On large collections, this can improve the search quality, with just minor performance impact.\n\n#### Memory and speed tuning\n\nIn this section, we will discuss how to tune the memory and speed of the search process with quantization.\n\nThere are 3 possible modes to place storage of vectors within the qdrant collection:\n\n- **All in RAM** - all vector, original and quantized, are loaded and kept in RAM. This is the fastest mode, but requires a lot of RAM. Enabled by default.\n\n- **Original on Disk, quantized in RAM** - this is a hybrid mode, allows to obtain a good balance between speed and memory usage. Recommended scenario if you are aiming to shrink the memory footprint while keeping the search speed.\n\nThis mode is enabled by setting `always_ram` to `true` in the quantization config while using memmap storage:\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n        \"size\": 768,\n        \"distance\": \"Cosine\",\n        \"on_disk\": true\n    },\n    \"quantization_config\": {\n        \"scalar\": {\n            \"type\": \"int8\",\n            \"always_ram\": true\n        }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=768, distance=models.Distance.COSINE, on_disk=True),\n    quantization_config=models.ScalarQuantization(\n        scalar=models.ScalarQuantizationConfig(\n            type=models.ScalarType.INT8,\n            always_ram=True,\n        ),\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });",
    "metadata": {
      "chunk_id": 13,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 965,
      "character_count": 3973,
      "created_at": "2025-10-16T17:42:27.366162",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 13,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client.createCollection(\"{collection_name}\", {\n  vectors: {\n    size: 768,\n    distance: \"Cosine\",\n    on_disk: true,\n  },\n  quantization_config: {\n    scalar: {\n      type: \"int8\",\n      always_ram: true,\n    },\n  },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    CreateCollectionBuilder, Distance, QuantizationType, ScalarQuantizationBuilder,\n    VectorParamsBuilder,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(768, Distance::Cosine))\n            .quantization_config(\n                ScalarQuantizationBuilder::default()\n                    .r#type(QuantizationType::Int8.into())\n                    .always_ram(true),\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.OptimizersConfigDiff;\nimport io.qdrant.client.grpc.Collections.QuantizationConfig;\nimport io.qdrant.client.grpc.Collections.QuantizationType;\nimport io.qdrant.client.grpc.Collections.ScalarQuantization;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(768)\n                            .setDistance(Distance.Cosine)\n                            .setOnDisk(true)\n                            .build())\n                    .build())\n            .setQuantizationConfig(\n                QuantizationConfig.newBuilder()\n                    .setScalar(\n                        ScalarQuantization.newBuilder()\n                            .setType(QuantizationType.Int8)\n                            .setAlwaysRam(true)\n                            .build())\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n\tcollectionName: \"{collection_name}\",\n\tvectorsConfig: new VectorParams { Size = 768, Distance = Distance.Cosine, OnDisk = true },\n\tquantizationConfig: new QuantizationConfig\n\t{\n\t\tScalar = new ScalarQuantization { Type = QuantizationType.Int8, AlwaysRam = true }\n\t}\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     768,\n\t\tDistance: qdrant.Distance_Cosine,\n\t\tOnDisk:   qdrant.PtrOf(true),\n\t}),\n\tQuantizationConfig: qdrant.NewQuantizationScalar(&qdrant.ScalarQuantization{\n\t\tType:      qdrant.QuantizationType_Int8,\n\t\tAlwaysRam: qdrant.PtrOf(true),\n\t}),\n})\n```\n\nIn this scenario, the number of disk reads may play a significant role in the search speed. In a system with high disk latency, the re-scoring step may become a bottleneck.\n\nConsider disabling `rescore` to improve the search speed:\n\n```http\nPOST /collections/{collection_name}/points/query\n{\n    \"query\": [0.2, 0.1, 0.9, 0.7],\n    \"params\": {\n        \"quantization\": {\n            \"rescore\": false\n        }\n    },\n    \"limit\": 10\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.query_points(\n    collection_name=\"{collection_name}\",\n    query=[0.2, 0.1, 0.9, 0.7],\n    search_params=models.SearchParams(\n        quantization=models.QuantizationSearchParams(rescore=False)\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });",
    "metadata": {
      "chunk_id": 14,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1021,
      "character_count": 4302,
      "created_at": "2025-10-16T17:42:27.374274",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 14,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "client.query(\"{collection_name}\", {\n    query: [0.2, 0.1, 0.9, 0.7],\n    params: {\n        quantization: {\n            rescore: false,\n        },\n    },\n});\n```\n\n```rust\nuse qdrant_client::qdrant::{\n    QuantizationSearchParamsBuilder, QueryPointsBuilder, SearchParamsBuilder,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .query(\n        QueryPointsBuilder::new(\"{collection_name}\")\n            .query(vec![0.2, 0.1, 0.9, 0.7])\n            .limit(3)\n            .params(\n                SearchParamsBuilder::default()\n                    .quantization(QuantizationSearchParamsBuilder::default().rescore(false)),\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Points.QuantizationSearchParams;\nimport io.qdrant.client.grpc.Points.QueryPoints;\nimport io.qdrant.client.grpc.Points.SearchParams;\n\nimport static io.qdrant.client.QueryFactory.nearest;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient.queryAsync(\n        QueryPoints.newBuilder()\n                .setCollectionName(\"{collection_name}\")\n                .setQuery(nearest(0.2f, 0.1f, 0.9f, 0.7f))\n                .setParams(\n                        SearchParams.newBuilder()\n                                .setQuantization(\n                                        QuantizationSearchParams.newBuilder().setRescore(false).build())\n                                .build())\n                .setLimit(3)\n                .build())\n        .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.QueryAsync(\n\tcollectionName: \"{collection_name}\",\n\tquery: new float[] { 0.2f, 0.1f, 0.9f, 0.7f },\n\tsearchParams: new SearchParams\n\t{\n\t\tQuantization = new QuantizationSearchParams { Rescore = false }\n\t},\n\tlimit: 3\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.Query(context.Background(), &qdrant.QueryPoints{\n\tCollectionName: \"{collection_name}\",\n\tQuery:          qdrant.NewQuery(0.2, 0.1, 0.9, 0.7),\n\tParams: &qdrant.SearchParams{\n\t\tQuantization: &qdrant.QuantizationSearchParams{\n\t\t\tRescore: qdrant.PtrOf(false),\n\t\t},\n\t},\n})\n```\n\n- **All on Disk** - all vectors, original and quantized, are stored on disk. This mode allows to achieve the smallest memory footprint, but at the cost of the search speed.\n\nIt is recommended to use this mode if you have a large collection and fast storage (e.g. SSD or NVMe).\n\nThis mode is enabled by setting `always_ram` to `false` in the quantization config while using mmap storage:\n\n```http\nPUT /collections/{collection_name}\n{\n    \"vectors\": {\n      \"size\": 768,\n      \"distance\": \"Cosine\",\n      \"on_disk\": true\n    },\n    \"quantization_config\": {\n        \"scalar\": {\n            \"type\": \"int8\",\n            \"always_ram\": false\n        }\n    }\n}\n```\n\n```python\nfrom qdrant_client import QdrantClient, models\n\nclient = QdrantClient(url=\"http://localhost:6333\")\n\nclient.create_collection(\n    collection_name=\"{collection_name}\",\n    vectors_config=models.VectorParams(size=768, distance=models.Distance.COSINE, on_disk=True),\n    quantization_config=models.ScalarQuantization(\n        scalar=models.ScalarQuantizationConfig(\n            type=models.ScalarType.INT8,\n            always_ram=False,\n        ),\n    ),\n)\n```\n\n```typescript\nimport { QdrantClient } from \"@qdrant/js-client-rest\";\n\nconst client = new QdrantClient({ host: \"localhost\", port: 6333 });\n\nclient.createCollection(\"{collection_name}\", {\n  vectors: {\n    size: 768,\n    distance: \"Cosine\",\n    on_disk: true,\n  },\n  quantization_config: {\n    scalar: {\n      type: \"int8\",\n      always_ram: false,\n    },\n  },\n});\n```",
    "metadata": {
      "chunk_id": 15,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 1011,
      "character_count": 3910,
      "created_at": "2025-10-16T17:42:27.382603",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 15,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "```rust\nuse qdrant_client::qdrant::{\n    CreateCollectionBuilder, Distance, QuantizationType, ScalarQuantizationBuilder,\n    VectorParamsBuilder,\n};\nuse qdrant_client::Qdrant;\n\nlet client = Qdrant::from_url(\"http://localhost:6334\").build()?;\n\nclient\n    .create_collection(\n        CreateCollectionBuilder::new(\"{collection_name}\")\n            .vectors_config(VectorParamsBuilder::new(768, Distance::Cosine).on_disk(true))\n            .quantization_config(\n                ScalarQuantizationBuilder::default()\n                    .r#type(QuantizationType::Int8.into())\n                    .always_ram(false),\n            ),\n    )\n    .await?;\n```\n\n```java\nimport io.qdrant.client.QdrantClient;\nimport io.qdrant.client.QdrantGrpcClient;\nimport io.qdrant.client.grpc.Collections.CreateCollection;\nimport io.qdrant.client.grpc.Collections.Distance;\nimport io.qdrant.client.grpc.Collections.OptimizersConfigDiff;\nimport io.qdrant.client.grpc.Collections.QuantizationConfig;\nimport io.qdrant.client.grpc.Collections.QuantizationType;\nimport io.qdrant.client.grpc.Collections.ScalarQuantization;\nimport io.qdrant.client.grpc.Collections.VectorParams;\nimport io.qdrant.client.grpc.Collections.VectorsConfig;\n\nQdrantClient client =\n    new QdrantClient(QdrantGrpcClient.newBuilder(\"localhost\", 6334, false).build());\n\nclient\n    .createCollectionAsync(\n        CreateCollection.newBuilder()\n            .setCollectionName(\"{collection_name}\")\n            .setVectorsConfig(\n                VectorsConfig.newBuilder()\n                    .setParams(\n                        VectorParams.newBuilder()\n                            .setSize(768)\n                            .setDistance(Distance.Cosine)\n                            .setOnDisk(true)\n                            .build())\n                    .build())\n            .setQuantizationConfig(\n                QuantizationConfig.newBuilder()\n                    .setScalar(\n                        ScalarQuantization.newBuilder()\n                            .setType(QuantizationType.Int8)\n                            .setAlwaysRam(false)\n                            .build())\n                    .build())\n            .build())\n    .get();\n```\n\n```csharp\nusing Qdrant.Client;\nusing Qdrant.Client.Grpc;\n\nvar client = new QdrantClient(\"localhost\", 6334);\n\nawait client.CreateCollectionAsync(\n collectionName: \"{collection_name}\",\n vectorsConfig: new VectorParams { Size = 768, Distance = Distance.Cosine, OnDisk = true},\n quantizationConfig: new QuantizationConfig\n {\n  Scalar = new ScalarQuantization { Type = QuantizationType.Int8, AlwaysRam = false }\n }\n);\n```\n\n```go\nimport (\n\t\"context\"\n\n\"github.com/qdrant/go-client/qdrant\"\n)\n\nclient, err := qdrant.NewClient(&qdrant.Config{\n\tHost: \"localhost\",\n\tPort: 6334,\n})\n\nclient.CreateCollection(context.Background(), &qdrant.CreateCollection{\n\tCollectionName: \"{collection_name}\",\n\tVectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{\n\t\tSize:     768,\n\t\tDistance: qdrant.Distance_Cosine,\n\t\tOnDisk:   qdrant.PtrOf(true),\n\t}),\n\tQuantizationConfig: qdrant.NewQuantizationScalar(\n\t\t&qdrant.ScalarQuantization{\n\t\t\tType:      qdrant.QuantizationType_Int8,\n\t\t\tAlwaysRam: qdrant.PtrOf(false),\n\t\t},\n\t),\n})\n```\n\n##### Was this page useful?\n\nYes No\n\nThank you for your feedback! 🙏\n\nWe are sorry to hear that. 😔 You can [edit](https:/github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/guides/quantization.md) this page on GitHub, or [create](https://github.com/qdrant/landing_page/issues/new/choose) a GitHub issue.\n\nOn this page:\n\n- [Quantization](#quantization.md)\n\n- [Scalar Quantization](#scalar-quantization.md)\n\n- [Binary Quantization](#binary-quantization.md)\n\n- [Binary Quantization as Hamming Distance](#binary-quantization-as-hamming-distance.md)\n    - [1.5-Bit and 2-Bit Quantization](#15-bit-and-2-bit-quantization.md)\n    - [Asymmetric Quantization](#asymmetric-quantization.md)\n\n- [Product Quantization](#product-quantization.md)\n\n- [How to choose the right quantization method](#how-to-choose-the-right-quantization-method.md)\n\n- [Setting up Quantization in Qdrant](#setting-up-quantization-in-qdrant.md)",
    "metadata": {
      "chunk_id": 16,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 969,
      "character_count": 4135,
      "created_at": "2025-10-16T17:42:27.391412",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 16,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  },
  {
    "text": "- [Setting up Scalar Quantization](#setting-up-scalar-quantization.md)\n    - [Setting up Binary Quantization](#setting-up-binary-quantization.md)\n    - [Setting up Product Quantization](#setting-up-product-quantization.md)\n    - [Disabling Quantization](#disabling-quantization.md)\n    - [Searching with Quantization](#searching-with-quantization.md)\n\n- [Quantization tips](#quantization-tips.md)\n    -\n\n* [Edit on Github](https://github.com/qdrant/landing_page/tree/master/qdrant-landing/content/documentation/guides/quantization.md)\n* [Create an issue](https://github.com/qdrant/landing_page/issues/new/choose)\n\n#### Ready to get started with Qdrant?\n\n[Start Free](https://qdrant.to/cloud/)\n\n© 2025 Qdrant.\n\n[Terms](https://qdrant.tech/legal/terms_and_conditions/) [Privacy Policy](https://qdrant.tech/legal/privacy-policy/) [Impressum](https://qdrant.tech/legal/impressum/)",
    "metadata": {
      "chunk_id": 17,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\Qdrant\\qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "input_type": "qdrant",
      "chunking_strategy": "platform_documentation",
      "token_count": 233,
      "character_count": 876,
      "created_at": "2025-10-16T17:42:27.392011",
      "parent_context": null,
      "semantic_type": "qdrant",
      "collection_name": "Qdrant",
      "subfolder_name": "qdrant_documentation",
      "collection_strategy": "platform_documentation",
      "chunk_index_in_file": 17,
      "file_relative_path": "qdrant_documentation\\documentation_guides_quantization\\_documentation_guides_quantization_.md",
      "collection_context": "Qdrant/qdrant_documentation"
    }
  }
]