[
  {
    "text": "Constrained Types | pydantic/pydantic | DeepWiki\n\n[Index your code with Devin](private-repo.md)\n\n[DeepWiki](https://deepwiki.com)\n\n[DeepWiki](.md)\n\n[pydantic/pydantic](https://github.com/pydantic/pydantic \"Open repository\")\n\n[Index your code with](private-repo.md)\n\n[Devin](private-repo.md)\n\nShare\n\nLast indexed: 11 October 2025 ([76ef0b](https://github.com/pydantic/pydantic/commits/76ef0b08))\n\n- [Overview](pydantic/pydantic/1-overview.md)\n- [Core Model System](pydantic/pydantic/2-core-model-system.md)\n- [BaseModel](pydantic/pydantic/2.1-basemodel.md)\n- [Field System](pydantic/pydantic/2.2-field-system.md)\n- [Model Configuration](pydantic/pydantic/2.3-model-configuration.md)\n- [Type System](pydantic/pydantic/3-type-system.md)\n- [Constrained Types](pydantic/pydantic/3.1-constrained-types.md)\n- [Network Types](pydantic/pydantic/3.2-network-types.md)\n- [TypeAdapter](pydantic/pydantic/3.3-typeadapter.md)\n- [Generics and Forward References](pydantic/pydantic/3.4-generics-and-forward-references.md)\n- [Validation and Serialization](pydantic/pydantic/4-validation-and-serialization.md)\n- [Validators](pydantic/pydantic/4.1-validators.md)\n- [Serializers](pydantic/pydantic/4.2-serializers.md)\n- [JSON Conversion](pydantic/pydantic/4.3-json-conversion.md)\n- [Schema Generation](pydantic/pydantic/5-schema-generation.md)\n- [Core Schema Generation](pydantic/pydantic/5.1-core-schema-generation.md)\n- [JSON Schema Generation](pydantic/pydantic/5.2-json-schema-generation.md)\n- [Advanced Features](pydantic/pydantic/6-advanced-features.md)\n- [Dataclass Support](pydantic/pydantic/6.1-dataclass-support.md)\n- [Function Validation](pydantic/pydantic/6.2-function-validation.md)\n- [RootModel and Computed Fields](pydantic/pydantic/6.3-rootmodel-and-computed-fields.md)\n- [Plugin System](pydantic/pydantic/6.4-plugin-system.md)\n- [Development and Deployment](pydantic/pydantic/7-development-and-deployment.md)\n- [Testing Framework](pydantic/pydantic/7.1-testing-framework.md)\n- [CI/CD Pipeline](pydantic/pydantic/7.2-cicd-pipeline.md)\n- [Documentation System](pydantic/pydantic/7.3-documentation-system.md)\n- [Versioning and Dependencies](pydantic/pydantic/7.4-versioning-and-dependencies.md)\n- [Migration and Compatibility](pydantic/pydantic/8-migration-and-compatibility.md)\n- [V1 to V2 Migration](pydantic/pydantic/8.1-v1-to-v2-migration.md)\n- [Backported Modules](pydantic/pydantic/8.2-backported-modules.md)\n\nMenu\n\n# Constrained Types\n\nRelevant source files\n\n- [pydantic/\\_\\_init\\_\\_.py](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/__init__.py)\n- [pydantic/errors.py](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/errors.py)\n- [pydantic/networks.py](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/networks.py)\n- [pydantic/types.py](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py)\n- [pydantic/validators.py](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/validators.py)\n- [tests/test\\_networks.py](https://github.com/pydantic/pydantic/blob/76ef0b08/tests/test_networks.py)\n- [tests/test\\_types.py](https://github.com/pydantic/pydantic/blob/76ef0b08/tests/test_types.py)",
    "metadata": {
      "chunk_id": 0,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "input_type": "pydantic_pydantic",
      "chunking_strategy": "programming_language_documentation",
      "token_count": 977,
      "character_count": 3147,
      "created_at": "2025-10-16T17:42:20.181459",
      "parent_context": null,
      "semantic_type": "pydantic_pydantic",
      "collection_name": "pydantic_pydantic",
      "subfolder_name": null,
      "collection_strategy": "programming_language_documentation",
      "chunk_index_in_file": 0,
      "file_relative_path": "Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "collection_context": "pydantic_pydantic"
    }
  },
  {
    "text": "Constrained Types in Pydantic provide a way to define additional restrictions on basic Python types, such as strings, integers, floats, and collections. These types ensure that values not only match the expected type but also comply with specific constraints like minimum/maximum values, string patterns, or collection lengths.\n\nThis page explains the various constrained types available in Pydantic, how they are implemented, and how to use them effectively. For information about custom types and validators, see [Type System](pydantic/pydantic/3-type-system.md).\n\n## Constrained Types Overview\n\nConstrained types are a key part of Pydantic's validation system. They extend basic Python types with additional validation requirements that are checked during model instantiation.\n\n```\n```\n\nSources: [pydantic/types.py149-832](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L149-L832) [pydantic/types.py836-904](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L836-L904)\n\nThe constrained types in Pydantic come in two forms:\n\n1. **Constraint Functions**: Functions like `constr()`, `conint()` that return a constrained version of a type\n2. **Predefined Constrained Types**: Ready-to-use types like `PositiveInt`, `StrictStr`, etc.\n\nSince Pydantic v2, the recommended approach is to use Python's `Annotated` type with field constraints rather than the legacy constraint functions.\n\n## Numeric Constrained Types\n\nPydantic provides constrained types for integers, floats, and decimals with various validation rules.\n\n### Integer Constraints\n\n```\n```\n\nSources: [pydantic/types.py151-235](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L151-L235) [pydantic/types.py238-363](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L238-L363)\n\nThe `conint` function creates a constrained integer type with the following parameters:\n\n- `strict`: When True, input must be an actual integer (not float or string)\n- `gt`: Greater than (exclusive lower bound)\n- `ge`: Greater than or equal (inclusive lower bound)\n- `lt`: Less than (exclusive upper bound)\n- `le`: Less than or equal (inclusive upper bound)\n- `multiple_of`: Input must be a multiple of this value\n\nPydantic also provides several predefined integer constrained types:\n\n| Type             | Description                      | Implementation                          |\n| ---------------- | -------------------------------- | --------------------------------------- |\n| `PositiveInt`    | Integer > 0                      | `Annotated[int, annotated_types.Gt(0)]` |\n| `NegativeInt`    | Integer < 0                      | `Annotated[int, annotated_types.Lt(0)]` |\n| `NonNegativeInt` | Integer ≥ 0                      | `Annotated[int, annotated_types.Ge(0)]` |\n| `NonPositiveInt` | Integer ≤ 0                      | `Annotated[int, annotated_types.Le(0)]` |\n| `StrictInt`      | Integer validated in strict mode | `Annotated[int, Strict()]`              |\n\n### Float Constraints\n\n```\n```\n\nSources: [pydantic/types.py411-497](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L411-L497) [pydantic/types.py500-645](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L500-L645)\n\nThe `confloat` function creates a constrained float type with the same parameters as `conint`, plus:\n\n- `allow_inf_nan`: When True, allows infinity and NaN values\n\nPredefined float constrained types include:\n\n| Type               | Description                    | Implementation                            |\n| ------------------ | ------------------------------ | ----------------------------------------- |\n| `PositiveFloat`    | Float > 0                      | `Annotated[float, annotated_types.Gt(0)]` |\n| `NegativeFloat`    | Float < 0                      | `Annotated[float, annotated_types.Lt(0)]` |\n| `NonNegativeFloat` | Float ≥ 0                      | `Annotated[float, annotated_types.Ge(0)]` |\n| `NonPositiveFloat` | Float ≤ 0                      | `Annotated[float, annotated_types.Le(0)]` |\n| `StrictFloat`      | Float validated in strict mode | `Annotated[float, Strict(True)]`          |\n| `FiniteFloat`      | Float that must be finite      | `Annotated[float, AllowInfNan(False)]`    |\n\n## String Constrained Types\n\nPydantic provides string constraints through the `constr` function and `StringConstraints` class.\n\n```\n```",
    "metadata": {
      "chunk_id": 1,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "input_type": "pydantic_pydantic",
      "chunking_strategy": "programming_language_documentation",
      "token_count": 1023,
      "character_count": 4387,
      "created_at": "2025-10-16T17:42:20.188932",
      "parent_context": null,
      "semantic_type": "pydantic_pydantic",
      "collection_name": "pydantic_pydantic",
      "subfolder_name": null,
      "collection_strategy": "programming_language_documentation",
      "chunk_index_in_file": 1,
      "file_relative_path": "Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "collection_context": "pydantic_pydantic"
    }
  },
  {
    "text": "Sources: [pydantic/types.py693-829](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L693-L829) [pydantic/types.py831-832](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L831-L832)\n\nThe `constr` function creates a constrained string type with the following parameters:\n\n- `strip_whitespace`: When True, strips leading and trailing whitespace\n- `to_upper`: When True, converts the string to uppercase\n- `to_lower`: When True, converts the string to lowercase\n- `strict`: When True, input must be an actual string\n- `min_length`: Minimum string length\n- `max_length`: Maximum string length\n- `pattern`: Regex pattern that the string must match\n\nIn Pydantic v2, the recommended approach is to use `Annotated` with `StringConstraints` instead of `constr`:\n\n```\n```\n\n## Collection Constrained Types\n\nPydantic provides constrained types for various collection types: lists, sets, frozensets, and bytes.\n\n```\n```\n\nSources: [pydantic/types.py663-684](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L663-L684) [pydantic/types.py839-904](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L839-L904)\n\n### Bytes Constraints\n\nThe `conbytes` function creates a constrained bytes type with parameters:\n\n- `min_length`: Minimum length in bytes\n- `max_length`: Maximum length in bytes\n- `strict`: When True, input must be an actual bytes object\n\n### List Constraints\n\nThe `conlist` function creates a constrained list type with parameters:\n\n- `item_type`: The type of items in the list\n- `min_length`: Minimum number of items\n- `max_length`: Maximum number of items\n\n### Set and FrozenSet Constraints\n\nThe `conset` and `confrozenset` functions create constrained set and frozenset types with similar parameters:\n\n- `item_type`: The type of items in the set\n- `min_length`: Minimum number of items\n- `max_length`: Maximum number of items\n\n## Usage Patterns\n\n### Using Constrained Types in Models\n\n```\n```\n\n### Modern Approach with Annotated\n\n```\n```\n\n## Integration with Schema Generation\n\nConstrained types automatically generate appropriate schema information that is used for validation and JSON Schema generation.\n\n```\n```\n\nSources: [pydantic/types.py151-235](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L151-L235) [pydantic/types.py411-497](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L411-L497) [pydantic/types.py750-828](https://github.com/pydantic/pydantic/blob/76ef0b08/pydantic/types.py#L750-L828)\n\nWhen a constrained type is used in a Pydantic model:\n\n1. The constraint is transformed into an `Annotated` type during schema generation\n2. The Pydantic validation engine uses these constraints to validate inputs\n3. JSON Schema generation includes the constraints in the resulting schema\n\n## Best Practices\n\n### Prefer Annotated over Constraint Functions\n\nPydantic recommends using `Annotated` with constraints rather than the legacy constraint functions:\n\n```\n```\n\nThe `conX` functions will be deprecated in Pydantic 3.0 in favor of the `Annotated` approach, which provides better static type checking and IDE support.\n\n### Common Use Cases\n\n1. **Validation with Transformation**:\n\n```\n   ```\n\n2. **Numeric Ranges**:\n\n```\n   ```\n\n3. **Pattern Matching**:\n\n```\n   ```\n\n## Testing Constrained Types\n\nWhen testing models with constrained types, it's important to test both valid and invalid inputs to ensure constraints are applied correctly:\n\n```\n```\n\nSources: [tests/test\\_types.py741-821](https://github.com/pydantic/pydantic/blob/76ef0b08/tests/test_types.py#L741-L821) [tests/test\\_types.py246-347](https://github.com/pydantic/pydantic/blob/76ef0b08/tests/test_types.py#L246-L347)\n\n## Related Features\n\nConstrained types work well with other Pydantic features:\n\n- **Field validators**: Apply custom validation logic beyond built-in constraints\n- **Type adapters**: Use constrained types with `TypeAdapter` for validation outside of models\n- **JSON Schema**: Constrained types generate appropriate JSON schema representations\n\nFor more information on related features, see:",
    "metadata": {
      "chunk_id": 2,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "input_type": "pydantic_pydantic",
      "chunking_strategy": "programming_language_documentation",
      "token_count": 1017,
      "character_count": 4099,
      "created_at": "2025-10-16T17:42:20.200443",
      "parent_context": null,
      "semantic_type": "pydantic_pydantic",
      "collection_name": "pydantic_pydantic",
      "subfolder_name": null,
      "collection_strategy": "programming_language_documentation",
      "chunk_index_in_file": 2,
      "file_relative_path": "Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "collection_context": "pydantic_pydantic"
    }
  },
  {
    "text": "- [Field System](pydantic/pydantic/2.2-field-system.md) for details on field configuration and validators\n- [Type Adapter](pydantic/pydantic/3.3-typeadapter.md) for using constrained types outside of models\n- [JSON Schema Generation](pydantic/pydantic/5.2-json-schema-generation.md) for how constraints appear in JSON schemas\n\nDismiss\n\nRefresh this wiki\n\nThis wiki was recently refreshed. Please wait 4 days to refresh again.\n\n### On this page\n\n- [Constrained Types](#constrained-types.md)\n- [Constrained Types Overview](#constrained-types-overview.md)\n- [Numeric Constrained Types](#numeric-constrained-types.md)\n- [Integer Constraints](#integer-constraints.md)\n- [Float Constraints](#float-constraints.md)\n- [String Constrained Types](#string-constrained-types.md)\n- [Collection Constrained Types](#collection-constrained-types.md)\n- [Bytes Constraints](#bytes-constraints.md)\n- [List Constraints](#list-constraints.md)\n- [Set and FrozenSet Constraints](#set-and-frozenset-constraints.md)\n- [Usage Patterns](#usage-patterns.md)\n- [Using Constrained Types in Models](#using-constrained-types-in-models.md)\n- [Modern Approach with Annotated](#modern-approach-with-annotated.md)\n- [Integration with Schema Generation](#integration-with-schema-generation.md)\n- [Best Practices](#best-practices.md)\n- [Prefer Annotated over Constraint Functions](#prefer-annotated-over-constraint-functions.md)\n- [Common Use Cases](#common-use-cases.md)\n- [Testing Constrained Types](#testing-constrained-types.md)\n- [Related Features](#related-features.md)",
    "metadata": {
      "chunk_id": 3,
      "source_file": "C:\\Users\\raze0\\Documents\\LLM_KNOWLEDGE_CREATOR\\RAG\\RAG_CLEAN\\Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "input_type": "pydantic_pydantic",
      "chunking_strategy": "programming_language_documentation",
      "token_count": 374,
      "character_count": 1537,
      "created_at": "2025-10-16T17:42:20.200953",
      "parent_context": null,
      "semantic_type": "pydantic_pydantic",
      "collection_name": "pydantic_pydantic",
      "subfolder_name": null,
      "collection_strategy": "programming_language_documentation",
      "chunk_index_in_file": 3,
      "file_relative_path": "Docs\\pydantic_pydantic\\_pydantic_pydantic_3.1-constrained-types.md",
      "collection_context": "pydantic_pydantic"
    }
  }
]